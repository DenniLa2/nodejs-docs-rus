<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>http - Node.js &mdash; Документация</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all" />
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js &mdash; Документация</h1>
      <div id="gtoc">
        <p><a href="index.html">Содержание</a> | <a href="all.html">Просмотреть на одной странице</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Содержание</h2><ul><li><a href="#hTTP">HTTP</a></li><li><a href="#http.Server">http.Server</a><ul><li><a href="#request_">request'</a></li><li><a href="#connection_">connection'</a></li><li><a href="#close_">close'</a></li><li><a href="#checkContinue_">checkContinue'</a></li><li><a href="#upgrade_">upgrade'</a></li><li><a href="#clientError_">clientError'</a></li><li><a href="#http.createServer">http.createServer(requestListener)</a></li><li><a href="#server.listen">server.listen(port, [hostname], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.close">server.close()</a></li></ul></li><li><a href="#http.ServerRequest">http.ServerRequest</a><ul><li><a href="#data_">data'</a></li><li><a href="#end_">end'</a></li><li><a href="#request.method">request.method</a></li><li><a href="#request.url">request.url</a></li><li><a href="#request.headers">request.headers</a></li><li><a href="#request.trailers">request.trailers</a></li><li><a href="#request.httpVersion">request.httpVersion</a></li><li><a href="#request.setEncoding">request.setEncoding(encoding=null)</a></li><li><a href="#request.pause">request.pause()</a></li><li><a href="#request.resume">request.resume()</a></li><li><a href="#request.connection">request.connection</a></li></ul></li><li><a href="#http.ServerResponse">http.ServerResponse</a><ul><li><a href="#response.writeContinue">response.writeContinue()</a></li><li><a href="#response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li><li><a href="#response.write">response.write(chunk, encoding='utf8')</a></li><li><a href="#response.addTrailers">response.addTrailers(headers)</a></li><li><a href="#response.end">response.end([data], [encoding])</a></li></ul></li><li><a href="#http.Client">http.Client</a><ul><li><a href="#upgrade_">upgrade'</a></li><li><a href="#continue_">continue'</a></li><li><a href="#http.createClient">http.createClient(port, host='localhost', secure=false, [credentials])</a></li><li><a href="#client.request">client.request(method='GET', path, [request_headers])</a></li><li><a href="#client.verifyPeer">client.verifyPeer()</a></li><li><a href="#client.getPeerCertificate">client.getPeerCertificate()</a></li></ul></li><li><a href="#http.ClientRequest">http.ClientRequest</a><ul><li><a href="#response_">response'</a></li><li><a href="#request.write">request.write(chunk, encoding='utf8')</a></li><li><a href="#request.end">request.end([data], [encoding])</a></li></ul></li><li><a href="#http.ClientResponse">http.ClientResponse</a><ul><li><a href="#data_">data'</a></li><li><a href="#end_">end'</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.httpVersion">response.httpVersion</a></li><li><a href="#response.headers">response.headers</a></li><li><a href="#response.trailers">response.trailers</a></li><li><a href="#response.setEncoding">response.setEncoding(encoding=null)</a></li><li><a href="#response.pause">response.pause()</a></li><li><a href="#response.resume">response.resume()</a></li><li><a href="#response.client">response.client</a></li></ul></li></ul><hr /></div>
<h2 id="hTTP">HTTP</h2>

<p>Для использования клиента и сервера HTTP необходимо подключить
соответствующий модуль с помощью <code>require('http')</code>.</p>

<p>Интерфейс HTTP спроектирован в Node таким образом, чтобы поддерживать многие
возможности протокола, которые традиционно было довольно сложно использовать.
В частности, большие сообщения с возможным chunk-encoding. Интерфейс никогда
не сохраняет в буфере целиком запрос или ответ, давая пользователю возможность
принимать и отправлять данные в потоковом режиме.</p>

<p>Заголовки сообщения HTTP представлены примерно таким объектом:</p>

<pre><code>{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'accept': '*/*' }</code></pre>

<p>Ключи приводятся к нижнему регистру. Значения не изменяются.</p>

<p>Для поддержки всего спектра возможных применений HTTP, соответствующее API
в Node довольно низкоуровневое. Оно основано на потоках и передаче сообщений.
Node разбирает HTTP-сообщение на заголовки и тело, остальное должен сделать
программист.</p>

<p>HTTPS поддерживается если на целевой платформе доступен OpenSSL.</p>

<h2 id="http.Server">http.Server</h2>

<p>Это <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_request_">Событие: 'request'</h3>

<p><code>function (request, response) { }</code></p>

<p>Генерируется каждый раз при получении запроса. Заметьте, что в течении одного
соединения может происходить несколько запросов (в случае keep-alive соединения).
Объект <code>request</code> — экземпляр <code>http.ServerRequest</code>,
объект <code>response</code> — экземпляр <code>http.ServerResponse</code>.</p>

<h3 id="_connection_">Событие: 'connection'</h3>

<p><code>function (stream) { }</code></p>

<p>Генерируется при установке нового HTTP-соединения. <code>stream</code> — объект типа <code>net.Stream</code>.
Обычно пользователи не используют это событие. Объект потока <code>stream</code> также можно
найти в свойстве объекта запроса <code>request.connection</code>.</p>

<h3 id="_close_">Событие: 'close'</h3>

<p><code>function (errno) { }</code></p>

<p>Генерируется при завершении работы сервера.</p>

<h3 id="_checkContinue_">Событие: 'checkContinue'</h3>

<p><code>function (request, response) {}</code></p>

<p>Событие наступает кажды раз при получении заголовка <code>'Expect: 100'</code>.
Если для этого события не назначен ни один обработчик, то сервер автоматически
отвечает <code>'100 Continue'</code>.</p>

<p>Обработка этого события подразумевает вызов <code>response.writeContinue</code> если клиент
должен продолжить отправку тела запроса, или генерацию другого HTTP запроса
(например <code>'400 Bad Request'</code>) если клиент не должен этого делать.</p>

<p>Имейте в виду, что если это событие наступило и было обработано, то событие
<code>request</code> не наступает.</p>

<h3 id="_upgrade_">Событие: 'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Генерируется каждый раз когда клиент запрашивает апгрейд соединения
до защищённого (см. RFC 2817). Если это событие никак не обрабатывается
соединение для которого запрошен апгрейд будет закрыто.</p>

<ul><li><code>request</code> — аргументы для HTTP запроса, как в событии <code>'request'</code>.</li><li><code>socket</code> — сетевой сокет между сервером и клиентом.</li><li><code>head</code> — экземпляр Buffer, первый пакет защищенного потока, может быть пустым.</li></ul>

<p>После генерации этого события, у объекта <code>server</code> не будет обработчика события
<code>data</code>, и программисту нужно назначить его заново чтобы обрабатывать данные,
получаемые этим соединением.</p>

<h3 id="_clientError_">Событие: 'clientError'</h3>

<p><code>function (exception) {}</code></p>

<p>Если соединение с клиентом генерирует событие <code>'error'</code> — оно поднимается сюда.</p>

<h3 id="http.createServer">http.createServer(requestListener)</h3>

<p>Возвращает новый объект web-сервера.</p>

<p>Функция <code>requestListener</code> автоматически добавляется к событию <code>'request'</code> сервера.</p>

<h3 id="server.listen">server.listen(port, [hostname], [callback])</h3>

<p>Начинает приём соединений на указанном порту и имени хоста. Если имя хоста не указано,
сервер будет принимать соединения на любой IPv4-адрес машины (<code>INADDR_ANY</code>).</p>

<p>Чтобы слушать unix-сокет, передайте имя файла вместо порта и имени хоста.</p>

<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с портом.</p>

<h3 id="server.listen">server.listen(path, [callback])</h3>

<p>Начинает слушать unix-сокет с заданным путём <code>path</code>.</p>

<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с сокетом.</p>

<h3 id="server.close">server.close()</h3>

<p>Прекращает приём новых соединений сервером.</p>

<h2 id="http.ServerRequest">http.ServerRequest</h2>

<p>Этот объект создаётся автоматически HTTP-сервером (не пользователем)
и передаётся первым аргументом обработчику события <code>'request'</code>.</p>

<p>Это <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_data_">Событие: 'data'</h3>

<p><code>function (chunk) { }</code></p>

<p>Генерируется при получении части тела сообщения.</p>

<p>Пример: Часть тела сообщения передаётся как единственный аргумент. Сообщение
уже раскодировано из transfer-encoding. Часть тела представлена в виде строки.
Кодировка тела сообщения задаётся <code>request.setBodyEncoding()</code>.</p>

<h3 id="_end_">Событие: 'end'</h3>

<p><code>function () { }</code></p>

<p>Генерируется строго один раз для каждого сообщения. Нет аргументов. После этого
события запрос не будет генерировать другие.</p>

<h3 id="request.method">request.method</h3>

<p>Метод запроса в виде строки. Только для чтения. Пример <code>'GET'</code> или <code>'DELETE'</code>.</p>

<h3 id="request.url">request.url</h3>

<p>Строка с URL запроса. Здесь содержится URL в том виде, в котором он задан
в самом HTTP-запросе. Если запрос выглядит так:</p>

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>

<p>Тогда значением <code>request.url</code> будет:</p>

<pre><code>'/status?name=ryan'</code></pre>

<p>Если вы хотите разделить URL на составные части, вы можете использовать
<code>require('url').parse(request.url)</code>. Пример:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status' }</code></pre>

<p>Если вам нужно извлечь параметры из строки запроса, можно использовать функцию
<code>require('querystring').parse</code>, или передать <code>true</code> в качестве второго аргумента
<code>require('url').parse</code>. Пример:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: { name: 'ryan' },
  pathname: '/status' }</code></pre>

<h3 id="request.headers">request.headers</h3>

<p>Заголовки запроса. Только для чтения.</p>

<h3 id="request.trailers">request.trailers</h3>

<p>HTTP trailers (если есть). Только для чтения.
Доступны тольк после наступления события <code>'end'</code>.</p>

<h3 id="request.httpVersion">request.httpVersion</h3>

<p>Версия протокола HTTP в виде строки. Только чтение. Пример: <code>'1.1'</code>, <code>'1.0'</code>.
Также <code>request.httpVersionMajor</code> содержит первое число и <code>request.httpVersionMinor</code> — второе.</p>

<h3 id="request.setEncoding">request.setEncoding(encoding=null)</h3>

<p>Задаёт кодировку тела запроса. Либо <code>'utf8'</code>, либо <code>'binary'</code>. По умолчанию
принимает значение <code>null</code>, что означает что в обработчик события <code>'data'</code>
поступает буфер.</p>

<h3 id="request.pause">request.pause()</h3>

<p>Прекращает генерирование событий запросом.
Можно использовать для ускорения закачки файла.</p>

<h3 id="request.resume">request.resume()</h3>

<p>Возобновляет генерирование событий запросом</p>

<h3 id="request.connection">request.connection</h3>

<p>Объект соединения, экземпляр <code>net.Stream</code>.</p>

<p>При поддержке HTTPS достоверность и содержимое сертификата могут быть проверены
с помощью методов <code>verifyPeer()</code> и <code>getPeerCertificate()</code>
объекта <code>request.connection</code> сервера.</p>

<h2 id="http.ServerResponse">http.ServerResponse</h2>

<p>Этот объект создаётся внутри HTTP-сервера — не пользователем. Он передаётся
вторым параметром в обработчик события <code>'request'</code> и является <code>потоком с возможностью записи</code>.</p>

<h3 id="response.writeContinue">response.writeContinue()</h3>

<p>Отправдяет клиенту сообщение <code>'HTTP/1.1 100 Continue'</code>, которое разрешает
отправку тела запроса. См. описанеи события <code>checkContinue</code> объекта <code>http.Server</code>.</p>

<h3 id="response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</h3>

<p>Отправляет заголовки ответа клиенту. <code>statusCode</code> это три цифры кода статуса HTTP,
например 404. Последний аргумент, <code>headers</code>, это заголовки ответа. Также вторым
аргументом можно передать фразу <code>reasonPhrase</code>.</p>

<p>Пример:</p>

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain' });</code></pre>

<p>Этот метод должен быть вызван только однажды для каждого сообщения
и должен быть вызван до <code>response.end()</code>.</p>

<h3 id="response.write">response.write(chunk, encoding='utf8')</h3>

<p>Этот метод должен вызываться после <code>writeHead</code>. Он отправляет часть тела ответа.
Метод может быть вызван несколько раз для отправки последующих частей тела ответа.</p>

<p>Аргумент <code>chunk</code> может быть буфером или строкой. Если <code>chunk</code> это строка, то
бойвторой параметр указывает в какой кодировке отправлять её в поток.
По умолчанию encoding принимает значение 'utf8'.</p>

<p><strong>Замечание:</strong> Это необработанное тело HTTP-ответа и не имеет отношения к более
высокоуровневым вещам вроде multi-part encoding, которые тоже могут использоваться.</p>

<p>После первого вызова <code>response.write()</code> клиенту будет отправлены заголовки
и первая часть тела сообщения. После второго вызова <code>response.write()</code> Node
предполагает что вы начинаете потоковую передачу данных и отправляет часть
тела отдельно. Таким образом, данные буферизуются только до первой части тела ответа.</p>

<h3 id="response.addTrailers">response.addTrailers(headers)</h3>

<p>Этот метод добавляет завершающие заголовки HTTP, следующие после тела ответа.</p>

<p>Эти заголовки могут быть использованы **только* в случае использование ответом 
<code>chunked encoding</code>; в противном случае они будут проигнорированы.</p>

<p>Имейте в виду, что протокол HTTP требует указания заголовка <code>Trailer</code>
в случае использования HTTP trailers, например:</p>

<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'TraceInfo' });
response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();</code></pre>

<h3 id="response.end">response.end([data], [encoding])</h3>

<p>Этот метод отправляет серверу сигнал что все заголовки и тело ответа отправлены;
сервер должен считать это сообщение законченным. Метод <code>response.end()</code>
<strong>ДОЛЖЕН</strong> быть вызван при каждом ответе.</p>

<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>response.write(data, encoding)</code> и <code>response.end()</code>.</p>

<h2 id="http.Client">http.Client</h2>

<p>HTTP-клиент создаётся принимая адрес сервера в качестве аргумента, возвращаемый
идентификатор используется для отправки одного или нескольких запросов.
В зависимости от того, к какому серверу совершено подключение клиент может
использовать pipeline (несколько запросов за соединение) либо пересоздавать
поток после каждого запроса. <em>Текущая версия не использует pipeline</em>.</p>

<p>Пример подключения к <code>google.com</code>:</p>

<pre><code>var http = require('http');
var google = http.createClient(80, 'www.google.com');
var request = google.request('GET', '/',
  {'host': 'www.google.com'});
request.end();
request.on('response', function (response) {
  console.log('STATUS: ' + response.statusCode);
  console.log('HEADERS: ' + JSON.stringify(response.headers));
  response.setEncoding('utf8');
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});</code></pre>

<p>Нужно иметь в виду следующие особенности реализации:</p>

<ul><li><p>Заголовок 'Host' не добавляется Node, но обычно требуется для работы с сайтами.</p></li><li><p>Отправка заголовка 'Connection: keep-alive' сообщает Node о необходимости
сохранять соединения для последующих запросов.</p></li><li><p>Отправка заголовка <code>'Content-length'</code> отключит 'chunked encoding'.</p></li><li><p>Отправка заголовка 'Expect' немедленно приведёт к отправке всех заголовков.
Обычно, при отправке 'Expect: 100-continue', вы должны установить таймаут
и установить обработчик события <code>continue</code>.
См. <a href="http://tools.ietf.org/html/rfc2616#section-8.2.3">RFC2616 Section 8.2.3</a>
для дополнительной информации.</p></li></ul>

<h3 id="_upgrade_">Событие: 'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Генерируется каждый раз когда сервер отвечает на запрос предложением улучшить
соединение до безопасного. Если это событие не обрабатывается, клиент
при получении заголовка <code>upgrade</code> будет закрывать соединение.</p>

<p>См. описание события <code>upgrade</code> для <code>http.Server</code>.</p>

<h3 id="_continue_">Событие: 'continue'</h3>

<p><code>function ()</code></p>

<p>Наступает если сервер отправляет ответ с кодом '100 Continue', обычно в случае
если зщапрос включает заголовк 'Expect: 100-continue'. Это является указанием
клиенту на необходимость начала отправки тела запроса.</p>

<h3 id="http.createClient">http.createClient(port, host='localhost', secure=false, [credentials])</h3>

<p>Создаёт новый HTTP клиент. <code>port</code> и <code>host</code> относятся к серверу, к которому
производится подключение. Поток не создаётся до отправки запроса.</p>

<p><code>secure</code> — дополнительный двоичный флаг для включения поддержки HTTPS,
а <code>credentials</code> — необязательный объект параметров для crypto-модуля,
хранящий private-ключ клиента, сертификат и список доверенных CA сертификатов.</p>

<p>Если соединение зашифровано, но в объекте параметров не переданы сертификаты CA,
Node будет использовать публично доступный список CA, который представлен в
<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>

<h3 id="client.request">client.request(method='GET', path, [request_headers])</h3>

<p>Отправляет запрос; при необходимости инициирует соединение.
Возвращает экземпляр <code>http.ClientRequest</code>.</p>

<p><code>method</code> — необязательный параметр, по умолчанию принимает значение 'GET'.</p>

<p><code>request_headers</code> необязательный параметр. Дополнительные заголовки запроса
могут быть добавлены внутри Node. Возвращает объект <code>http.ClientRequest</code>.</p>

<p>Не забудьте включить заголовок <code>Content-Length</code> если планируете отправить тело
запроса. Если вы хотите отправить тело запроса потоком, поставьте
<code>Transfer-Encoding: chunked</code>.</p>

<p><em>ВНИМАНИЕ:</em> запрос ещё не закончен. Этот метод только отсылает заголовки серверу.
Необходимо вызвать <code>request.end()</code> чтобы отправить запрос целиком и получить ответ.
(Это звучит сложно, но позволяет пользователю передавать тело запроса
в потоковом режиме с помощью <code>request.write()</code>.)</p>

<h3 id="client.verifyPeer">client.verifyPeer()</h3>

<p>Возвращает true или false в зависимости от подлинности сертификата сервера
соответственно списку доверенных сертификатов CA (переданному явно или используемому по умолчанию).</p>

<h3 id="client.getPeerCertificate">client.getPeerCertificate()</h3>

<p>Возвращает JSON с деталями сертификата сервера, содержит поля <code>'subject'</code>, <code>'issuer'</code>, <code>'valid_from'</code> и <code>'valid_to'</code>.</p>

<h2 id="http.ClientRequest">http.ClientRequest</h2>

<p>Объект создаётся внутри Node и возвращается методом <code>request()</code> объекта <code>http.Client</code>.
Он представляет собой <em>незаконченный запрос</em>, заголовки которого уже отправлены.</p>

<p>Чтобы получить ответ, добавьте обработчик событию <code>'response'</code> объекта запроса.
Событие <code>'response'</code> будет сгенерировано объектом запроса при получении
заголовков ответа. Обработчик события <code>'response'</code> выполняется с одним
аргументом — экземпляром <code>http.ClientResponse</code>.</p>

<p>Во время события <code>'response'</code> можно добавлять обработчики к объекту ответа;
в частности, чтобы получать части тела ответа надо добавить обработчик
событию <code>'data'</code>. Заметьте что обработчик события <code>'response'</code> вызывается
до того, как будут получены части тела ответа, поэтому не надо беспокоиться,
что первая часть тела будет пропущена. Если обработчик <code>'data'</code> добавляется
во время события <code>'response'</code>, то всё тело ответа будет получено наверняка.</p>

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});</code></pre>

<p>Это <code>поток с возможностью записи</code>.</p>

<p>Это экземпляр <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_response_">Событие: 'response'</h3>

<p><code>function (response) { }</code></p>

<p>Генерируется когда на запрос приходит ответ. Это событие генерируется только
один раз. Аргументом обработчика <code>response</code> будет экземпляр <code>http.ClientResponse</code>.</p>

<h3 id="request.write">request.write(chunk, encoding='utf8')</h3>

<p>Отправляет часть тела запроса. Вызывая этот метод несколько раз, пользователь
может отправлять тело ответа серверу в потоковом режиме — в таком случае
предпочтительно добавлять в заголовки <code>['Transfer-Encoding', 'chunked']</code>
при создании запроса.</p>

<p>Аргумент <code>chunk</code> должен быть массивом чисел или строкой.</p>

<p>Аргумент <code>encoding</code> необязателен и имеет значение только если <code>chunk</code> строка.</p>

<h3 id="request.end">request.end([data], [encoding])</h3>

<p>Завершает отправку запроса. Если какие то части тела запроса ещё не были
отправлены, они отправляются. Если запрос разбит на части, будет послана
завершающая последовательность <code>'0\r\n\r\n'</code>.</p>

<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>request.write(data, encoding)</code> и <code>request.end()</code>.</p>

<h2 id="http.ClientResponse">http.ClientResponse</h2>

<p>Этот объект создаётся при создании запроса с помощью <code>http.Client</code>.
Он передаётся обработчику события <code>'response'</code> объекта запроса.</p>

<p>Объект ответа — <code>поток с возможностью чтения</code>.</p>

<h3 id="_data_">Событие: 'data'</h3>

<p><code>function (chunk) {}</code></p>

<p>Часть тела сообщения передаётся обработчику в качестве единственного аргуметна.
Строка уже преобразована из кодировки с помощью которой осуществлялась передача.
Часть тела сообщения передаётся обработчику в виде строки. Кодировка тела
сообщения задаётся <code>response.setBodyEncoding()</code>.</p>

<h3 id="_end_">Событие: 'end'</h3>

<p><code>function () {}</code></p>

<p>Генерируется только однажды для каждого сообщения. Обработчик вызывается
без аргументов. После этого сообщение не будет генерировать никаких событий.</p>

<h3 id="response.statusCode">response.statusCode</h3>

<p>Код статуса HTTP из трёх цифр, например <code>404</code>.</p>

<h3 id="response.httpVersion">response.httpVersion</h3>

<p>Версия HTTP для текущего соединения. Скорее всего либо <code>'1.1'</code>, либо <code>'1.0'</code>.
Также <code>response.httpVersionMajor</code> — первая цифра версии,
а <code>response.httpVersionMinor</code> — вторая.</p>

<h3 id="response.headers">response.headers</h3>

<p>Заголовки ответа.</p>

<h3 id="response.trailers">response.trailers</h3>

<p>См. описание выше.</p>

<h3 id="response.setEncoding">response.setEncoding(encoding=null)</h3>

<p>Задаёт кодировку тела ответа. Может принимать значения <code>'utf8'</code>, <code>'ascii'</code>
или <code>'base64'</code>. По умолчанию используется <code>null</code>, что означает что в обработчик
события <code>'data'</code> поступает буфер.</p>

<h3 id="response.pause">response.pause()</h3>

<p>Приостанавливает генерацию событий ответом.
Можно использовать для ускорения закачки файла.</p>

<h3 id="response.resume">response.resume()</h3>

<p>Возобновляет генерацию событий ответом.</p>

<h3 id="response.client">response.client</h3>

<p>Ссылка на <code>http.Client</code> которому принадлежит ответ.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
  <!-- Yandex.Metrika --> 
  <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script> 
  <script type="text/javascript"> 
  try { var yaCounter612423 = new Ya.Metrika(612423); } catch(e){}
  </script> 
  <noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/612423" alt="" /></div></noscript> 
  <!-- /Yandex.Metrika -->   
</body>
</html>
