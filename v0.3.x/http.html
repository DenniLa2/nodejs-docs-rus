<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>http - Node.js &mdash; Документация</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all" />
</head>
<body>
<a href="http://github.com/kurokikaze/nodejs-docs-rus"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://assets0.github.com/img/ce742187c818c67d98af16f96ed21c00160c234a?repo=&url=http%3A%2F%2Fs3.amazonaws.com%2Fgithub%2Fribbons%2Fforkme_left_gray_6d6d6d.png&path=" alt="Fork me on GitHub"></a>
  <div id="container">
    <header>
      <h1>Node.js &mdash; Документация</h1>
      <div id="gtoc">
        <p><a href="index.html">Содержание</a> | <a href="all.html">Просмотреть на одной странице</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Содержание</h2><ul><li><a href="#hTTP">HTTP</a></li><li><a href="#http.Server">http.Server</a><ul><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_request_">Событие: 'request'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connection_">Событие: 'connection'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_checkContinue_">Событие: 'checkContinue'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_upgrade_">Событие: 'upgrade'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_clientError_">Событие: 'clientError'</a></li><li><a href="#http.createServer">http.createServer(requestListener)</a></li><li><a href="#server.listen">server.listen(port, [hostname], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.close">server.close()</a></li></ul></li><li><a href="#http.ServerRequest">http.ServerRequest</a><ul><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</a></li><li><a href="#request.method">request.method</a></li><li><a href="#request.url">request.url</a></li><li><a href="#request.headers">request.headers</a></li><li><a href="#request.trailers">request.trailers</a></li><li><a href="#request.httpVersion">request.httpVersion</a></li><li><a href="#request.setEncoding">request.setEncoding(encoding=null)</a></li><li><a href="#request.pause">request.pause()</a></li><li><a href="#request.resume">request.resume()</a></li><li><a href="#request.connection">request.connection</a></li></ul></li><li><a href="#http.ServerResponse">http.ServerResponse</a><ul><li><a href="#response.writeContinue">response.writeContinue()</a></li><li><a href="#response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li><li><a href="#response.write">response.write(chunk, encoding='utf8')</a></li><li><a href="#response.addTrailers">response.addTrailers(headers)</a></li><li><a href="#response.end">response.end([data], [encoding])</a></li></ul></li><li><a href="#http.request">http.request(options, callback)</a></li><li><a href="#http.get">http.get(options, callback)</a><ul><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_upgrade_">Событие: 'upgrade'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_continue_">Событие: 'continue'</a></li></ul></li><li><a href="#http.Agent">http.Agent</a></li><li><a href="#http.getAgent">http.getAgent(host, port)</a><ul><li><a href="#agent.maxSockets">agent.maxSockets</a></li><li><a href="#agent.sockets">agent.sockets</a></li><li><a href="#agent.queue">agent.queue</a></li></ul></li><li><a href="#http.ClientRequest">http.ClientRequest</a><ul><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_response_">Событие: 'response'</a></li><li><a href="#request.write">request.write(chunk, encoding='utf8')</a></li><li><a href="#request.end">request.end([data], [encoding])</a></li><li><a href="#request.abort">request.abort()</a></li></ul></li><li><a href="#http.ClientResponse">http.ClientResponse</a><ul><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.httpVersion">response.httpVersion</a></li><li><a href="#response.headers">response.headers</a></li><li><a href="#response.trailers">response.trailers</a></li><li><a href="#response.setEncoding">response.setEncoding(encoding=null)</a></li><li><a href="#response.pause">response.pause()</a></li><li><a href="#response.resume">response.resume()</a></li></ul></li></ul><hr /></div>
<h2 id="hTTP">HTTP</h2>

<p>Для использования клиента и сервера HTTP необходимо подключить
соответствующий модуль с помощью <code>require('http')</code>.</p>

<p>Интерфейс HTTP спроектирован в Node таким образом, чтобы поддерживать многие
возможности протокола, которые традиционно было довольно сложно использовать.
В частности, большие сообщения с возможным chunk-encoding. Интерфейс никогда
не сохраняет в буфере целиком запрос или ответ, давая пользователю возможность
принимать и отправлять данные в потоковом режиме.</p>

<p>Заголовки сообщения HTTP представлены примерно таким объектом:</p>

<pre><code>{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'accept': '*/*' }</code></pre>

<p>Ключи приводятся к нижнему регистру. Значения не изменяются.</p>

<p>Для поддержки всего спектра возможных применений HTTP, соответствующее API
в Node довольно низкоуровневое. Оно основано на потоках и передаче сообщений.
Node разбирает HTTP-сообщение на заголовки и тело, остальное должен сделать
программист.</p>

<h2 id="http.Server">http.Server</h2>

<p>Это <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_request_">Событие: 'request'</h3>

<p><code>function (request, response) { }</code></p>

<p>Генерируется каждый раз при получении запроса. Заметьте, что в течении одного
соединения может происходить несколько запросов (в случае keep-alive соединения).
Объект <code>request</code> — экземпляр <code>http.ServerRequest</code>,
объект <code>response</code> — экземпляр <code>http.ServerResponse</code>.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connection_">Событие: 'connection'</h3>

<p><code>function (stream) { }</code></p>

<p>Генерируется при установке нового HTTP-соединения. <code>stream</code> — объект типа <code>net.Stream</code>.
Обычно пользователи не используют это событие. Объект потока <code>stream</code> также можно
найти в свойстве объекта запроса <code>request.connection</code>.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</h3>

<p><code>function (errno) { }</code></p>

<p>Генерируется при завершении работы сервера.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_checkContinue_">Событие: 'checkContinue'</h3>

<p><code>function (request, response) {}</code></p>

<p>Событие наступает кажды раз при получении заголовка <code>'Expect: 100'</code>.
Если для этого события не назначен ни один обработчик, то сервер автоматически
отвечает <code>'100 Continue'</code>.</p>

<p>Обработка этого события подразумевает вызов <code>response.writeContinue</code> если клиент
должен продолжить отправку тела запроса, или генерацию другого HTTP запроса
(например <code>'400 Bad Request'</code>) если клиент не должен этого делать.</p>

<p>Имейте в виду, что если это событие наступило и было обработано, то событие
<code>request</code> не наступает.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_upgrade_">Событие: 'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Генерируется каждый раз когда клиент запрашивает апгрейд соединения
до защищённого (см. RFC 2817). Если это событие никак не обрабатывается
соединение для которого запрошен апгрейд будет закрыто.</p>

<ul><li><code>request</code> — аргументы для HTTP запроса, как в событии <code>'request'</code>.</li><li><code>socket</code> — сетевой сокет между сервером и клиентом.</li><li><code>head</code> — экземпляр Buffer, первый пакет защищенного потока, может быть пустым.</li></ul>

<p>После генерации этого события, у объекта <code>server</code> не будет обработчика события
<code>data</code>, и программисту нужно назначить его заново чтобы обрабатывать данные,
получаемые этим соединением.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_clientError_">Событие: 'clientError'</h3>

<p><code>function (exception) {}</code></p>

<p>Если соединение с клиентом генерирует событие <code>'error'</code> — оно поднимается сюда.</p>

<h3 id="http.createServer">http.createServer(requestListener)</h3>

<p>Возвращает новый объект web-сервера.</p>

<p>Функция <code>requestListener</code> автоматически добавляется к событию <code>'request'</code> сервера.</p>

<h3 id="server.listen">server.listen(port, [hostname], [callback])</h3>

<p>Начинает приём соединений на указанном порту и имени хоста. Если имя хоста не указано,
сервер будет принимать соединения на любой IPv4-адрес машины (<code>INADDR_ANY</code>).</p>

<p>Чтобы слушать unix-сокет, передайте имя файла вместо порта и имени хоста.</p>

<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с портом.</p>

<h3 id="server.listen">server.listen(path, [callback])</h3>

<p>Начинает слушать unix-сокет с заданным путём <code>path</code>.</p>

<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с сокетом.</p>

<h3 id="server.close">server.close()</h3>

<p>Прекращает приём новых соединений сервером.</p>

<h2 id="http.ServerRequest">http.ServerRequest</h2>

<p>Этот объект создаётся автоматически HTTP-сервером (не пользователем)
и передаётся первым аргументом обработчику события <code>'request'</code>.</p>

<p>Это <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</h3>

<p><code>function (chunk) { }</code></p>

<p>Генерируется при получении части тела сообщения.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</h3>

<p><code>function () { }</code></p>

<p>Генерируется строго один раз для каждого сообщения. Нет аргументов. После этого
события запрос не будет генерировать другие.</p>

<h3 id="request.method">request.method</h3>

<p>Метод запроса в виде строки. Только для чтения. Пример <code>'GET'</code> или <code>'DELETE'</code>.</p>

<h3 id="request.url">request.url</h3>

<p>Строка с URL запроса. Здесь содержится URL в том виде, в котором он задан
в самом HTTP-запросе. Если запрос выглядит так:</p>

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>

<p>Тогда значением <code>request.url</code> будет:</p>

<pre><code>'/status?name=ryan'</code></pre>

<p>Если вы хотите разделить URL на составные части, вы можете использовать
<code>require('url').parse(request.url)</code>. Пример:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status' }</code></pre>

<p>Если вам нужно извлечь параметры из строки запроса, можно использовать функцию
<code>require('querystring').parse</code>, или передать <code>true</code> в качестве второго аргумента
<code>require('url').parse</code>. Пример:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: { name: 'ryan' },
  pathname: '/status' }</code></pre>

<h3 id="request.headers">request.headers</h3>

<p>Заголовки запроса. Только для чтения.</p>

<h3 id="request.trailers">request.trailers</h3>

<p>HTTP trailers (если есть). Только для чтения.
Доступны тольк после наступления события <code>'end'</code>.</p>

<h3 id="request.httpVersion">request.httpVersion</h3>

<p>Версия протокола HTTP в виде строки. Только чтение. Пример: <code>'1.1'</code>, <code>'1.0'</code>.
Также <code>request.httpVersionMajor</code> содержит первое число и <code>request.httpVersionMinor</code> — второе.</p>

<h3 id="request.setEncoding">request.setEncoding(encoding=null)</h3>

<p>Задаёт кодировку тела запроса. Либо <code>'utf8'</code>, либо <code>'binary'</code>. По умолчанию
принимает значение <code>null</code>, что означает что в обработчик события <code>'data'</code>
поступает буфер.</p>

<h3 id="request.pause">request.pause()</h3>

<p>Прекращает генерирование событий запросом.
Можно использовать для ускорения закачки файла.</p>

<h3 id="request.resume">request.resume()</h3>

<p>Возобновляет генерирование событий запросом</p>

<h3 id="request.connection">request.connection</h3>

<p>Объект соединения, экземпляр <code>net.Stream</code>.</p>

<p>При поддержке HTTPS достоверность и содержимое сертификата могут быть проверены
с помощью методов <code>verifyPeer()</code> и <code>getPeerCertificate()</code>
объекта <code>request.connection</code> сервера.</p>

<h2 id="http.ServerResponse">http.ServerResponse</h2>

<p>Этот объект создаётся внутри HTTP-сервера — не пользователем. Он передаётся
вторым параметром в обработчик события <code>'request'</code> и является <code>потоком с возможностью записи</code>.</p>

<h3 id="response.writeContinue">response.writeContinue()</h3>

<p>Отправдяет клиенту сообщение <code>'HTTP/1.1 100 Continue'</code>, которое разрешает
отправку тела запроса. См. описанеи события <code>checkContinue</code> объекта <code>http.Server</code>.</p>

<h3 id="response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</h3>

<p>Отправляет заголовки ответа клиенту. <code>statusCode</code> это три цифры кода статуса HTTP,
например 404. Последний аргумент, <code>headers</code>, это заголовки ответа. Также вторым
аргументом можно передать фразу <code>reasonPhrase</code>.</p>

<p>Пример:</p>

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain' });</code></pre>

<p>Этот метод должен быть вызван только однажды для каждого сообщения
и должен быть вызван до <code>response.end()</code>.</p>

<h3 id="response.write">response.write(chunk, encoding='utf8')</h3>

<p>Этот метод должен вызываться после <code>writeHead</code>. Он отправляет часть тела ответа.
Метод может быть вызван несколько раз для отправки последующих частей тела ответа.</p>

<p>Аргумент <code>chunk</code> может быть буфером или строкой. Если <code>chunk</code> это строка, то
бойвторой параметр указывает в какой кодировке отправлять её в поток.
По умолчанию encoding принимает значение 'utf8'.</p>

<p><strong>Замечание:</strong> Это необработанное тело HTTP-ответа и не имеет отношения к более
высокоуровневым вещам вроде multi-part encoding, которые тоже могут использоваться.</p>

<p>После первого вызова <code>response.write()</code> клиенту будет отправлены заголовки
и первая часть тела сообщения. После второго вызова <code>response.write()</code> Node
предполагает что вы начинаете потоковую передачу данных и отправляет часть
тела отдельно. Таким образом, данные буферизуются только до первой части тела ответа.</p>

<h3 id="response.addTrailers">response.addTrailers(headers)</h3>

<p>Этот метод добавляет завершающие заголовки HTTP, следующие после тела ответа.</p>

<p>Эти заголовки могут быть использованы **только* в случае использование ответом 
<code>chunked encoding</code>; в противном случае они будут проигнорированы.</p>

<p>Имейте в виду, что протокол HTTP требует указания заголовка <code>Trailer</code>
в случае использования HTTP trailers, например:</p>

<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'TraceInfo' });
response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();</code></pre>

<h3 id="response.end">response.end([data], [encoding])</h3>

<p>Этот метод отправляет серверу сигнал что все заголовки и тело ответа отправлены;
сервер должен считать это сообщение законченным. Метод <code>response.end()</code>
<strong>ДОЛЖЕН</strong> быть вызван при каждом ответе.</p>

<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>response.write(data, encoding)</code> и <code>response.end()</code>.</p>

<h2 id="http.request">http.request(options, callback)</h2>

<p>Node поддерживает множественные соединения для выполнения HTTP запросов.
Эта функция позволяет легко создавать их.</p>

<p>Параметры <code>options</code>:</p>

<ul><li><code>host</code>: Доменное имя или IP адрес для запроса.</li><li><code>port</code>: Порт на удалённом сервере.</li><li><code>method</code>: Строка, определяющая HTTP метод. возможные значения:
<code>'GET'</code> (по умолчанию), <code>'POST'</code>, <code>'PUT'</code> и <code>'DELETE'</code>.</li><li><code>path</code>: HTTP-путь, может включать строку запроса при необходимости.
Например <code>'/index.html?page=12'</code>.</li><li><code>headers</code>: Объект со списком дополнительных заголовков.</li></ul>

<p><code>http.request()</code> возвращает объект класса <code>http.ClientRequest</code>, являющийся
потоком с возможностью записи. Если вы хотите отпавить файл с помощью POST-запроса,
вам нужно записать его в этот объект.</p>

<p>Пример подключения к <code>google.com</code>:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST'
};

var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// write data to request body
req.write('data\n');
req.write('data\n');
req.end();</code></pre>

<p>Обратите внимание на вызов <code>req.end()</code> в примере. Используя <code>http.request()</code>
вы должны вызвать <code>req.end()</code>, иначе всё что вы делали до этого с объектом
не произойдёт и никакие данные не будут отправлены.</p>

<p>В случае возникновение ошибки (на уровне разрешения DNS имени, на уровне TCP
или на уровне обработки тела HTTP запроса) будет сгенерировано событие <code>'error'</code>
объекта запроса <code>req</code>.</p>

<p>Нужно иметь в виду следующие особенности реализации:</p>

<ul><li><p>Отправка заголовка 'Connection: keep-alive' сообщает Node о необходимости
сохранять соединения для последующих запросов.</p></li><li><p>Отправка заголовка <code>'Content-length'</code> отключит 'chunked encoding'.</p></li><li><p>Отправка заголовка 'Expect' немедленно приведёт к отправке всех заголовков.
Обычно, при отправке 'Expect: 100-continue', вы должны установить таймаут
и установить обработчик события <code>continue</code>.
См. <a href="http://tools.ietf.org/html/rfc2616#section-8.2.3">RFC2616 Section 8.2.3</a>
для дополнительной информации.</p></li></ul>

<h2 id="http.get">http.get(options, callback)</h2>

<p>Так как большинство запросов являются GET запросами без тела, Node содержит этот дополнительный метод.
Единственное отличие от метода <code>http.request()</code> заключается в использовании
запроса типа GET и автоматическом вызове <code>req.end()</code>.</p>

<p>Пример:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/index.html'
};

http.get(options, function(res) {
  console.log("Got response: " + res.statusCode);
}).on('error', function(e) {
  console.log("Got error: " + e.message);
});</code></pre>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_upgrade_">Событие: 'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Генерируется каждый раз когда сервер отвечает на запрос предложением улучшить
соединение до безопасного. Если это событие не обрабатывается, клиент
при получении заголовка <code>upgrade</code> будет закрывать соединение.</p>

<p>См. описание события <code>upgrade</code> для <code>http.Server</code>.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_continue_">Событие: 'continue'</h3>

<p><code>function ()</code></p>

<p>Наступает если сервер отправляет ответ с кодом '100 Continue', обычно в случае
если зщапрос включает заголовк 'Expect: 100-continue'. Это является указанием
клиенту на необходимость начала отправки тела запроса.</p>

<h2 id="http.Agent">http.Agent</h2>

<h2 id="http.getAgent">http.getAgent(host, port)</h2>

<p><code>http.request()</code> использует специального <code>Агента</code> для обработки множества
соединений с HTTP сервером. Обычно объекты класса <code>Agent</code> не должны быть доступны
в пользовательском коде, однако иногда это может быть полезно. Метод <code>http.getAgent()</code>
позволяет получить доступ к этому объекту.</p>

<h3 id="agent.maxSockets">agent.maxSockets</h3>

<p>По умолчанию равно 5. Определяет максимальное количество сокетов,
одновременно открытых клиентом.</p>

<h3 id="agent.sockets">agent.sockets</h3>

<p>Массив сокетов, используемых в данный момент. Не изменяйте этот массив.</p>

<h3 id="agent.queue">agent.queue</h3>

<p>Очередь запросов, ожидающих отправки.</p>

<h2 id="http.ClientRequest">http.ClientRequest</h2>

<p>Объект создаётся внутри Node и возвращается методом <code>http.request()</code>.
Он представляет собой <em>незаконченный запрос</em>, заголовки которого уже отправлены.</p>

<p>Чтобы получить ответ, добавьте обработчик событию <code>'response'</code> объекта запроса.
Событие <code>'response'</code> будет сгенерировано объектом запроса при получении
заголовков ответа. Обработчик события <code>'response'</code> выполняется с одним
аргументом — экземпляром <code>http.ClientResponse</code>.</p>

<p>Во время события <code>'response'</code> можно добавлять обработчики к объекту ответа;
в частности, чтобы получать части тела ответа надо добавить обработчик
событию <code>'data'</code>. Заметьте что обработчик события <code>'response'</code> вызывается
до того, как будут получены части тела ответа, поэтому не надо беспокоиться,
что первая часть тела будет пропущена. Если обработчик <code>'data'</code> добавляется
во время события <code>'response'</code>, то всё тело ответа будет получено наверняка.</p>

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});</code></pre>

<p>Это <code>поток с возможностью записи</code>.</p>

<p>Это экземпляр <code>EventEmitter</code> со следующими событиями:</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_response_">Событие: 'response'</h3>

<p><code>function (response) { }</code></p>

<p>Генерируется когда на запрос приходит ответ. Это событие генерируется только
один раз. Аргументом обработчика <code>response</code> будет экземпляр <code>http.ClientResponse</code>.</p>

<h3 id="request.write">request.write(chunk, encoding='utf8')</h3>

<p>Отправляет часть тела запроса. Вызывая этот метод несколько раз, пользователь
может отправлять тело ответа серверу в потоковом режиме — в таком случае
предпочтительно добавлять в заголовки <code>['Transfer-Encoding', 'chunked']</code>
при создании запроса.</p>

<p>Аргумент <code>chunk</code> должен быть массивом чисел или строкой.</p>

<p>Аргумент <code>encoding</code> необязателен и имеет значение только если <code>chunk</code> строка.</p>

<h3 id="request.end">request.end([data], [encoding])</h3>

<p>Завершает отправку запроса. Если какие то части тела запроса ещё не были
отправлены, они отправляются. Если запрос разбит на части, будет послана
завершающая последовательность <code>'0\r\n\r\n'</code>.</p>

<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>request.write(data, encoding)</code> и <code>request.end()</code>.</p>

<h3 id="request.abort">request.abort()</h3>

<p>Прерывает запрос. (Добавлено в версии v0.3.8)</p>

<h2 id="http.ClientResponse">http.ClientResponse</h2>

<p>Этот объект создаётся при создании запроса с помощью <code>http.request()</code>.
Он передаётся обработчику события <code>'response'</code> объекта запроса.</p>

<p>Объект ответа — <code>поток с возможностью чтения</code>.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</h3>

<p><code>function (chunk) {}</code></p>

<p>Часть тела сообщения передаётся обработчику в качестве единственного аргуметна.
Строка уже преобразована из кодировки с помощью которой осуществлялась передача.
Часть тела сообщения передаётся обработчику в виде строки. Кодировка тела
сообщения задаётся <code>response.setBodyEncoding()</code>.</p>

<h3 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</h3>

<p><code>function () {}</code></p>

<p>Генерируется только однажды для каждого сообщения. Обработчик вызывается
без аргументов. После этого сообщение не будет генерировать никаких событий.</p>

<h3 id="response.statusCode">response.statusCode</h3>

<p>Код статуса HTTP из трёх цифр, например <code>404</code>.</p>

<h3 id="response.httpVersion">response.httpVersion</h3>

<p>Версия HTTP для текущего соединения. Скорее всего либо <code>'1.1'</code>, либо <code>'1.0'</code>.
Также <code>response.httpVersionMajor</code> — первая цифра версии,
а <code>response.httpVersionMinor</code> — вторая.</p>

<h3 id="response.headers">response.headers</h3>

<p>Заголовки ответа.</p>

<h3 id="response.trailers">response.trailers</h3>

<p>См. описание выше.</p>

<h3 id="response.setEncoding">response.setEncoding(encoding=null)</h3>

<p>Задаёт кодировку тела ответа. Может принимать значения <code>'utf8'</code>, <code>'ascii'</code>
или <code>'base64'</code>. По умолчанию используется <code>null</code>, что означает что в обработчик
события <code>'data'</code> поступает буфер.</p>

<h3 id="response.pause">response.pause()</h3>

<p>Приостанавливает генерацию событий ответом.
Можно использовать для ускорения закачки файла.</p>

<h3 id="response.resume">response.resume()</h3>

<p>Возобновляет генерацию событий ответом.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
  <!-- Yandex.Metrika --> 
  <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script> 
  <script type="text/javascript"> 
  try { var yaCounter612423 = new Ya.Metrika(612423); } catch(e){}
  </script> 
  <noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/612423" alt="" /></div></noscript> 
  <!-- /Yandex.Metrika -->   
</body>
</html>
