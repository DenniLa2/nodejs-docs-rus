<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>О документации Node.js v0.6.x &mdash; Документация</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/all.html">
</head>
<body class="alt apidoc" id="api-section-all">
    <a href="http://github.com/kurokikaze/nodejs-docs-rus">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="assets/forkme_right_green.png" alt="Fork me on GitHub">
    </a>
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.6.x &mdash; Документация</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Содержание</a> |
                <a href="all.html">Просмотреть на одной странице</a> |
                <a href="all.json">Просмотреть в виде JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Содержание</h2>
            <ul>
<li><a href="#all">О документации</a><ul>
<li><a href="#all_1">Индекс стабильности</a></li>
</ul>
</li>
<li><a href="#all_2">Краткий обзор</a><ul>
<li><a href="#all_3">Глобальные объекты</a><ul>
<li><a href="#all_global">global</a></li>
<li><a href="#all_process">process</a></li>
<li><a href="#all_console">console</a></li>
<li><a href="#all_require">require()</a></li>
<li><a href="#all_require_resolve">require.resolve()</a></li>
<li><a href="#all_require_paths">require.paths</a></li>
<li><a href="#all_filename">__filename</a></li>
<li><a href="#all_dirname">__dirname</a></li>
<li><a href="#all_module">module</a></li>
<li><a href="#all_exports">exports</a></li>
<li><a href="#all_settimeout_cb_ms">setTimeout(cb, ms)</a></li>
<li><a href="#all_cleartimeout_t">clearTimeout(t)</a></li>
<li><a href="#all_setinterval_cb_ms">setInterval(cb, ms)</a></li>
<li><a href="#all_clearinterval_t">clearInterval(t)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_console_1">console</a><ul>
<li><a href="#all_console_log">console.log()</a></li>
<li><a href="#all_console_info">console.info()</a></li>
<li><a href="#all_console_warn">console.warn()</a></li>
<li><a href="#all_console_error">console.error()</a></li>
<li><a href="#all_console_dir_obj">console.dir(obj)</a></li>
<li><a href="#all_console_time_label">console.time(label)</a></li>
<li><a href="#all_console_timeend_label">console.timeEnd(label)</a></li>
<li><a href="#all_console_trace">console.trace()</a></li>
<li><a href="#all_console_assert">console.assert()</a></li>
<li><a href="#all_4">Таймеры</a><ul>
<li><a href="#all_settimeout_callback_delay_arg">setTimeout(callback, delay, [arg], [...])</a></li>
<li><a href="#all_cleartimeout_timeoutid">clearTimeout(timeoutId)</a></li>
<li><a href="#all_setinterval_callback_delay_arg">setInterval(callback, delay, [arg], [...])</a></li>
<li><a href="#all_clearinterval_intervalid">clearInterval(intervalId)</a></li>
</ul>
</li>
<li><a href="#all_5">Модули</a></li>
<li><a href="#all_6">Стандартные модули</a><ul>
<li><a href="#all_7">Поиск модулей</a></li>
<li><a href="#all_node_modules">Загрузка из папок <code>node_modules</code></a></li>
<li><a href="#all_8">Папки как модули</a></li>
<li><a href="#all_9">Кеширование</a><ul>
<li><a href="#all_10">Будьте осторожны с кешированием модулей</a></li>
</ul>
</li>
<li><a href="#all_module_exports">module.exports</a></li>
<li><a href="#all_11">Собирая всё вместе...</a></li>
<li><a href="#all_require_paths_1">Загрузка из папок <code>require.paths</code></a><ul>
<li><a href="#all_require_paths_2"><strong>Примечание:</strong> Пожалуйста, избегайте использования <code>require.paths</code></a><ul>
<li><a href="#all_require_paths_3">Присвоение <code>require.paths</code> другой переменной ничего не изменяет.</a></li>
<li><a href="#all_require_paths_4">Добавление относительных путей в <code>require.paths</code> чревато ... странностями</a></li>
<li><a href="#all_12">Отсутствие изоляции</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_13">Доступ к главному модулю.</a></li>
</ul>
</li>
<li><a href="#all_14">Дополнение: Советы для пакетных менеджеров</a></li>
</ul>
</li>
<li><a href="#all_c_c">C/C++ дополнения</a><ul>
<li><a href="#all_hello_world">Hello world</a></li>
<li><a href="#all_15">Фрагменты кода дополнений</a><ul>
<li><a href="#all_16">Передача аргументов в функции</a></li>
<li><a href="#all_17">Функции обратного вызова</a></li>
<li><a href="#all_18">Фабрика объектов</a></li>
<li><a href="#all_19">Фабрика функций</a></li>
<li><a href="#all_c">Обертка C++ объектов</a></li>
<li><a href="#all_20">Фабрика обёрток объектов</a></li>
<li><a href="#all_c_1">Использование обёрнутых объектов в C++ коде</a></li>
</ul>
</li>
<li><a href="#all_21">Процесс</a><ul>
<li><a href="#all_exit">Событие: &apos;exit&apos;</a></li>
<li><a href="#all_uncaughtexception">Событие: &apos;uncaughtException&apos;</a></li>
<li><a href="#all_22">Сигнальные события</a></li>
<li><a href="#all_process_stdout">process.stdout</a></li>
<li><a href="#all_process_stderr">process.stderr</a></li>
<li><a href="#all_process_stdin">process.stdin</a></li>
<li><a href="#all_process_argv">process.argv</a></li>
<li><a href="#all_process_execpath">process.execPath</a></li>
<li><a href="#all_process_chdir_directory">process.chdir(directory)</a></li>
<li><a href="#all_process_cwd">process.cwd()</a></li>
<li><a href="#all_process_env">process.env</a></li>
<li><a href="#all_process_exit_code_0">process.exit(code=0)</a></li>
<li><a href="#all_process_getgid">process.getgid()</a></li>
<li><a href="#all_process_setgid_id">process.setgid(id)</a></li>
<li><a href="#all_process_getuid">process.getuid()</a></li>
<li><a href="#all_process_setuid_id">process.setuid(id)</a></li>
<li><a href="#all_process_version">process.version</a></li>
<li><a href="#all_process_installprefix">process.installPrefix</a></li>
<li><a href="#all_process_kill_pid_signal_sigterm">process.kill(pid, signal=&apos;SIGTERM&apos;)</a></li>
<li><a href="#all_process_pid">process.pid</a></li>
<li><a href="#all_process_title">process.title</a></li>
<li><a href="#all_process_platform">process.platform</a></li>
<li><a href="#all_process_memoryusage">process.memoryUsage()</a></li>
<li><a href="#all_process_nexttick_callback">process.nextTick(callback)</a></li>
<li><a href="#all_process_umask_mask">process.umask([mask])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_23">Утилиты</a><ul>
<li><a href="#all_util_format">util.format()</a></li>
<li><a href="#all_util_debug_string">util.debug(string)</a></li>
<li><a href="#all_util_log_string">util.log(string)</a></li>
<li><a href="#all_util_inspect_object_showhidden_depth_colors">util.inspect(object, [showHidden], [depth], [colors])</a></li>
<li><a href="#all_util_isarray_object">util.isArray(object)</a></li>
<li><a href="#all_util_isregexp_object">util.isRegExp(object)</a></li>
<li><a href="#all_util_isdate_object">util.isDate(object)</a></li>
<li><a href="#all_util_iserror_object">util.isError(object)</a></li>
<li><a href="#all_util_pump_readablestream_writablestream_callback">util.pump(readableStream, writableStream, [callback])</a></li>
<li><a href="#all_util_inherits_constructor_superconstructor">util.inherits(constructor, superConstructor)</a></li>
<li><a href="#all_c_2">Cобытия</a><ul>
<li><a href="#all_events_eventemitter">events.EventEmitter</a><ul>
<li><a href="#all_emitter_addlistener_event_listener">emitter.addListener(event, listener)</a></li>
<li><a href="#all_emitter_on_event_listener">emitter.on(event, listener)</a></li>
<li><a href="#all_emitter_once_event_listener">emitter.once(event, listener)</a></li>
<li><a href="#all_emitter_removelistener_event_listener">emitter.removeListener(event, listener)</a></li>
<li><a href="#all_emitter_removealllisteners_event">emitter.removeAllListeners(event)</a></li>
<li><a href="#all_emitter_setmaxlisteners_n">emitter.setMaxListeners(n)</a></li>
<li><a href="#all_emitter_listeners_event">emitter.listeners(event)</a></li>
<li><a href="#all_emitter_emit_event_arg1_arg2">emitter.emit(event, [arg1], [arg2], [...])</a></li>
<li><a href="#all_newlistener">Событие: &apos;newListener&apos;</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_24">Буфер</a><ul>
<li><a href="#all_buffer">Класс: Buffer</a><ul>
<li><a href="#all_new_buffer_size">new Buffer(size)</a></li>
<li><a href="#all_new_buffer_array">new Buffer(array)</a></li>
<li><a href="#all_new_buffer_str_encoding">new Buffer(str, [encoding])</a></li>
<li><a href="#all_buf_write_string_offset_length_encoding">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="#all_buf_tostring_encoding_start_end">buf.toString([encoding], [start], [end])</a></li>
<li><a href="#all_buf_index">buf[index]</a></li>
<li><a href="#all_buffer_isbuffer_obj">Метод класса: Buffer.isBuffer(obj)</a></li>
<li><a href="#all_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="#all_buf_length">buf.length</a></li>
<li><a href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="#all_buffer_slice_start_end">buffer.slice([start], [end])</a></li>
<li><a href="#all_buf_readuint8_offset_noassert">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint8_offset_noassert">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16le_offset_noassert">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint16be_offset_noassert">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32le_offset_noassert">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readint32be_offset_noassert">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatle_offset_noassert">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="#all_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="#all_buf_fill_value_offset_end">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="#all_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="#all_class_slowbuffer">Class: SlowBuffer</a></li>
</ul>
</li>
<li><a href="#all_25">Поток</a><ul>
<li><a href="#all_26">Поток с возможностью чтения</a><ul>
<li><a href="#all_data">Событие: &apos;data&apos;</a></li>
<li><a href="#all_end">Событие: &apos;end&apos;</a></li>
<li><a href="#all_event_error">Event: &apos;error&apos;</a></li>
<li><a href="#all_close">Событие: &apos;close&apos;</a></li>
<li><a href="#all_stream_readable">stream.readable</a></li>
<li><a href="#all_stream_setencoding_encoding">stream.setEncoding(encoding)</a></li>
<li><a href="#all_stream_pause">stream.pause()</a></li>
<li><a href="#all_stream_resume">stream.resume()</a></li>
<li><a href="#all_stream_destroy">stream.destroy()</a></li>
<li><a href="#all_stream_pipe_destination_options">stream.pipe(destination, [options])</a></li>
</ul>
</li>
<li><a href="#all_27">Поток с возможностью записи</a><ul>
<li><a href="#all_drain">Событие: &apos;drain&apos;</a></li>
<li><a href="#all_error">Событие: &apos;error&apos;</a></li>
<li><a href="#all_close_1">Событие: &apos;close&apos;</a></li>
<li><a href="#all_pipe">Событие: &apos;pipe&apos;</a></li>
<li><a href="#all_stream_writable">stream.writable</a></li>
<li><a href="#all_stream_write_string_encoding_fd">stream.write(string, [encoding], [fd])</a></li>
<li><a href="#all_stream_write_buffer">stream.write(buffer)</a></li>
<li><a href="#all_stream_end">stream.end()</a></li>
<li><a href="#all_stream_end_string_encoding">stream.end(string, encoding)</a></li>
<li><a href="#all_stream_end_buffer">stream.end(buffer)</a></li>
<li><a href="#all_stream_destroy_1">stream.destroy()</a></li>
<li><a href="#all_stream_destroysoon">stream.destroySoon()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_28">Модуль криптографии</a><ul>
<li><a href="#all_crypto_createcredentials_details">crypto.createCredentials(details)</a></li>
<li><a href="#all_crypto_createhash_algorithm">crypto.createHash(algorithm)</a></li>
<li><a href="#all_hash">Класс: Hash</a><ul>
<li><a href="#all_hash_update_data_input_encoding">hash.update(data, [input_encoding])</a></li>
<li><a href="#all_hash_digest_encoding">hash.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createhmac_algorithm_key">crypto.createHmac(algorithm, key)</a></li>
<li><a href="#all_hmac">Класс: Hmac</a><ul>
<li><a href="#all_hmac_update_data">hmac.update(data)</a></li>
<li><a href="#all_hmac_digest_encoding">hmac.digest([encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createcipher_algorithm_password">crypto.createCipher(algorithm, password)</a></li>
<li><a href="#all_crypto_createcipheriv_algorithm_key_iv">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="#all_cipher">Класс: Cipher</a><ul>
<li><a href="#all_cipher_update_data_input_encoding_output_encoding">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_cipher_final_output_encoding">cipher.final([output_encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createdecipher_algorithm_password">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="#all_crypto_createdecipheriv_algorithm_key_iv">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="#all_decipher">Класс: Decipher</a><ul>
<li><a href="#all_decipher_update_data_input_encoding_output_encoding">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_decipher_final_output_encoding">decipher.final([output_encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createsign_algorithm">crypto.createSign(algorithm)</a></li>
<li><a href="#all_signer">Класс: Signer</a><ul>
<li><a href="#all_signer_update_data">signer.update(data)</a></li>
<li><a href="#all_signer_sign_private_key_output_format">signer.sign(private_key, [output_format])</a></li>
</ul>
</li>
<li><a href="#all_crypto_createverify_algorithm">crypto.createVerify(algorithm)</a></li>
<li><a href="#all_verify">Класс: Verify</a><ul>
<li><a href="#all_verifier_update_data">verifier.update(data)</a></li>
<li><a href="#all_verifier_verify_cert_signature_signature_format">verifier.verify(cert, signature, [signature_format])</a></li>
</ul>
</li>
<li><a href="#all_crypto_creatediffiehellman_prime_length">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="#all_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="#all_class_diffiehellman">Class: DiffieHellman</a><ul>
<li><a href="#all_diffiehellman_generatekeys_encoding">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="#all_diffiehellman_getprime_encoding">diffieHellman.getPrime([encoding])</a></li>
<li><a href="#all_diffiehellman_getgenerator_encoding">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="#all_diffiehellman_getpublickey_encoding">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="#all_diffiehellman_getprivatekey_encoding">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="#all_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="#all_diffiehellman_setprivatekey_public_key_encoding">diffieHellman.setPrivateKey(public_key, [encoding])</a></li>
</ul>
</li>
<li><a href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="#all_crypto_randombytes_size_callback">crypto.randomBytes(size, [callback])</a></li>
<li><a href="#all_tls_ssl">TLS (SSL)</a><ul>
<li><a href="#all_s_tls_connect_port_host_options_callback">s = tls.connect(port, [host], [options], callback)</a></li>
<li><a href="#all_starttls">STARTTLS</a></li>
<li><a href="#all_pair_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a><ul>
<li><a href="#all_secure">Событие: &apos;secure&apos;</a></li>
</ul>
</li>
<li><a href="#all_tls_server">tls.Server</a><ul>
<li><a href="#all_tls_createserver_options_secureconnectionlistener">tls.createServer(options, secureConnectionListener)</a></li>
<li><a href="#all_secureconnection">Событие: &apos;secureConnection&apos;</a></li>
<li><a href="#all_server_listen_port_host_callback">server.listen(port, [host], [callback])</a></li>
<li><a href="#all_server_close">server.close()</a></li>
<li><a href="#all_server_maxconnections">server.maxConnections</a></li>
<li><a href="#all_server_connections">server.connections</a></li>
</ul>
</li>
<li><a href="#all_tls_cleartextstream">tls.CleartextStream</a><ul>
<li><a href="#all_cleartextstream_authorized">cleartextStream.authorized</a></li>
<li><a href="#all_cleartextstream_authorizationerror">cleartextStream.authorizationError</a></li>
<li><a href="#all_cleartextstream_getpeercertificate">cleartextStream.getPeerCertificate()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_29">Файловая система</a><ul>
<li><a href="#all_fs_rename_path1_path2_callback">fs.rename(path1, path2, [callback])</a></li>
<li><a href="#all_fs_renamesync_path1_path2">fs.renameSync(path1, path2)</a></li>
<li><a href="#all_fs_truncate_fd_len_callback">fs.truncate(fd, len, [callback])</a></li>
<li><a href="#all_fs_truncatesync_fd_len">fs.truncateSync(fd, len)</a></li>
<li><a href="#all_fs_chown_path_uid_gid_callback">fs.chown(path, uid, gid, [callback])</a></li>
<li><a href="#all_fs_chownsync_path_uid_gid">fs.chownSync(path, uid, gid)</a></li>
<li><a href="#all_fs_fchown_path_uid_gid_callback">fs.fchown(path, uid, gid, [callback])</a></li>
<li><a href="#all_fs_fchownsync_path_uid_gid">fs.fchownSync(path, uid, gid)</a></li>
<li><a href="#all_fs_lchown_path_uid_gid_callback">fs.lchown(path, uid, gid, [callback])</a></li>
<li><a href="#all_fs_lchownsync_path_uid_gid">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="#all_fs_chmod_path_mode_callback">fs.chmod(path, mode, [callback])</a></li>
<li><a href="#all_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="#all_fs_fchmod_fd_mode_callback">fs.fchmod(fd, mode, [callback])</a></li>
<li><a href="#all_fs_fchmodsync_path_mode">fs.fchmodSync(path, mode)</a></li>
<li><a href="#all_fs_lchmod_fd_mode_callback">fs.lchmod(fd, mode, [callback])</a></li>
<li><a href="#all_fs_lchmodsync_path_mode">fs.lchmodSync(path, mode)</a></li>
<li><a href="#all_fs_stat_path_callback">fs.stat(path, [callback])</a></li>
<li><a href="#all_fs_lstat_path_callback">fs.lstat(path, [callback])</a></li>
<li><a href="#all_fs_fstat_fd_callback">fs.fstat(fd, [callback])</a></li>
<li><a href="#all_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="#all_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="#all_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="#all_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, [callback])</a></li>
<li><a href="#all_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="#all_fs_symlink_linkdata_path_callback">fs.symlink(linkdata, path, [callback])</a></li>
<li><a href="#all_fs_symlinksync_linkdata_path">fs.symlinkSync(linkdata, path)</a></li>
<li><a href="#all_fs_readlink_path_callback">fs.readlink(path, [callback])</a></li>
<li><a href="#all_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="#all_fs_realpath_path_callback">fs.realpath(path, [callback])</a></li>
<li><a href="#all_fs_realpathsync_path">fs.realpathSync(path)</a></li>
<li><a href="#all_fs_unlink_path_callback">fs.unlink(path, [callback])</a></li>
<li><a href="#all_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="#all_fs_rmdir_path_callback">fs.rmdir(path, [callback])</a></li>
<li><a href="#all_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="#all_fs_mkdir_path_mode_callback">fs.mkdir(path, mode, [callback])</a></li>
<li><a href="#all_fs_mkdirsync_path_mode">fs.mkdirSync(path, mode)</a></li>
<li><a href="#all_fs_readdir_path_callback">fs.readdir(path, [callback])</a></li>
<li><a href="#all_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="#all_fs_close_fd_callback">fs.close(fd, [callback])</a></li>
<li><a href="#all_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="#all_fs_open_path_flags_mode_callback">### fs.open(path, flags, [mode], [callback])</a></li>
<li><a href="#all_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="#all_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_writesync_fd_str_position_encoding_utf8">fs.writeSync(fd, str, position, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, [callback])</a></li>
<li><a href="#all_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#all_fs_readsync_fd_length_position_encoding">fs.readSync(fd, length, position, encoding)</a></li>
<li><a href="#all_fs_readfile_filename_encoding_callback">fs.readFile(filename, [encoding], [callback])</a></li>
<li><a href="#all_fs_readfilesync_filename_encoding">fs.readFileSync(filename, [encoding])</a></li>
<li><a href="#all_fs_writefile_filename_data_encoding_utf8_callback">fs.writeFile(filename, data, encoding=&apos;utf8&apos;, [callback])</a></li>
<li><a href="#all_fs_writefilesync_filename_data_encoding_utf8">fs.writeFileSync(filename, data, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="#all_fs_unwatchfile_filename">fs.unwatchFile(filename)</a></li>
</ul>
</li>
<li><a href="#all_fs_stats">fs.Stats</a></li>
<li><a href="#all_fs_readstream">fs.ReadStream</a><ul>
<li><a href="#all_open">Событие: &apos;open&apos;</a></li>
<li><a href="#all_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
</ul>
</li>
<li><a href="#all_fs_writestream">fs.WriteStream</a><ul>
<li><a href="#all_open_1">Событие: &apos;open&apos;</a></li>
<li><a href="#all_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
</ul>
</li>
<li><a href="#all_path">Path</a><ul>
<li><a href="#all_path_normalize_p">path.normalize(p)</a></li>
<li><a href="#all_path_join_path1_path2">path.join([path1], [path2], [...])</a></li>
<li><a href="#all_path_resolve_from_to">path.resolve([from ...], to)</a></li>
<li><a href="#all_path_dirname_p">path.dirname(p)</a></li>
<li><a href="#all_path_basename_p_ext">path.basename(p, [ext])</a></li>
<li><a href="#all_path_extname_p">path.extname(p)</a></li>
<li><a href="#all_path_exists_p_callback">path.exists(p, [callback])</a></li>
<li><a href="#all_path_existssync_p">path.existsSync(p)</a></li>
</ul>
</li>
<li><a href="#all_tcp">TCP / Сеть</a><ul>
<li><a href="#all_net_createserver_options_connectionlistener">net.createServer([options], [connectionListener])</a></li>
<li><a href="#all_net_createconnection_arguments">net.createConnection(arguments...)</a></li>
<li><a href="#all_net_server">net.Server</a><ul>
<li><a href="#all_server_listen_port_host_callback_1">server.listen(port, [host], [callback])</a></li>
<li><a href="#all_server_listen_path_callback">server.listen(path, [callback])</a></li>
<li><a href="#all_server_listenfd_fd">server.listenFD(fd)</a></li>
<li><a href="#all_server_pause_msecs">server.pause([msecs])</a></li>
<li><a href="#all_server_close_1">server.close()</a></li>
<li><a href="#all_server_address">server.address()</a></li>
<li><a href="#all_server_maxconnections_1">server.maxConnections</a></li>
<li><a href="#all_server_connections_1">server.connections</a></li>
<li><a href="#all_connection">Событие: &apos;connection&apos;</a></li>
<li><a href="#all_close_2">Событие: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_net_socket">net.Socket</a><ul>
<li><a href="#all_new_net_socket_options">new net.Socket([options])</a></li>
<li><a href="#all_socket_connect_port_host">socket.connect(port, [host])</a></li>
<li><a href="#all_socket_connect_path">socket.connect(path)</a></li>
<li><a href="#all_socket_buffersize">socket.bufferSize</a></li>
<li><a href="#all_socket_setencoding_encoding_null">socket.setEncoding(encoding=null)</a></li>
<li><a href="#all_socket_setsecure_credentials">socket.setSecure([credentials])</a></li>
<li><a href="#all_socket_write_data_encoding_callback">socket.write(data, [encoding], [callback])</a></li>
<li><a href="#all_socket_write_data_encoding_filedescriptor_callback">socket.write(data, [encoding], [fileDescriptor], [callback])</a></li>
<li><a href="#all_socket_end_data_encoding">socket.end([data], [encoding])</a></li>
<li><a href="#all_socket_destroy">socket.destroy()</a></li>
<li><a href="#all_socket_pause">socket.pause()</a></li>
<li><a href="#all_socket_resume">socket.resume()</a></li>
<li><a href="#all_socket_settimeout_timeout_callback">socket.setTimeout(timeout, [callback])</a></li>
<li><a href="#all_socket_setnodelay_nodelay_true">socket.setNoDelay(noDelay=true)</a></li>
<li><a href="#all_socket_setkeepalive_enable_false_initialdelay">socket.setKeepAlive(enable=false, [initialDelay])</a></li>
<li><a href="#all_socket_address">socket.address()</a></li>
<li><a href="#all_socket_remoteaddress">socket.remoteAddress</a></li>
<li><a href="#all_connect">Событие: &apos;connect&apos;</a></li>
<li><a href="#all_data_1">Событие: &apos;data&apos;</a></li>
<li><a href="#all_end_1">Событие: &apos;end&apos;</a></li>
<li><a href="#all_timeout">Событие: &apos;timeout&apos;</a></li>
<li><a href="#all_drain_1">Событие: &apos;drain&apos;</a></li>
<li><a href="#all_error_1">Событие: &apos;error&apos;</a></li>
<li><a href="#all_close_3">Событие: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_net_isip">net.isIP</a><ul>
<li><a href="#all_net_isip_input">net.isIP(input)</a></li>
<li><a href="#all_net_isipv4_input">net.isIPv4(input)</a></li>
<li><a href="#all_net_isipv6_input">net.isIPv6(input)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_udp">UDP / Датаграммы</a><ul>
<li><a href="#all_dgram_createsocket_type_callback">dgram.createSocket(type, [callback])</a></li>
<li><a href="#all_socket">Класс: Socket</a><ul>
<li><a href="#all_message">Событие: &apos;message&apos;</a></li>
<li><a href="#all_listening">Событие: &apos;listening&apos;</a></li>
<li><a href="#all_close_4">Событие: &apos;close&apos;</a></li>
<li><a href="#all_dgram_send_buf_offset_length_path_callback">dgram.send(buf, offset, length, path, [callback])</a></li>
<li><a href="#all_dgram_send_buf_offset_length_port_address_callback">dgram.send(buf, offset, length, port, address, [callback])</a></li>
<li><a href="#all_dgram_bind_path">dgram.bind(path)</a></li>
<li><a href="#all_dgram_bind_port_address">dgram.bind(port, [address])</a></li>
<li><a href="#all_dgram_close">dgram.close()</a></li>
<li><a href="#all_dgram_address">dgram.address()</a></li>
<li><a href="#all_dgram_setbroadcast_flag">dgram.setBroadcast(flag)</a></li>
<li><a href="#all_dgram_setttl_ttl">dgram.setTTL(ttl)</a></li>
<li><a href="#all_dgram_setmulticastttl_ttl">dgram.setMulticastTTL(ttl)</a></li>
<li><a href="#all_dgram_setmulticastloopback_flag">dgram.setMulticastLoopback(flag)</a></li>
<li><a href="#all_dgram_addmembership_multicastaddress_multicastinterface">dgram.addMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="#all_dgram_dropmembership_multicastaddress_multicastinterface">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li>
</ul>
</li>
<li><a href="#all_dns">DNS</a><ul>
<li><a href="#all_dns_lookup_domain_family_null_callback">dns.lookup(domain, family=null, callback)</a></li>
<li><a href="#all_dns_resolve_domain_rrtype_a_callback">dns.resolve(domain, rrtype=&apos;A&apos;, callback)</a></li>
<li><a href="#all_dns_resolve4_domain_callback">dns.resolve4(domain, callback)</a></li>
<li><a href="#all_dns_resolve6_domain_callback">dns.resolve6(domain, callback)</a></li>
<li><a href="#all_dns_resolvemx_domain_callback">dns.resolveMx(domain, callback)</a></li>
<li><a href="#all_dns_resolvetxt_domain_callback">dns.resolveTxt(domain, callback)</a></li>
<li><a href="#all_dns_resolvesrv_domain_callback">dns.resolveSrv(domain, callback)</a></li>
<li><a href="#all_dns_reverse_ip_callback">dns.reverse(ip, callback)</a></li>
<li><a href="#all_dns_resolvens_domain_callback">dns.resolveNs(domain, callback)</a></li>
<li><a href="#all_dns_resolvecname_domain_callback">dns.resolveCname(domain, callback)</a></li>
</ul>
</li>
<li><a href="#all_http">HTTP</a></li>
<li><a href="#all_http_server">http.Server</a><ul>
<li><a href="#all_request">Событие: &apos;request&apos;</a></li>
<li><a href="#all_connection_1">Событие: &apos;connection&apos;</a></li>
<li><a href="#all_close_5">Событие: &apos;close&apos;</a></li>
<li><a href="#all_checkcontinue">Событие: &apos;checkContinue&apos;</a></li>
<li><a href="#all_upgrade">Событие: &apos;upgrade&apos;</a></li>
<li><a href="#all_clienterror">Событие: &apos;clientError&apos;</a></li>
<li><a href="#all_http_createserver_requestlistener">http.createServer([requestListener])</a></li>
<li><a href="#all_server_listen_port_hostname_callback">server.listen(port, [hostname], [callback])</a></li>
<li><a href="#all_server_listen_path_callback_1">server.listen(path, [callback])</a></li>
<li><a href="#all_server_close_2">server.close()</a></li>
</ul>
</li>
<li><a href="#all_http_serverrequest">http.ServerRequest</a><ul>
<li><a href="#all_data_2">Событие: &apos;data&apos;</a></li>
<li><a href="#all_end_2">Событие: &apos;end&apos;</a></li>
<li><a href="#all_close_6">Событие: &apos;close&apos;</a></li>
<li><a href="#all_request_method">request.method</a></li>
<li><a href="#all_request_url">request.url</a></li>
<li><a href="#all_request_headers">request.headers</a></li>
<li><a href="#all_request_trailers">request.trailers</a></li>
<li><a href="#all_request_httpversion">request.httpVersion</a></li>
<li><a href="#all_request_setencoding_encoding_null">request.setEncoding(encoding=null)</a></li>
<li><a href="#all_request_pause">request.pause()</a></li>
<li><a href="#all_request_resume">request.resume()</a></li>
<li><a href="#all_request_connection">request.connection</a></li>
</ul>
</li>
<li><a href="#all_http_serverresponse">http.ServerResponse</a><ul>
<li><a href="#all_response_writecontinue">response.writeContinue()</a></li>
<li><a href="#all_response_writehead_statuscode_reasonphrase_headers">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="#all_response_statuscode">response.statusCode</a></li>
<li><a href="#all_response_setheader_name_value">response.setHeader(name, value)</a></li>
<li><a href="#all_response_getheader_name">response.getHeader(name)</a></li>
<li><a href="#all_response_removeheader_name">response.removeHeader(name)</a></li>
<li><a href="#all_response_write_chunk_encoding_utf8">response.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_response_addtrailers_headers">response.addTrailers(headers)</a></li>
<li><a href="#all_response_end_data_encoding">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="#all_http_request_options_callback">http.request(options, callback)</a></li>
<li><a href="#all_http_get_options_callback">http.get(options, callback)</a><ul>
<li><a href="#all_upgrade_1">Событие: &apos;upgrade&apos;</a></li>
</ul>
</li>
<li><a href="#all_http_agent">http.Agent</a></li>
<li><a href="#all_http_getagent_host_port">http.getAgent(host, port)</a><ul>
<li><a href="#all_agent_maxsockets">agent.maxSockets</a></li>
<li><a href="#all_agent_sockets">agent.sockets</a></li>
<li><a href="#all_agent_queue">agent.queue</a></li>
</ul>
</li>
<li><a href="#all_http_clientrequest">http.ClientRequest</a><ul>
<li><a href="#all_continue">Событие: &apos;continue&apos;</a></li>
<li><a href="#all_response">Событие: &apos;response&apos;</a></li>
<li><a href="#all_request_write_chunk_encoding_utf8">request.write(chunk, encoding=&apos;utf8&apos;)</a></li>
<li><a href="#all_request_end_data_encoding">request.end([data], [encoding])</a></li>
<li><a href="#all_request_abort">request.abort()</a></li>
</ul>
</li>
<li><a href="#all_http_clientresponse">http.ClientResponse</a><ul>
<li><a href="#all_data_3">Событие: &apos;data&apos;</a></li>
<li><a href="#all_end_3">Событие: &apos;end&apos;</a></li>
<li><a href="#all_close_7">Событие: &apos;close&apos;</a></li>
<li><a href="#all_response_statuscode_1">response.statusCode</a></li>
<li><a href="#all_response_httpversion">response.httpVersion</a></li>
<li><a href="#all_response_headers">response.headers</a></li>
<li><a href="#all_response_trailers">response.trailers</a></li>
<li><a href="#all_response_setencoding_encoding_null">response.setEncoding(encoding=null)</a></li>
<li><a href="#all_response_pause">response.pause()</a></li>
<li><a href="#all_response_resume">response.resume()</a></li>
</ul>
</li>
<li><a href="#all_https">HTTPS</a></li>
<li><a href="#all_https_server">https.Server</a></li>
<li><a href="#all_https_createserver_options_requestlistener">https.createServer(options, [requestListener])</a></li>
<li><a href="#all_https_request_options_callback">https.request(options, callback)</a></li>
<li><a href="#all_https_get_options_callback">https.get(options, callback)</a></li>
<li><a href="#all_url">URL</a><ul>
<li><a href="#all_url_parse_urlstr_parsequerystring_false_slashesdenotehost_false">url.parse(urlStr, parseQueryString=false, slashesDenoteHost=false)</a></li>
<li><a href="#all_url_format_urlobj">url.format(urlObj)</a></li>
<li><a href="#all_url_resolve_from_to">url.resolve(from, to)</a></li>
</ul>
</li>
<li><a href="#all_30">Разбор строки запроса</a><ul>
<li><a href="#all_querystring_stringify_obj_sep_eq">querystring.stringify(obj, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)</a></li>
<li><a href="#all_querystring_parse_str_sep_eq">querystring.parse(str, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)</a></li>
<li><a href="#all_querystring_escape">querystring.escape</a></li>
<li><a href="#all_querystring_unescape">querystring.unescape</a></li>
</ul>
</li>
<li><a href="#all_readline">Readline</a><ul>
<li><a href="#all_rl_createinterface_input_output_completer">rl.createInterface(input, output, completer)</a></li>
<li><a href="#all_rl_setprompt_prompt_length">rl.setPrompt(prompt, length)</a></li>
<li><a href="#all_rl_prompt">rl.prompt()</a></li>
<li><a href="#all_rl_question_query_callback">rl.question(query, callback)</a></li>
<li><a href="#all_rl_close">rl.close()</a></li>
<li><a href="#all_rl_pause">rl.pause()</a></li>
<li><a href="#all_rl_resume">rl.resume()</a></li>
<li><a href="#all_rl_write">rl.write()</a></li>
<li><a href="#all_event_line">Event: &apos;line&apos;</a></li>
<li><a href="#all_event_close">Event: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="#all_repl">Интерактивная консоль (REPL)</a><ul>
<li><a href="#all_repl_start_prompt_stream_process_openstdin">repl.start(prompt=&apos;&gt; &apos;, stream=process.openStdin())</a></li>
<li><a href="#all_repl_1">Возможности REPL</a></li>
</ul>
</li>
<li><a href="#all_javascript">Выполнение JavaScript</a><ul>
<li><a href="#all_vm_runinthiscontext_code_filename">vm.runInThisContext(code, [filename])</a></li>
<li><a href="#all_vm_runinnewcontext_code_sandbox_filename">vm.runInNewContext(code, [sandbox], [filename])</a></li>
<li><a href="#all_vm_createscript_code_filename">vm.createScript(code, [filename])</a></li>
</ul>
</li>
<li><a href="#all_script">Класс: Script</a><ul>
<li><a href="#all_script_runinthiscontext">script.runInThisContext()</a></li>
<li><a href="#all_script_runinnewcontext_sandbox">script.runInNewContext([sandbox])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_31">Дочерний процесс</a><ul>
<li><a href="#all_class_childprocess">Class: ChildProcess</a><ul>
<li><a href="#all_exit_1">Событие: &apos;exit&apos;</a></li>
<li><a href="#all_child_stdin">child.stdin</a></li>
<li><a href="#all_child_stdout">child.stdout</a></li>
<li><a href="#all_child_stderr">child.stderr</a></li>
<li><a href="#all_child_pid">child.pid</a></li>
<li><a href="#all_child_kill_signal_sigterm">child.kill(signal=&apos;SIGTERM&apos;)</a></li>
<li><a href="#all_child_send_message_sendhandle">child.send(message, [sendHandle])</a></li>
</ul>
</li>
<li><a href="#all_child_process_spawn_command_args_options">child_process.spawn(command, [args], [options])</a></li>
<li><a href="#all_child_process_exec_command_options_callback">child_process.exec(command, [options], callback)</a></li>
<li><a href="#all_child_process_execfile_file_args_options_callback">child_process.execFile(file, args, options, callback)</a></li>
<li><a href="#all_child_process_fork_modulepath_args_options">child_process.fork(modulePath, [args], [options])</a></li>
</ul>
</li>
<li><a href="#all_asserts">Тестирование (asserts)</a><ul>
<li><a href="#all_assert_fail_actual_expected_message_operator">assert.fail(actual, expected, message, operator)</a></li>
<li><a href="#all_assert_ok_value_message">assert.ok(value, [message])</a></li>
<li><a href="#all_assert_equal_actual_expected_message">assert.equal(actual, expected, [message])</a></li>
<li><a href="#all_assert_notequal_actual_expected_message">assert.notEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_deepequal_actual_expected_message">assert.deepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notdeepequal_actual_expected_message">assert.notDeepEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_strictequal_actual_expected_message">assert.strictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_notstrictequal_actual_expected_message">assert.notStrictEqual(actual, expected, [message])</a></li>
<li><a href="#all_assert_throws_block_error_message">assert.throws(block, [error], [message])</a></li>
<li><a href="#all_assert_doesnotthrow_block_error_message">assert.doesNotThrow(block, [error], [message])</a></li>
<li><a href="#all_assert_iferror_value">assert.ifError(value)</a></li>
<li><a href="#all_tty">TTY</a><ul>
<li><a href="#all_tty_open_path_args">tty.open(path, args=[])</a></li>
<li><a href="#all_tty_isatty_fd">tty.isatty(fd)</a></li>
<li><a href="#all_tty_setrawmode_mode">tty.setRawMode(mode)</a></li>
<li><a href="#all_tty_setwindowsize_fd_row_col">tty.setWindowSize(fd, row, col)</a></li>
<li><a href="#all_tty_getwindowsize_fd">tty.getWindowSize(fd)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_zlib">Zlib</a><ul>
<li><a href="#all_32">Примеры</a></li>
<li><a href="#all_33">Константы</a></li>
<li><a href="#all_zlib_creategzip">zlib.createGzip([параметры])</a></li>
<li><a href="#all_zlib_creategunzip">zlib.createGunzip([параметры])</a></li>
<li><a href="#all_zlib_createdeflate">zlib.createDeflate([параметры])</a></li>
<li><a href="#all_zlib_createinflate">zlib.createInflate([параметры])</a></li>
<li><a href="#all_zlib_createdeflateraw">zlib.createDeflateRaw([параметры])</a></li>
<li><a href="#all_zlib_createinflateraw">zlib.createInflateRaw([параметры])</a></li>
<li><a href="#all_zlib_createunzip">zlib.createUnzip([параметры])</a></li>
<li><a href="#all_zlib_gzip">Класс: zlib.Gzip</a></li>
<li><a href="#all_zlib_gunzip">Класс: zlib.Gunzip</a></li>
<li><a href="#all_zlib_deflate">Класс: zlib.Deflate</a></li>
<li><a href="#all_zlib_inflate">Класс: zlib.Inflate</a></li>
<li><a href="#all_zlib_deflateraw">Класс: zlib.DeflateRaw</a></li>
<li><a href="#all_zlib_inflateraw">Класс: zlib.InflateRaw</a></li>
<li><a href="#all_zlib_unzip">Класс: zlib.Unzip</a></li>
<li><a href="#all_34">Удобные методы</a></li>
<li><a href="#all_zlib_deflate_buf_callback">zlib.deflate(buf, callback)</a></li>
<li><a href="#all_zlib_deflateraw_buf_callback">zlib.deflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_gzip_buf_callback">zlib.gzip(buf, callback)</a></li>
<li><a href="#all_zlib_gunzip_buf_callback">zlib.gunzip(buf, callback)</a></li>
<li><a href="#all_zlib_inflate_buf_callback">zlib.inflate(buf, callback)</a></li>
<li><a href="#all_zlib_inflateraw_buf_callback">zlib.inflateRaw(buf, callback)</a></li>
<li><a href="#all_zlib_unzip_buf_callback">zlib.unzip(buf, callback)</a></li>
<li><a href="#all_35">Опции</a></li>
<li><a href="#all_36">Настройки использования памяти</a></li>
</ul>
</li>
<li><a href="#all_37">Операционная система</a><ul>
<li><a href="#all_os_hostname">os.hostname()</a></li>
<li><a href="#all_os_type">os.type()</a></li>
<li><a href="#all_os_platform">os.platform()</a></li>
<li><a href="#all_os_arch">os.arch()</a></li>
<li><a href="#all_os_release">os.release()</a></li>
<li><a href="#all_os_uptime">os.uptime()</a></li>
<li><a href="#all_os_loadavg">os.loadavg()</a></li>
<li><a href="#all_os_totalmem">os.totalmem()</a></li>
<li><a href="#all_os_freemem">os.freemem()</a></li>
<li><a href="#all_os_cpus">os.cpus()</a></li>
<li><a href="#all_os_networkinterfaces">os.networkInterfaces()</a></li>
<li><a href="#all_38">Встроенный отладчик</a><ul>
<li><a href="#all_39">Продвинутое использование</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_cluster">Cluster</a><ul>
<li><a href="#all_cluster_fork">cluster.fork()</a></li>
<li><a href="#all_cluster_ismaster">cluster.isMaster</a></li>
<li><a href="#all_cluster_isworker">cluster.isWorker</a></li>
<li><a href="#all_event_death">Event: &apos;death&apos;</a></li>
</ul>
</li>
<li><a href="#all_1">Приложение 1 - Рекомендуемые сторонние модули</a></li>
</ul>

          </div>

          <div id="apicontent">
            <h1>О документации<span><a class="mark" href="#all" id="all">#</a></span></h1>
<!-- type=misc -->

<p>Целью даннй документации является всесторонний обзор API Node.js,
как с точки зрения справки, так и с концептуальной стороны.
Каждая часть описывает встроенный модуль или высокоуровневую концепцию.

</p>
<p>Где это возможно, после названия метода или события приводится
список аргументов с описанием ихз типов, а также тип возвращаемого значения.

</p>
<p>Каждый <code>.html</code> документ имеет соответствующий ему <code>.json</code> документ,
содержащий идентичную информацию в структурированном виде.
Этот экспериментальный функционал добавлен для использования его
в IDE и инструментах, которым необходим програмный доступ к документации.

</p>
<p>Каждый <code>.html</code> и <code>.json</code> файл создаётся на основе соответствующего
<code>.markdown</code> файла из папки <code>doc/api/</code> репозитория исходного кода Node.
Документация генерируется скриптом <code>tools/doc/generate.js</code>.
HTML шаблон документации находится в <code>doc/template.html</code>.

</p>
<h2>Индекс стабильности<span><a class="mark" href="#all_1" id="all_1">#</a></span></h2>
<!--type=misc-->

<p>При чтении документации вы можете обратить внимание на индикаторы стабильности отдельныйх частей.
API Node.js продолжает изменяться и его различные части могут быть подвержены различным изменениям.
Некоторые части скорее всего не будут никогда изменены, тогда как другие являются экспериментальными
и могут значительно измениться процессе развития.

</p>
<p>Индикаторы стабильности выглядят следующим образом:

</p>
<pre><code>Стабильность: 1 - Экспериментально</code></pre>
<p>Возможные значения индекса стабильности:

</p>
<ul>
<li><strong>0 - Устарело</strong>  Это API может вызывать проблемы, т.к. в нём запланированы изменения.
Обратная совместимость невозможна.</li>
</ul>
<ul>
<li><strong>1 - Экспериментально</strong>  Это API появилось недавно и может быть изменено или удалено в будущих версиях.
Пожалуйста, попробуйте его и при необходимости оставьте свои отзывы.
Если оно будет полезно и важно для вашего использования Node, сообщите об этом команде разработчиковNode .</li>
</ul>
<ul>
<li><strong>2 - Нестабильно</strong>  Это API в процессе становления и пока ещё не прошло достаточного тестирования в реальных проектах.
Обратная совместимость возможно при наличии существенных аргументов.</li>
</ul>
<ul>
<li><strong>3 - Стабильно</strong>  Это API достаточно проверено, но возможны небольшие изменения кода методов этого API.
При этом гарантируется обратная совместимость.</li>
</ul>
<ul>
<li><strong>4 - API заморожено</strong>  Это API интенсивно тестировалось на рабочих проектах и скорее всего никогда не будт изменено.</li>
</ul>
<ul>
<li><strong>5 - Заблокировано</strong>  Это API не изменится, за исключением случая возникновения серьёзного бага.
Пожалуйста, не предлагайте изменений в этой части API, они будут отклонены.</li>
</ul>
<h1>Краткий обзор<span><a class="mark" href="#all_2" id="all_2">#</a></span></h1>
<!--type=misc-->

<p>Пример <a href="http.html">web сервера</a>, написанного с помощью Node
и отвечающего строкой &apos;Hello World&apos;:

</p>
<pre><code>var http = require(&apos;http&apos;);

http.createServer(function (request, response) {
  response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
  response.end(&apos;Hello World\n&apos;);
}).listen(8124);

console.log(&apos;Server running at http://127.0.0.1:8124/&apos;);</code></pre>
<p>Чтобы запустить сервер, поместите код в файл с названием <code>example.js</code>
и выполните его программой <code>node</code>:

</p>
<pre><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>
<p>Все примеры в этом руководстве можно запустить таким же образом.


</p>
<h2>Глобальные объекты<span><a class="mark" href="#all_3" id="all_3">#</a></span></h2>
<p>Эти объекты доступны в любом модуле. При их использовании нужно иметь в виду
что некоторые из них находятся не в глобальной области видимости, а в области видимости модуля.

</p>
<h3>global<span><a class="mark" href="#all_global" id="all_global">#</a></span></h3>
<p>Глобальный объект.

</p>
<p>В браузерах глобальной областью видимости <code>window</code> одна для всех подключённых на странице скриптов.
Т.е. в браузерах конструкция <code>var something</code> в начале скрипта создаст глобальную переменную.
В Node это поведение другое, а именно у каждого модуля есть своё пространство имён.
Чтобы создать переменную, видимую из всех модулей, её нужно явно создать как свойство объекта <code>global</code>.

</p>
<h3>process<span><a class="mark" href="#all_process" id="all_process">#</a></span></h3>
<p>Объект процесса. Большая часть данных процесса находится именно здесь.
См. секцию <a href="process.html#process">&apos;Процесс&apos;</a>.

</p>
<h3>console<span><a class="mark" href="#all_console" id="all_console">#</a></span></h3>
<p>Используется для вывода в stdout и stderr. См. секцию <a href="stdio.html">&apos;Стандартный вывод&apos;</a>.

</p>
<h3>require()<span><a class="mark" href="#all_require" id="all_require">#</a></span></h3>
<p>Подключает модули. См. секцию <a href="modules.html#modules">&apos;Модули&apos;</a>.
<code>require</code> является не глобальной функцией, а локальной для каждого модуля.

</p>
<h3>require.resolve()<span><a class="mark" href="#all_require_resolve" id="all_require_resolve">#</a></span></h3>
<p>Использует внутреннюю логику <code>require()</code> для определение местоположения модуля,
но не загружает его, а возвращает имя файла, содержащего модуль.

</p>
<h3>require.paths<span><a class="mark" href="#all_require_paths" id="all_require_paths">#</a></span></h3>
<p>Массив путей поиска для <code>require()</code>. Этот массив может быть изменён
для добавления пользовательских путей.

</p>
<p>Пример: добавить новый путь в начало массива.

</p>
<pre><code>require.paths.unshift(&apos;/usr/local/node&apos;);</code></pre>
<h3>__filename<span><a class="mark" href="#all_filename" id="all_filename">#</a></span></h3>
<p>Имя исполняемого скрипта. Это абсолютный путь, и не всегда это будет то же имя, которое было передано в аргументе командной строки.

</p>
<p>Пример: запускаем <code>node example.js</code> из папки <code>/Users/mjr</code>.

</p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>
<p><code>__filename</code> является не глобальной переменной, а локальной для каждого модуля.


</p>
<h3>__dirname<span><a class="mark" href="#all_dirname" id="all_dirname">#</a></span></h3>
<p>Имя директории исполняемого скрипта.

</p>
<p>Пример: запускаем <code>node example.js</code> из папки <code>/Users/mjr</code>.

</p>
<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>
<p><code>__dirname</code> является не глобальной переменной, а локальной для каждого модуля.

</p>
<h3>module<span><a class="mark" href="#all_module" id="all_module">#</a></span></h3>
<p>Ссылка на текущий модуль (типа <code>process.Module</code>). В частности, <code>module.exports</code> —
то же самое, что и объект <code>exports</code>. См. <code>src/node.js</code> для подробной информации.
<code>module</code> является не глобальной переменной, а локальной для каждого модуля.

</p>
<h3>exports<span><a class="mark" href="#all_exports" id="all_exports">#</a></span></h3>
<p>Объект, который является общим для всех экземпляров текущего модуля и становящийся доступным при использовании <code>require()</code>.
<code>exports</code> является тем же объектом, что и <code>module.exports</code>. Подробности реализации вы можете посмотреть в файле <code>src/node.js</code> исходного кода Node.
Объект <code>exports</code> не является истинно глобальным, а локален для каждого модуля.

</p>
<h3>setTimeout(cb, ms)<span><a class="mark" href="#all_settimeout_cb_ms" id="all_settimeout_cb_ms">#</a></span></h3>
<h3>clearTimeout(t)<span><a class="mark" href="#all_cleartimeout_t" id="all_cleartimeout_t">#</a></span></h3>
<h3>setInterval(cb, ms)<span><a class="mark" href="#all_setinterval_cb_ms" id="all_setinterval_cb_ms">#</a></span></h3>
<h3>clearInterval(t)<span><a class="mark" href="#all_clearinterval_t" id="all_clearinterval_t">#</a></span></h3>
<p>Функции таймера являются глобальными. См. секцию <a href="timers.html">&apos;Таймеры&apos;</a>.


</p>
<h1>console<span><a class="mark" href="#all_console_1" id="all_console_1">#</a></span></h1>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<!--type=global-->

<p>Объект для вывода в стандартный поток вывода <code>stdout</code> и стандартный поток ошибок <code>stderr</code>.
Похож на <code>console</code> в браузерах.

</p>
<h2>console.log()<span><a class="mark" href="#all_console_log" id="all_console_log">#</a></span></h2>
<p>Выводит строку в <code>stdout</code>, с переходом на новую строку. Функция может принимать
несколько аргументов и работать как <code>printf()</code>. Пример:

</p>
<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>
<p>Если первый аргумент <code>console.log()</code> не является строкой, то будут выведены преобразованные в строки аргументы,
разделённые пробелом. Преобразование осуществляется функцией <code>util.inspect()</code>.
Подробнее об этом смотрите в описании метода <a href="util.html#util.format">util.format()</a>.


</p>
<h2>console.info()<span><a class="mark" href="#all_console_info" id="all_console_info">#</a></span></h2>
<p>Синоним <code>console.log</code>.

</p>
<h2>console.warn()<span><a class="mark" href="#all_console_warn" id="all_console_warn">#</a></span></h2>
<h2>console.error()<span><a class="mark" href="#all_console_error" id="all_console_error">#</a></span></h2>
<p>Тоже самое, что и <code>console.log</code>, но выводит данные в <code>stderr</code>

</p>
<h2>console.dir(obj)<span><a class="mark" href="#all_console_dir_obj" id="all_console_dir_obj">#</a></span></h2>
<p>Выводит результат вызова <code>util.inspect</code> для <code>obj</code> в <code>stderr</code>.

</p>
<h2>console.time(label)<span><a class="mark" href="#all_console_time_label" id="all_console_time_label">#</a></span></h2>
<p>Запоминает текущее время.

</p>
<h2>console.timeEnd(label)<span><a class="mark" href="#all_console_timeend_label" id="all_console_timeend_label">#</a></span></h2>
<p>Завершает отсчёт времени и выводит результат. Пример:

</p>
<pre><code>console.time(&apos;100-elements&apos;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&apos;100-elements&apos;);</code></pre>
<h2>console.trace()<span><a class="mark" href="#all_console_trace" id="all_console_trace">#</a></span></h2>
<p>Выводит в <code>stderr</code> стек вызова для текущей инструкции.

</p>
<h2>console.assert()<span><a class="mark" href="#all_console_assert" id="all_console_assert">#</a></span></h2>
<p>Синоним <code>assert.ok()</code>.


</p>
<h2>Таймеры<span><a class="mark" href="#all_4" id="all_4">#</a></span></h2>
<h3>setTimeout(callback, delay, [arg], [...])<span><a class="mark" href="#all_settimeout_callback_delay_arg" id="all_settimeout_callback_delay_arg">#</a></span></h3>
<p>Позволяет выполнить переданный <code>callback</code> через <code>delay</code> миллисекунд.
Возвращает ID таймаута — <code>timeoutId</code> для последующего использования с <code>clearTimeout()</code>.

</p>
<h3>clearTimeout(timeoutId)<span><a class="mark" href="#all_cleartimeout_timeoutid" id="all_cleartimeout_timeoutid">#</a></span></h3>
<p>Отменяет установленный таймаут.

</p>
<h3>setInterval(callback, delay, [arg], [...])<span><a class="mark" href="#all_setinterval_callback_delay_arg" id="all_setinterval_callback_delay_arg">#</a></span></h3>
<p>Позволяет выполнять переданный <code>callback</code> каждые <code>delay</code> миллисекунд.
Возвращает ID интервала — <code>intervalId</code> для использования с <code>clearInterval()</code>.
Кроме того, можно передавать аргументы callback&apos;у.

</p>
<h3>clearInterval(intervalId)<span><a class="mark" href="#all_clearinterval_intervalid" id="all_clearinterval_intervalid">#</a></span></h3>
<p>Прекращает действие интервального таймера.


</p>
<h2>Модули<span><a class="mark" href="#all_5" id="all_5">#</a></span></h2>
<p>Node имеет простую систему загрузки модулей, файлы и модули в которой являются,
в каком-то смысле, синонимами. В примере <code>foo.js</code> загружает модуль <code>circle.js</code>,
находящийся в той же директории.

</p>
<p>Содержимое <code>foo.js</code>:

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;The area of a circle of radius 4 is &apos;
           + circle.area(4));</code></pre>
<p>Содержимое <code>circle.js</code>:

</p>
<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>
<p>Модуль <code>circle.js</code> экспортирует функции <code>area()</code> и <code>circumference()</code>. Для этого
достаточно добавить экспортируемые функции/объекты к специальному объекты <code>exports</code>.
(В качетве альтернативы можно использовать <code>this</code> вместо <code>exports</code>.) Переменные,
локальные для модуля, не будут видны извне. В этом примере переменная <code>PI</code> видна
только внутри модуля <code>circle.js</code>.

</p>
<h2>Стандартные модули<span><a class="mark" href="#all_6" id="all_6">#</a></span></h2>
<p>Вместе с Node поставляется несколько стандартных встроенных модулей,
большинство из которых описано ниже.

</p>
<p>Стандартные модули можно найти в папке <code>lib/</code> исходного кода node.

</p>
<p>Стандартные модули всегда имеют приоритет при загрузке с помощью <code>require()</code>.
Например, <code>require(&apos;http&apos;)</code> всегда возвратит стандартный модуль HTTP, даже если
существует другой файл с таким именем.

</p>
<h3>Поиск модулей<span><a class="mark" href="#all_7" id="all_7">#</a></span></h3>
<p>Если файла с именем, переданным в <code>require()</code>, не существует, то node сначала
пытается загрузить файлы с этим именем и дополнительным расширением <code>.js</code> потом <code>.node</code>.

</p>
<p><code>.js</code> файлы трактуются как текстовые файлы с JavaScript-кодом, а <code>.node</code> файлы
трактуются как скомпилированные дополнения и загружаются с помощью <code>dlopen</code>.

</p>
<p>Имена, начинающиеся на <code>&apos;/&apos;</code>, считаются абсолютными путями. Например,
<code>require(&apos;/home/marco/foo.js&apos;)</code> будет загружать файл <code>/home/marco/foo.js</code>.

</p>
<p>Модули, имена которых начинаются на <code>&apos;./&apos;</code> считаются относительными для
вызывающего <code>require()</code> модуля. Это означает, что в примере выше <code>circle.js</code>
должен находиться в той же папке, что и <code>foo.js</code>, тогда <code>require(&apos;./circle&apos;)</code>
будет работать.

</p>
<p>В случае отсутствия <code>&apos;/&apos;</code> или <code>&apos;./&apos;</code>, которые указывают на необходимость поиска файла,
модуль является илбо стандартным модулем, либо загружается из папки <code>node_modules</code>.

</p>
<h3>Загрузка из папок <code>node_modules</code><span><a class="mark" href="#all_node_modules" id="all_node_modules">#</a></span></h3>
<p>Если идентификатор модуля, переданный в <code>require()</code> не представляет стандартный модуль
и не начинается на <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code> или <code>&apos;./&apos;</code>, то node берёт папку текущего модуля,
добалвет к ней <code>&apos;/node_modules&apos;</code> и пытается загрузить модуль из этой папки.

</p>
<p>Если по этому пути модуль не будет найден, то node переходит к родительской папке
и так далее, пока не будет достигнут корень файловой системы.

</p>
<p>Например, если файл <code>&apos;/home/ry/projects/foo.js&apos;</code> вызывает <code>require(&apos;bar.js&apos;)</code>,
то node будет искать в следующей последовательности:

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>Это позволяет программам локализовывать их зависимости, чтобы они не конфликтовали.

</p>
<h3>Папки как модули<span><a class="mark" href="#all_8" id="all_8">#</a></span></h3>
<p>Довольно удобно организовывать программы в виде вложеннных папок, предоставляя
единственную точку входа для библиотеки. Есть три способа, которыми папки могут
быть переданы в качестве аргумента <code>require()</code>.

</p>
<p>Первым является создание в папке файла <code>package.json</code>, который определяет
<code>главный</code> модуль. Например, package.json может быть таким:

</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>Если он находится в папке <code>./some-library</code>, то <code>require(&apos;./some-library&apos;)</code> будет
пытаться загрузить файл <code>./some-library/lib/some-library.js</code>.

</p>
<p>Этим ограничивается осведомлённость node о файлах package.json.

</p>
<p>Если файла package.json в папке нет, то node будет пытаться загрузить <code>index.js</code>
или <code>index.node</code> в этой папке. При этом <code>require(&apos;./some-library&apos;)</code> попробует
загрузить:

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h3>Кеширование<span><a class="mark" href="#all_9" id="all_9">#</a></span></h3>
<p>Модули кешируются при первой загрузке. Это, кроме остального, означает, что
каждый вызов <code>require(&apos;foo&apos;)</code> возвращает точно тотже объект, если модуль
разрешается в тоже самое имя файла.

</p>
<p>Множественные вызовы <code>require(&apos;foo&apos;)</code> не вызывают повторной компиляции кода.
Это очень важно. С помощью этого можно возвращать &quot;частично готовые&quot; объекты, позволяя транзитивным зависимостям загружаться даже если в нормальной ситуации это вызовет цикл зависимостей. 

</p>
<p>Если вы хотите выполнять код модуля несколько раз, то вам следует
экспортировать из него функцию и исполнять её в вашем коде.

</p>
<h4>Будьте осторожны с кешированием модулей<span><a class="mark" href="#all_10" id="all_10">#</a></span></h4>
<p>Модули кешируются в зависимости от имён файлов, в которые они разрешаются.
Так как один и тот же модуль может разрешаться в разные файлы
в зависимости от того, из какого модуля он вызывается (например
при загрузке из папки <code>node_modules</code>), ничто <em>не гарантирует</em>, что
<code>require(&apos;foo&apos;)</code> всегда будет возвращать один и тот же объект.

</p>
<h3>module.exports<span><a class="mark" href="#all_module_exports" id="all_module_exports">#</a></span></h3>
<p>Объект <code>exports</code> создаётся системой модулей. Это не всегда удобно, когда вам хочется,
чтобы модуль был экземпляром какого-то класса. Для того, чтобы сделать это,
вам нужно присвоить экспортируемый объект переменной <code>module.exports</code>.
Например, вы можете создать модуль <code>a.js</code>:

</p>
<pre><code>var EventEmitter = require(&apos;events&apos;).EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the &apos;ready&apos; event from the module itself.
setTimeout(function() {
  module.exports.emit(&apos;ready&apos;);
}, 1000);</code></pre>
<p>Тогда в другом модуле вы можете использовать его следующим образом:

</p>
<pre><code>var a = require(&apos;./a&apos;);
a.on(&apos;ready&apos;, function() {
  console.log(&apos;module a is ready&apos;);
});</code></pre>
<p>Нужно иметь в виду, что присваивание <code>module.exports</code> должно происходить
в основном коде модуля, а не в каких-либо коллбеках. Следующий код работать не будет:

</p>
<p>x.js:

</p>
<pre><code>setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);</code></pre>
<p>y.js:

</p>
<pre><code>var x = require(&apos;./x&apos;);
console.log(x.a);</code></pre>
<h3>Собирая всё вместе...<span><a class="mark" href="#all_11" id="all_11">#</a></span></h3>
<p>Для того, чтобы определить, какой модуль был загружен при вызове <code>require()</code>,
можно воспользоваться функцией <code>require.resolve()</code>.

</p>
<p>Учитывая всё вышесказанное, можно составить следующий высокоуровневый псевдокод
для <code>require()</code>:

</p>
<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with `./` or `/` or &apos;../&apos;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for &quot;main&quot; field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. LOAD_AS_FILE(X/index)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS</code></pre>
<h3>Загрузка из папок <code>require.paths</code><span><a class="mark" href="#all_require_paths_1" id="all_require_paths_1">#</a></span></h3>
<p>В node также есть массив <code>require.paths</code> строк, представляющих папки, где также
будет производится поиск модулей, идентификаторы которых не начинаются на <code>&apos;/&apos;</code>,
<code>&apos;./&apos;</code> или <code>&apos;../&apos;</code>. Например, пусть <code>require.paths</code> содержит:

</p>
<pre><code>[ &apos;/home/micheil/.node_modules&apos;,
  &apos;/usr/local/lib/node_modules&apos; ]</code></pre>
<p>Тогда вызов <code>require(&apos;bar/baz.js&apos;)</code> будет проверять следующие файлы:

</p>
<ul>
<li>1: <code>&apos;/home/micheil/.node_modules/bar/baz.js&apos;</code></li>
<li>2: <code>&apos;/usr/local/lib/node_modules/bar/baz.js&apos;</code></li>
</ul>
<p>Массив <code>require.paths</code> может быть изменён во время выполнения программы.

</p>
<p>Изначально содержимое берётся из переменной окружения <code>NODE_PATH</code>, которая
содержит разделённые с помощью двоеточия пути. В предыдуще случае <code>NODE_PATH</code>
должна быть установлена таким образом:

</p>
<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>
<p>Загрузка из <code>require.paths</code> предпринимается только в том случае, если алгоритм
с использованием <code>node_modules</code>, описанный выше, не принёс успеха. Глобальные
модули имеют меньший приоритет, чем зависимости, включённые в текущий модуль.

</p>
<h4><strong>Примечание:</strong> Пожалуйста, избегайте использования <code>require.paths</code><span><a class="mark" href="#all_require_paths_2" id="all_require_paths_2">#</a></span></h4>
<p>Переменная <code>require.paths</code> будет поддерживаться только в стабильной ветке v0.4.
Она удалена в ветке v0.5 и не будет присутствовать в стабильной ветке v0.6.

</p>
<p>На данный момент это выглядит разумно и представляет простор для экспериментов.
Но на практике изменение <code>require.paths</code> часто является причиной проблем и головной боли.

</p>
<h5>Присвоение <code>require.paths</code> другой переменной ничего не изменяет.<span><a class="mark" href="#all_require_paths_3" id="all_require_paths_3">#</a></span></h5>
<p>Этот код делает не то, что ожидается:

</p>
<pre><code>require.paths = [ &apos;/usr/lib/node&apos; ];</code></pre>
<p>Всё, чего вы добьётесь, так это потеря ссылки на <em>реальный</em> массив <code>require.paths</code>.

</p>
<h5>Добавление относительных путей в <code>require.paths</code> чревато ... странностями<span><a class="mark" href="#all_require_paths_4" id="all_require_paths_4">#</a></span></h5>
<p>Если вы сделаете:

</p>
<pre><code>require.paths.push(&apos;./lib&apos;);</code></pre>
<p>то в массив будет добавлен не реальный путь, соответствующий <code>./lib</code>
в файловой системе. Напротив, в массив будет добавлена строка <code>&apos;./lib&apos;</code>.
Соответственно, если вы вызовете <code>require(&apos;y.js&apos;)</code> в модуле <code>/a/b/x.js</code>,
то будет подключен модуль <code>/a/b/lib/y.js</code>, а если вы вызовете <code>require(&apos;y.js&apos;)</code>
в модуле <code>/l/m/n/o/p.js</code>, то будет подключен модуль <code>/l/m/n/o/lib/y.js</code>.

</p>
<p>На практике некоторые используют это при включении зависимостей в модуль,
но это хрупкая техника.

</p>
<h5>Отсутствие изоляции<span><a class="mark" href="#all_12" id="all_12">#</a></span></h5>
<p>К сожалению, есть только один массив <code>require.paths</code>, используемый всеми модулями.

</p>
<p>В результате, если один модуль полагается на это поведение, оно может быть
изменено другими модулями, загруженными в этом процессе node. Как только приложение
становится большим, труднопредсказуемое поведение может стать большой проблемой.

</p>
<h3>Доступ к главному модулю.<span><a class="mark" href="#all_13" id="all_13">#</a></span></h3>
<p>Когда файл исполняется напрямую из Node, переменной <code>require.main</code>
устанавливается значение <code>module</code>. Таким образом можно определить
как вызван файл с помощью проверки

</p>
<pre><code>require.main === module</code></pre>
<p>Для файла <code>foo.js</code> это будет верно в случае вызова <code>node foo.js</code>
и не верно в случае вызова <code>require(&apos;./foo&apos;)</code>.

</p>
<p>Так как <code>module</code> предоставляет свойство <code>filename</code> (обычно равное <code>__filename</code>),
то точка входа приложения может быть определена с помощью <code>require.main.filename</code>.

</p>
<h2>Дополнение: Советы для пакетных менеджеров<span><a class="mark" href="#all_14" id="all_14">#</a></span></h2>
<p><em>Прим. пер.: Эффективные менеджеры могут не читать этот раздел.</em>

</p>
<p>Семантика работы <code>require()</code> была разработана так, чтобы поддерживать различные
структуры папок. Пакетные менеджеры, такие как <code>dpkg</code>, <code>rpm</code> и <code>npm</code>, скорее
всего позволят собирать пакеты из Node.js модулей без модификаций.

</p>
<p>Ниже мы приводим предлагаемую структуру каталогов, которая должна быть.

</p>
<p>Предположим, мы хотим иметь папку <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>,
содержащую определёную версию пакета.

</p>
<p>Пакет может зависеть от какого-то другого пакета. Соответственно, перед установкой
пакета <code>foo</code> вы должны установить пакет определёную версию пакета <code>bar</code>.  Пакет
<code>bar</code> может иметь свои зависимости, и ,возможно, эти зависимости будут формировать циклы.

</p>
<p>Так как node определяет <code>realpath</code> каждого загружаемого модуля (т.е. разрешает
символические ссылки), и потом ищет их зависимости в папках <code>node_modules</code>,
как описано выше, эту ситуацию легко решить с помощью следующей архитектуры:

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Содержимое модуля <code>foo</code> версии 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Содержимое модуля <code>bar</code>, от которого зависит <code>foo</code>.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Символическая ссылка на
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Символические ссылки на модули,
от которых зависит <code>bar</code>.</li>
</ul>
<p>Таким образом, даже если встретится цикл или другой конфликт зависимостей,
каждый модуль сможет получить ту пакета, от которой он зависит.

</p>
<p>Когда код из пакета  <code>foo</code> вызывает <code>require(&apos;bar&apos;)</code>, он получит версию,
связанную с <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Когда код из пакета <code>bar</code> вызывает <code>require(&apos;quux&apos;)</code>, он получит версию,
связанную с <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>Кроме того, чтобы сделать процесс поиска модулей более оптимальным, мы можем
поместить модули не в папку <code>/usr/lib/node</code>, а в <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.
Тогда node не будет пытаться искать отсутствующие зависимости в <code>/usr/node_modules</code>
и <code>/node_modules</code>.

</p>
<p>Чтобы сделать модули доступными и в REPL, может быть полезно добавить путь
<code>/usr/lib/node_modules</code> в переменную окружения <code>$NODE_PATH</code>. Так как поиск модулей
с помощью папок <code>node_modules</code> однован на реальных путях в файловой системе,
разрешаемых во время вызова <code>require()</code>, то пакеты могут располагаться где угодно.


</p>
<h1>C/C++ дополнения<span><a class="mark" href="#all_c_c" id="all_c_c">#</a></span></h1>
<p>Дополнения — это динамически подключаемые объекты. Они могут предоставлять
связь с библиотеками на языках C/C++. На данный момент API для дополнений
довольно сложное и использует следующие библиотеки:

</p>
<ul>
<li><p>Движок V8 JavaScript, написан на C++. Используется для обращения к JavaScript
из дополнения: создания объектов, вызова функций и т.д. Документация по нему
крайне скудна, в основном стоит полагаться на заголовочный файл <code>v8.h</code>
(<code>deps/v8/include/v8.h</code> в дистрибутиве Node), документация по которому
также доступна <a href="http://izs.me/v8-docs/main.html">онлайн</a>.</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, библиотека цикла событий, написанная на C.
Каждый раз, когда вам потребуется подождать пока файловый дескриптор станет
доступен для чтения, подождать вызова таймера или поступления сигнала,
вы будете испльзовать вызовы из libuv.</p>
</li>
<li><p>Внутренние библиотеки Node. Наиболее важная из них — класс <code>node::ObjectWrap</code>,
от которого будут наследоваться большинство ваших классов.</p>
</li>
<li><p>Остальные доступные библиотеки вы можете найти впапке <code>deps</code> дистрибутива Node.</p>
</li>
</ul>
<p>При сборке Node все её зависимости статически компилируются в исполняемый файл.
При сборке своего модуля вы не должны задумываться об описанных выше библиотеках.

</p>
<h2>Hello world<span><a class="mark" href="#all_hello_world" id="all_hello_world">#</a></span></h2>
<p>В качестве простого примера сделаем дополнение для Node на C++, которое будет
делать тоже самое, что и JavaScript код:

</p>
<pre><code>exports.hello = &apos;world&apos;;</code></pre>
<p>Для начала создадим файл <code>hello.cc</code>:

</p>
<pre><code>#include &lt;node.h&gt;
#include &lt;v8.h&gt;

using namespace v8;

Handle&lt;Value&gt; Method(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New(&quot;world&quot;));
}

void init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;hello&quot;),
      FunctionTemplate::New(Method)-&gt;GetFunction());
}
NODE_MODULE(hello, init)</code></pre>
<p>Каждое дополнение должно экспортировать функцию инициализации следующим образом:

</p>
<pre><code>void Initialize (Handle&lt;Object&gt; target);
NODE_MODULE(module_name, Initialize)</code></pre>
<p>После <code>NODE_MODULE</code> нет точки с запятой, так как это не функция, а макрос (см. <code>node.h</code>).

</p>
<p>Текст <code>module_name</code> должен совпадать с именем файла скопилированного бинарного дополнения
(баз суффикса .node).

</p>
<p>Этот код нужно собрать в файл <code>hello.node</code>, файл бинарного дополнения.
Для этого создадим файл <code>wscript</code>, содержащий код на Python (аналог Makefile):

</p>
<pre><code>srcdir = &apos;.&apos;
blddir = &apos;build&apos;
VERSION = &apos;0.0.1&apos;

def set_options(opt):
  opt.tool_options(&apos;compiler_cxx&apos;)

def configure(conf):
  conf.check_tool(&apos;compiler_cxx&apos;)
  conf.check_tool(&apos;node_addon&apos;)

def build(bld):
  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)
  obj.target = &apos;hello&apos;
  obj.source = &apos;hello.cc&apos;</code></pre>
<p>Теперь можно запустить команду <code>node-waf configure build</code>, которая создаст файл
<code>build/default/hello.node</code>, содержащий бинарную версию дополнения.

</p>
<p><code>node-waf</code> — расширение <a href="http://code.google.com/p/waf/">WAF</a>, системы сборки
на языке Python. <code>node-waf</code> включён в состав Node для упрощения процесса
сборки дополнений.

</p>
<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing <code>require</code> to
the recently built module:

</p>
<pre><code>var addon = require(&apos;./build/Release/hello&apos;);

console.log(addon.hello()); // &apos;world&apos;</code></pre>
<p>Некоторые шаблоны кода, необходимые для написания расширений, приведены ниже.
В качестве примера вы можете просмотреть код <a href="https://github.com/pietern/hiredis-node">https://github.com/pietern/hiredis-node</a>.


</p>
<h2>Фрагменты кода дополнений<span><a class="mark" href="#all_15" id="all_15">#</a></span></h2>
<p>Ниже приведены некоторые фрагменты кода дополнений, которые часто используются
и помогут вам начать писать свои бинарные дополнения для Node.js. Для более подробной информации по бибилиотеке v8
вы можете воспользоваться <a href="http://izs.me/v8-docs/main.html">справкой</a>,
а также <a href="http://code.google.com/apis/v8/embed.html">v8 Embedder&apos;s Guide</a>, в котором описаны некоторые концепции библиотеки,
такие handle, замыкание, шаблон функции и т.д.

</p>
<p>Чтобы скомпилировать приведённые примеры, создаёте простой <code>wscript</code> и выполните в консоли команду
<code>node-waf configure build</code>:

</p>
<pre><code>srcdir = &apos;.&apos;
blddir = &apos;build&apos;
VERSION = &apos;0.0.1&apos;

def set_options(opt):
  opt.tool_options(&apos;compiler_cxx&apos;)

def configure(conf):
  conf.check_tool(&apos;compiler_cxx&apos;)
  conf.check_tool(&apos;node_addon&apos;)

def build(bld):
  obj = bld.new_task_gen(&apos;cxx&apos;, &apos;shlib&apos;, &apos;node_addon&apos;)
  obj.target = &apos;addon&apos;
  obj.source = [&apos;addon.cc&apos;]</code></pre>
<p>Если дополнение требует более одного файла <code>.cc</code>, просто добавьте его в массив <code>obj.source</code>:

</p>
<pre><code>obj.source = [&apos;addon.cc&apos;, &apos;myexample.cc&apos;]</code></pre>
<h3>Передача аргументов в функции<span><a class="mark" href="#all_16" id="all_16">#</a></span></h3>
<p>Этот пример показывает, как прочитать переданные из JavaScript аргументы функции и вернуть результат выполнения.
Для этого потребует только один исходный файл <code>addon.cc</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  if (args.Length() &lt; 2) {
    ThrowException(Exception::TypeError(String::New(&quot;Wrong number of arguments&quot;)));
    return scope.Close(Undefined());
  }

  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {
    ThrowException(Exception::TypeError(String::New(&quot;Wrong arguments&quot;)));
    return scope.Close(Undefined());
  }

  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +
      args[1]-&gt;NumberValue());
  return scope.Close(num);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;add&quot;),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>Вы можете проверить работоспособность дополнения с помощью следующего JavaScript кода:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

console.log( &apos;This should be eight:&apos;, addon.add(3,5) );</code></pre>
<h3>Функции обратного вызова<span><a class="mark" href="#all_17" id="all_17">#</a></span></h3>
<p>Вы можете передать JavaScript функции в дополнение для вызова её оттуда.
Пример <code>addon.cc</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; RunCallback(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);
  const unsigned argc = 1;
  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };
  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);

  return scope.Close(Undefined());
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;runCallback&quot;),
      FunctionTemplate::New(RunCallback)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>Проверяем работоспособность дополнения:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

addon.runCallback(function(msg){
  console.log(msg); // &apos;hello world&apos;
});</code></pre>
<h3>Фабрика объектов<span><a class="mark" href="#all_18" id="all_18">#</a></span></h3>
<p>В этом примере мы создадим функцию <code>createObject()</code>, которая будект возвращать объект со свойством <code>msg</code>,
содержащим переданный в функцию текст:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Object&gt; obj = Object::New();
  obj-&gt;Set(String::NewSymbol(&quot;msg&quot;), args[0]-&gt;ToString());

  return scope.Close(obj);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>Проверяем работоспособность дополнения:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj1 = addon.createObject(&apos;hello&apos;);
var obj2 = addon.createObject(&apos;world&apos;);
console.log(obj1.msg+&apos; &apos;+obj2.msg); // &apos;hello world&apos;</code></pre>
<h3>Фабрика функций<span><a class="mark" href="#all_19" id="all_19">#</a></span></h3>
<p>Этот пример показывает, как создать и вернуть из C++ кода Javascript функцию, связанную с другой C++ функцией:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; MyFunction(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New(&quot;hello world&quot;));
}

Handle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);
  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();
  fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // omit this to make it anonymous

  return scope.Close(fn);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol(&quot;createFunction&quot;),
      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>Для проверки выполняем:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var fn = addon.createFunction();
console.log(fn()); // &apos;hello world&apos;</code></pre>
<h3>Обертка C++ объектов<span><a class="mark" href="#all_c" id="all_c">#</a></span></h3>
<p>Вы также можете создавать Javascript обёртки для C++ объектов/классов. В данном случае <code>MyObject</code> может быть
инстанцирован в JavaScript с помощью оператора <code>new</code>. Для начала напишем основной файл дополнения, <code>addon.cc</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init(target);
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>В файле <code>myobject.h</code> унаследуем нашу обёртку от <code>node::ObjectWrap</code>:

</p>
<pre><code>#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init(v8::Handle&lt;v8::Object&gt; target);

 private:
  MyObject();
  ~MyObject();

  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>
<p>А в файл <code>myobject.cc</code> поместим реализацию некоторых методов класса, которые мы хотим сделать видимыми в Javascrip.
Для этого мы должны добавить метод <code>plusOne</code> в прототип конструктора объекта:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

void MyObject::Init(Handle&lt;Object&gt; target) {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  Persistent&lt;Function&gt; constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
  target-&gt;Set(String::NewSymbol(&quot;MyObject&quot;), constructor);
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Для проверки выполняем:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>
<h3>Фабрика обёрток объектов<span><a class="mark" href="#all_20" id="all_20">#</a></span></h3>
<p>Бывает полезным создание объектов без использования оператора <code>new</code> в JavaScript, например.

</p>
<pre><code>var obj = addon.createObject();
// instead of:
// var obj = new addon.Object();</code></pre>
<p>Для этого создадим метод <code>createObject</code> в <code>addon.cc</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>Теперь нам необходимо объявить в <code>myobject.h</code> статический метод <code>NewInstance</code>, который будет инстанцировать объект
(т.е. выполнять функцию <code>new</code> в JavaScript):

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);
  double counter_;
};

#endif</code></pre>
<p>Реализация <code>myobject.cc</code> похожа на описанную выше:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototype
  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),
      FunctionTemplate::New(PlusOne)-&gt;GetFunction());

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}

Handle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());
  obj-&gt;counter_ += 1;

  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Для проверки выполняем:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj = addon.createObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13

var obj2 = addon.createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>
<h3>Использование обёрнутых объектов в C++ коде<span><a class="mark" href="#all_c_1" id="all_c_1">#</a></span></h3>
<p>Кроме того, что C++ объекты можно обёртывать и возвращать в Javascript код, их также можно передавать обратно,
разворачивать и использовать в C++ коде как обычные C++ объекты. Для этого используется функция <code>node::ObjectWrap::Unwrap</code>.
Добавим в <code>addon.cc</code> функцию <code>add()</code>, которая принимает два объекта класса <code>MyObject</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MyObject::NewInstance(args));
}

Handle&lt;Value&gt; Add(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[0]-&gt;ToObject());
  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[1]-&gt;ToObject());

  double sum = obj1-&gt;Val() + obj2-&gt;Val();
  return scope.Close(Number::New(sum));
}

void InitAll(Handle&lt;Object&gt; target) {
  MyObject::Init();

  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());

  target-&gt;Set(String::NewSymbol(&quot;add&quot;),
      FunctionTemplate::New(Add)-&gt;GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>Для получения значения приватной переменной <code>val_</code> напишем дополнительную функцию прямо в <code>myobject.h</code>:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);
  double Val() const { return val_; }

 private:
  MyObject();
  ~MyObject();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  double val_;
};

#endif</code></pre>
<p>Реализация <code>myobject.cc</code> не изменилась:

</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function&gt; MyObject::constructor;

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);
  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());
}

Handle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj-&gt;val_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  obj-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}</code></pre>
<p>Для проверки выполняем:

</p>
<pre><code>var addon = require(&apos;./build/Release/addon&apos;);

var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30</code></pre>
<h2>Процесс<span><a class="mark" href="#all_21" id="all_21">#</a></span></h2>
<p>Объект <code>process</code> — глобальный и может быть использован в любом месте кода.
Является экземпляром <code>EventEmitter</code>.


</p>
<h3>Событие: &apos;exit&apos;<span><a class="mark" href="#all_exit" id="all_exit">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p>Генерируется перед тем как процесс завершится. Это хорошее место для проверок
состояния модуля (например, юнит-тестов). Event loop не будет действовать
после завершения обработчика <code>&apos;exit&apos;</code>, так что таймеры использовать нельзя.

</p>
<p>Пример обработки события <code>&apos;exit&apos;</code>:

</p>
<pre><code>process.on(&apos;exit&apos;, function () {
  process.nextTick(function () {
   console.log(&apos;This will not run&apos;);
  });
  console.log(&apos;About to exit.&apos;);
});</code></pre>
<h3>Событие: &apos;uncaughtException&apos;<span><a class="mark" href="#all_uncaughtexception" id="all_uncaughtexception">#</a></span></h3>
<p><code>function (err) { }</code>

</p>
<p>Генерируется, когда неперехваченное исключение достигает цикла обработки событий.
Если этому событию назначен обработчик,
стандартное действие (печать стека и выход) производиться не будет.

</p>
<p>Пример обработки события <code>&apos;uncaughtException&apos;</code>:

</p>
<pre><code>process.on(&apos;uncaughtException&apos;, function (err) {
  console.log(&apos;Caught exception: &apos; + err);
});

setTimeout(function () {
  console.log(&apos;This will still run.&apos;);
}, 500);

// Intentionally cause an exception, but don&apos;t catch it.
nonexistentFunc();
console.log(&apos;This will not run.&apos;);</code></pre>
<p>Заметьте, что событие <code>&apos;uncaughtException&apos;</code> — это очень грубый механизм для управления исключениями.
Использование try/catch даст вам больший контроль над выполнением вашего кода.
Но для программ, предназначенных для постоянной работы,
<code>&apos;uncaughtException&apos;</code> может быть очень полезным механизмом безопасности.


</p>
<h3>Сигнальные события<span><a class="mark" href="#all_22" id="all_22">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p>Генерируются когда процесс получает сигнал.
См. sigaction(2) для списка стандартных имён сигналов в POSIX,
таких как <code>SIGINT</code>, <code>SIGUSR1</code> и т.д.

</p>
<p>Пример обработки сигнала <code>SIGINT</code>:

</p>
<pre><code>// Start reading from stdin so we don&apos;t exit.
process.stdin.resume();

process.on(&apos;SIGINT&apos;, function () {
  console.log(&apos;Got SIGINT.  Press Control-D to exit.&apos;);
});</code></pre>
<p>Простой способ отправки сигнала <code>SIGINT</code>: <code>Control-C</code> в большинстве терминальных программ.


</p>
<h3>process.stdout<span><a class="mark" href="#all_process_stdout" id="all_process_stdout">#</a></span></h3>
<p>Поток с возможностью записи, представляющий стандартный поток вывода <code>stdout</code>.

</p>
<p>Пример (определение <code>console.log</code>):

</p>
<pre><code>console.log = function (d) {
  process.stdout.write(d + &apos;\n&apos;);
};</code></pre>
<h3>process.stderr<span><a class="mark" href="#all_process_stderr" id="all_process_stderr">#</a></span></h3>
<p>Поток с возможностью записи, представляющий стандартный поток ошибок <code>stderr</code>.
Запись в этот поток всегда является блокирующей.


</p>
<h3>process.stdin<span><a class="mark" href="#all_process_stdin" id="all_process_stdin">#</a></span></h3>
<p>Стандартный поток ввода stdin. Этот поток по умолчанию не реагирует на события,
для чтения из него нужно предварительно вызвать <code>process.stdin.resume()</code>.

</p>
<p>Пример открытия стандартного потока ввода и обработки обоих событий:

</p>
<pre><code>process.stdin.resume();
process.stdin.setEncoding(&apos;utf8&apos;);

process.stdin.on(&apos;data&apos;, function (chunk) {
  process.stdout.write(&apos;data: &apos; + chunk);
});

process.stdin.on(&apos;end&apos;, function () {
  process.stdout.write(&apos;end&apos;);
});</code></pre>
<h3>process.argv<span><a class="mark" href="#all_process_argv" id="all_process_argv">#</a></span></h3>
<p>Массив, содержащий аргументы командной строки.
Первым элементом будет &apos;node&apos;, вторым — имя JavaScript файла.
Следующие элементы будут дополнительными аргументами скрипта.

</p>
<pre><code>// print process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + &apos;: &apos; + val);
});</code></pre>
<p>В результате получим:

</p>
<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>
<h3>process.execPath<span><a class="mark" href="#all_process_execpath" id="all_process_execpath">#</a></span></h3>
<p>Абсолютный путь к приложению, запустившему процесс.

</p>
<p>Пример:

</p>
<pre><code>/usr/local/bin/node</code></pre>
<h3>process.chdir(directory)<span><a class="mark" href="#all_process_chdir_directory" id="all_process_chdir_directory">#</a></span></h3>
<p>Изменяет текущий рабочий каталог приложения либо генерирует исключение,
если изменить каталог не удаётся.

</p>
<pre><code>console.log(&apos;Starting directory: &apos; + process.cwd());
try {
  process.chdir(&apos;/tmp&apos;);
  console.log(&apos;New directory: &apos; + process.cwd());
}
catch (err) {
  console.log(&apos;chdir: &apos; + err);
}</code></pre>
<h3>process.cwd()<span><a class="mark" href="#all_process_cwd" id="all_process_cwd">#</a></span></h3>
<p>Возвращает текущую рабочую директорию процесса.

</p>
<pre><code>console.log(&apos;Current directory: &apos; + process.cwd());</code></pre>
<h3>process.env<span><a class="mark" href="#all_process_env" id="all_process_env">#</a></span></h3>
<p>Объект, хранящий окружение пользователя. См. environ(7).


</p>
<h3>process.exit(code=0)<span><a class="mark" href="#all_process_exit_code_0" id="all_process_exit_code_0">#</a></span></h3>
<p>Завершает процесс с указанным кодом <code>code</code>.
Если код пропущен, завершает процесс со стандартным успешным кодом <code>0</code>.

</p>
<p>Чтобы выйти с ощибочным кодом, нужно вызвать:

</p>
<pre><code>process.exit(1);</code></pre>
<p>Оболочка, с помощью которой был запущен скрипт в node, должна получить код <code>1</code>.


</p>
<h3>process.getgid()<span><a class="mark" href="#all_process_getgid" id="all_process_getgid">#</a></span></h3>
<p>Возвращает групповой индикатор процесса (см. setgid(2)). Это числовое значение id группы, а не её имя.

</p>
<pre><code>console.log(&apos;Current gid: &apos; + process.getgid());</code></pre>
<h3>process.setgid(id)<span><a class="mark" href="#all_process_setgid_id" id="all_process_setgid_id">#</a></span></h3>
<p>Устанавливает групповой индикатор процесса (см. setgid(2)).
Функция принимает как числовое значение, так и его текстовый эквивалент.
Если функции передано имя группы, то функция блокирует выполнение кода
пока не разрешит имя в числовой идентификатор.

</p>
<pre><code>console.log(&apos;Current gid: &apos; + process.getgid());
try {
  process.setgid(501);
  console.log(&apos;New gid: &apos; + process.getgid());
}
catch (err) {
  console.log(&apos;Failed to set gid: &apos; + err);
}</code></pre>
<h3>process.getuid()<span><a class="mark" href="#all_process_getuid" id="all_process_getuid">#</a></span></h3>
<p>Возвращает индикатор пользователя-владельца процесса (см. setuid(2)). Это числовой идентификатор, а не имя пользователя.

</p>
<pre><code>console.log(&apos;Current uid: &apos; + process.getuid());</code></pre>
<h3>process.setuid(id)<span><a class="mark" href="#all_process_setuid_id" id="all_process_setuid_id">#</a></span></h3>
<p>Устанавливает индикатор пользователя-владельца процесса (см. setuid(2)).
Функция принимает как числовое значение, так и его текстовый эквивалент.
Если функции передано имя пользователя, то функция блокирует выполнение кода
пока не разрешит имя в числовой идентификатор.

</p>
<pre><code>console.log(&apos;Current uid: &apos; + process.getuid());
try {
  process.setuid(501);
  console.log(&apos;New uid: &apos; + process.getuid());
}
catch (err) {
  console.log(&apos;Failed to set uid: &apos; + err);
}</code></pre>
<h3>process.version<span><a class="mark" href="#all_process_version" id="all_process_version">#</a></span></h3>
<p>Заданное при компиляции свойство, возвращающее версию Node (<code>NODE_VERSION</code>).

</p>
<pre><code>console.log(&apos;Version: &apos; + process.version);</code></pre>
<h3>process.installPrefix<span><a class="mark" href="#all_process_installprefix" id="all_process_installprefix">#</a></span></h3>
<p>Заданное при компиляции свойство, хранящее директорию,
в которую устанавливали Node (<code>NODE_PREFIX</code>).

</p>
<pre><code>console.log(&apos;Prefix: &apos; + process.installPrefix);</code></pre>
<h3>process.kill(pid, signal=&apos;SIGTERM&apos;)<span><a class="mark" href="#all_process_kill_pid_signal_sigterm" id="all_process_kill_pid_signal_sigterm">#</a></span></h3>
<p>Отправляет сигнал процессу. <code>pid</code> это идентификатор процесса, <code>signal</code> — строка,
обозначающая отправляемый сигнал. Имена сигналов это строки вроде <code>&apos;SIGINT&apos;</code> или <code>&apos;SIGUSR1&apos;</code>.
Если имя сигнала пропущено, отправлен будет сигнал <code>&apos;SIGTERM&apos;</code>.
См. kill(2) для более подробной информации.

</p>
<p>Заметьте, что хотя функция и называется <code>process.kill</code>,
на самом деле она просто отправляет сигнал, как и системная команда <code>kill</code>.
Отправляемый сигнал может не только завершать целевой процесс.

</p>
<p>Пример процесса, отправляющего сигнал самому себе:

</p>
<pre><code>process.on(&apos;SIGHUP&apos;, function () {
  console.log(&apos;Got SIGHUP signal.&apos;);
});

setTimeout(function () {
  console.log(&apos;Exiting.&apos;);
  process.exit(0);
}, 100);

process.kill(process.pid, &apos;SIGHUP&apos;);</code></pre>
<h3>process.pid<span><a class="mark" href="#all_process_pid" id="all_process_pid">#</a></span></h3>
<p>Идентификатор процесса (PID).

</p>
<pre><code>console.log(&apos;This process is pid &apos; + process.pid);</code></pre>
<h3>process.title<span><a class="mark" href="#all_process_title" id="all_process_title">#</a></span></h3>
<p>свойство для определение/задания заголовка, отобращаемого в списке процессов.


</p>
<h3>process.platform<span><a class="mark" href="#all_process_platform" id="all_process_platform">#</a></span></h3>
<p>Платформа, на которой выполняется node. <code>&apos;linux2&apos;</code>, <code>&apos;darwin&apos;</code> и т.д.

</p>
<pre><code>console.log(&apos;This platform is &apos; + process.platform);</code></pre>
<h3>process.memoryUsage()<span><a class="mark" href="#all_process_memoryusage" id="all_process_memoryusage">#</a></span></h3>
<p>Возвращает объект, описывающий потребление памяти процессом Node, измеренное в байтах.

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(process.memoryUsage()));</code></pre>
<p>В результате получим:

</p>
<pre><code>{ rss: 4935680,
  vsize: 41893888,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>
<p><code>heapTotal</code> и <code>heapUsed</code>     относятся к потреблению памяти движком V8.


</p>
<h3>process.nextTick(callback)<span><a class="mark" href="#all_process_nexttick_callback" id="all_process_nexttick_callback">#</a></span></h3>
<p>На следующей итерации цикла обработки событий запустить указанный обработчик.
Это <em>не</em> простой alias для <code>setTimeout(fn, 0)</code>, это намного более эффективный метод.

</p>
<pre><code>process.nextTick(function () {
  console.log(&apos;nextTick callback&apos;);
});</code></pre>
<h3>process.umask([mask])<span><a class="mark" href="#all_process_umask_mask" id="all_process_umask_mask">#</a></span></h3>
<p>Задаёт и возвращает маску создания файлов процессом.
Дочерние процессы наследуют эту маску от процесса-родителя.
Если задан аргумент mask возвращает старую маску, иначе — возвращает текущую.

</p>
<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log(&apos;Changed umask from: &apos; + oldmask.toString(8) +
            &apos; to &apos; + newmask.toString(8));</code></pre>
<h1>Утилиты<span><a class="mark" href="#all_23" id="all_23">#</a></span></h1>
<p>Используйте <code>require(&apos;util&apos;)</code> для доступа к этим функциям.


</p>
<h2>util.format()<span><a class="mark" href="#all_util_format" id="all_util_format">#</a></span></h2>
<p>Возвращает составную строку, используя первый параметр в качестве строки формата в стиле <code>printf</code>.

</p>
<p>Первый аргумент является строкой, которая может содержать нуль
или несколько <em>заменителей</em>. Каждый заменитель будет заменён
на отформатированное значение в зависимости от типа аргумента.
Поддерживаемые заменители:

</p>
<ul>
<li><code>%s</code> - String.</li>
<li><code>%d</code> - Number (both integer and float).</li>
<li><code>%j</code> - JSON.</li>
<li><code>%%</code> - single percent sign (<code>&apos;%&apos;</code>). This does not consume an argument.</li>
</ul>
<p>Если для заменителя не задан соответствующий аргумент, он не будет заменён.

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;</code></pre>
<p>Если аргументов больше, чем заменителей в строке, оставшиеся аргументы
будут преобразованы в строки с помощью <code>util.inspect()</code> и склеены
с использованием пробела:

</p>
<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;</code></pre>
<p>Если первый аргумент не является строкой, то <code>util.format()</code> вернёт преобразованные в строки аргументы,
склееные с использованием пробела. Преобразование будет осуществляться функцией <code>util.inspect()</code>.

</p>
<pre><code>util.format(1, 2, 3); // &apos;1 2 3&apos;</code></pre>
<h2>util.debug(string)<span><a class="mark" href="#all_util_debug_string" id="all_util_debug_string">#</a></span></h2>
<p>Синхронный вывод. Заблокирует процесс и выведет строку <code>string</code>
в поток <code>stderr</code> немедленно.

</p>
<pre><code>require(&apos;util&apos;).debug(&apos;message on stderr&apos;);</code></pre>
<h2>util.log(string)<span><a class="mark" href="#all_util_log_string" id="all_util_log_string">#</a></span></h2>
<p>Выводит строку с меткой времени в <code>stdout</code>.

</p>
<pre><code>require(&apos;util&apos;).log(&apos;Timestmaped message.&apos;);</code></pre>
<h2>util.inspect(object, [showHidden], [depth], [colors])<span><a class="mark" href="#all_util_inspect_object_showhidden_depth_colors" id="all_util_inspect_object_showhidden_depth_colors">#</a></span></h2>
<p>Возвращает объект <code>object</code> в виде строки, очень удобно для отладки.

</p>
<p>Если <code>showHidden</code> имеет значение true, неперечисляемые свойства тоже будут показаны.
По умолчанию <code>false</code>.

</p>
<p>Параметр <code>depth</code> он сообщает <code>inspect</code> на какую глубину просмотреть объект,
прежде чем выдавать результат. Это полезно для больших сложных объектов.

</p>
<p>По умолчанию принята глубина просмотра 2. Чтобы просмотреть объект
на неограниченную глубину, передайте <code>null</code> в качестве значения <code>depth</code>.

</p>
<p>Если параметр <code>colors</code> равен <code>true</code>, то вывод функции будет расцвечен с использованием кодов цветов ANSI.
По умолчанию <code>false</code>.

</p>
<p>Пример просмотра всех свойств объекта <code>util</code>:

</p>
<pre><code>var util = require(&apos;util&apos;);

console.log(util.inspect(util, true, null));</code></pre>
<h2>util.isArray(object)<span><a class="mark" href="#all_util_isarray_object" id="all_util_isarray_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Array</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false</code></pre>
<h2>util.isRegExp(object)<span><a class="mark" href="#all_util_isregexp_object" id="all_util_isregexp_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>RegExp</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp(&apos;another regexp&apos;))
  // true
util.isRegExp({})
  // false</code></pre>
<h2>util.isDate(object)<span><a class="mark" href="#all_util_isdate_object" id="all_util_isdate_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Date</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without &apos;new&apos; returns a String)
util.isDate({})
  // false</code></pre>
<h2>util.isError(object)<span><a class="mark" href="#all_util_iserror_object" id="all_util_iserror_object">#</a></span></h2>
<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Error</code>. <code>false</code> otherwise.

</p>
<pre><code>var util = require(&apos;util&apos;);

util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })
  // false</code></pre>
<h2>util.pump(readableStream, writableStream, [callback])<span><a class="mark" href="#all_util_pump_readablestream_writablestream_callback" id="all_util_pump_readablestream_writablestream_callback">#</a></span></h2>
<p>Экспериментальный метод.

</p>
<p>Читает данные из потока <code>readableStream</code> и посылает потоку <code>writableStream</code>.
Когда <code>writableStream.write(data)</code> возвращает <code>false</code> <code>readableStream</code>
приостанавливается пока не произойдёт событие <code>drain</code> во <code>writableStream</code>.
<code>callback</code> вызывается после закрытия <code>writableStream</code>. <code>callback</code> принимает
ошибку в случае если <code>writableStream</code> был закрыт или возникла ошибка.


</p>
<h2>util.inherits(constructor, superConstructor)<span><a class="mark" href="#all_util_inherits_constructor_superconstructor" id="all_util_inherits_constructor_superconstructor">#</a></span></h2>
<p>Расширяет <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">конструктор</a>
прототипа методами из другого прототипа. Прототип <code>constructor</code> будет новым объектом, созданным с помощью <code>superConstructor</code>.

</p>
<p>Также <code>superConstructor</code> будет доступен через свойство <code>constructor.super_</code>.

</p>
<pre><code>var util = require(&quot;util&quot;);
var events = require(&quot;events&quot;);

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit(&quot;data&quot;, data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on(&quot;data&quot;, function(data) {
    console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);
})
stream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>
<h2>Cобытия<span><a class="mark" href="#all_c_2" id="all_c_2">#</a></span></h2>
<p>Множество объектов в Node генерируют события: <code>net.Server</code> вызывает событие
при каждом поступающем запросе, <code>fs.readStream</code> вызывает событие при открытии файла.
Все объекты, генерирующие события, являются экземплярами <code>events.EventEmitter</code>.
Используйте <code>require(&apos;events&apos;)</code> чтобы получить доступ к модулю.

</p>
<p>Обычно события представлены строками в стиле camelCase. Вот несколько примеров:
<code>&apos;stream&apos;</code>, <code>&apos;data&apos;</code>, <code>&apos;messageBegin&apos;</code>. Однако, это только пожелание и никаких
жёстких ограничений на имена событий не накладывается.

</p>
<p>К объектам могут быть присоединены функции, которые будут выполняться
при генерации события. Эти функции называются <em>обработчиками</em> (<em>listeners</em>).


</p>
<h3>events.EventEmitter<span><a class="mark" href="#all_events_eventemitter" id="all_events_eventemitter">#</a></span></h3>
<p>Класс <code>EventEmitter</code> находится в модуле <code>&apos;events&apos;</code>: <code>require(events&apos;).EventEmitter</code>.

</p>
<p>Когда источник событий сталкивается с ошибкой, типичное поведение — сгенерировать
событие ошибки <code>&apos;error&apos;</code>. События ошибки особенные — если им не назначен
обработчик, то они выводят на экран стек вызовов (stack trace) и завершают программу.

</p>
<p>Все источники событий генерируют событие <code>&apos;newListener&apos;</code>,
когда к ним добавляются новые обработчики.

</p>
<h4>emitter.addListener(event, listener)<span><a class="mark" href="#all_emitter_addlistener_event_listener" id="all_emitter_addlistener_event_listener">#</a></span></h4>
<h4>emitter.on(event, listener)<span><a class="mark" href="#all_emitter_on_event_listener" id="all_emitter_on_event_listener">#</a></span></h4>
<p>Добавляет обработчик в конец массива обработчиков указанного события.

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});</code></pre>
<h4>emitter.once(event, listener)<span><a class="mark" href="#all_emitter_once_event_listener" id="all_emitter_once_event_listener">#</a></span></h4>
<p>Добавляет <strong>однократный</strong> обработчик указанного события. Обработчик вызываетя
один раз при первом наступлении события, после чего удаляется.

</p>
<pre><code>server.once(&apos;connection&apos;, function (stream) {
  console.log(&apos;Ah, we have our first user!&apos;);
});</code></pre>
<h4>emitter.removeListener(event, listener)<span><a class="mark" href="#all_emitter_removelistener_event_listener" id="all_emitter_removelistener_event_listener">#</a></span></h4>
<p>Удаляет обработчик из массива обработчиков указанного события.
<strong>Внимание:</strong> изменяет индексы в массиве обработчиков после указанного обработчика.

</p>
<pre><code>var callback = function(stream) {
  console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);</code></pre>
<h4>emitter.removeAllListeners(event)<span><a class="mark" href="#all_emitter_removealllisteners_event" id="all_emitter_removealllisteners_event">#</a></span></h4>
<p>Удаляет все обработчики из массива обработчиков для указанного события.


</p>
<h4>emitter.setMaxListeners(n)<span><a class="mark" href="#all_emitter_setmaxlisteners_n" id="all_emitter_setmaxlisteners_n">#</a></span></h4>
<p>По умолчаню <code>EventEmitter</code> выводит предупреждение, если к нему подключено
больше 10-ти обработчиков. Это полезно для поиска утечек памяти.
Но не всегда такое ограничение полезно и возможно. Эта функция позволяет изменить
пороговое значение. Если функции передать значение <code>0</code>,
то предупреждение не будет выводиться при любом числе обработчиков.


</p>
<h4>emitter.listeners(event)<span><a class="mark" href="#all_emitter_listeners_event" id="all_emitter_listeners_event">#</a></span></h4>
<p>Возвращает массив обработчиков для указанного события. Этот массив может быть
использован, например, для удаления обработчиков.

</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});
console.log(util.inspect(server.listeners(&apos;connection&apos;)); // [ [Function] ]</code></pre>
<h4>emitter.emit(event, [arg1], [arg2], [...])<span><a class="mark" href="#all_emitter_emit_event_arg1_arg2" id="all_emitter_emit_event_arg1_arg2">#</a></span></h4>
<p>Выполнит все обработчики события по порядку с указанными аргументами.

</p>
<h4>Событие: &apos;newListener&apos;<span><a class="mark" href="#all_newlistener" id="all_newlistener">#</a></span></h4>
<p><code>function (event, listener) { }</code>

</p>
<p>Это событие вызывается каждый раз при добавлении обработчика события.


</p>
<h1>Буфер<span><a class="mark" href="#all_24" id="all_24">#</a></span></h1>
<pre><code>Стабильность: 3 - Стабильно</code></pre>
<p>Чистый JavaScript поддерживает Unicode, но в нём нет средств для работы
с двоичными данными. При работе с TCP или файловой системой часто необходимо
работать именно с потоками двоичных данных. В Node предусмотрено несколько
средств управления, создания и приёма двоичных потоков.

</p>
<p>Бинарные данные хранятся в экземплярах класса Buffer. Buffer похож на массив
целых чисел, но ему соответствует область памяти, выделенная вне стандартной
кучи V8. Размер Buffer невозможно изменить после создания. 

</p>
<p>Объект <code>Buffer</code> существует в глобальном пространстве имён,
но при необходимости его можно получить с помощью <code>require(&apos;buffer&apos;)</code>.

</p>
<p>При преобразовании между буферами и строками JavaScript требуется явно
указывать метод кодирования символов. Node поддерживает 3 кодировки для строк:

</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> — только для 7-битных ASCII-строк. Этот метод кодирования очень
быстрый, и будет сбрасывать старший бит символа, если тот установлен.
Нужно помнить, что при использовании этой кодировки нулевые символы (<code>&apos;\0&apos;</code> или <code>&apos;\u0000&apos;</code>)
преобразуются в <code>0x20</code> (символ пробела). Если вам нужно сохранить нулевые символы как <code>0x00</code>,
то вам нужно использовать кодировку <code>&apos;utf8&apos;</code>.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> — Многобайтовые Unicode-символы. Многие веб-страницы и документы используют UTF-8.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> — Двухбайтовые little endian Unicode-символы.
Могут кодировать только символы в диапазоне U+0000 - U+FFFF (Basic Multilingual Plane).</p>
</li>
<li><p><code>&apos;binary&apos;</code> — устаревший способ. Хранит двоичные данные в строке используя
младшие 8 бит каждого символа. Не используйте эту кодировку.</p>
</li>
</ul>
<h2>Класс: Buffer<span><a class="mark" href="#all_buffer" id="all_buffer">#</a></span></h2>
<p>Класс Buffer является клобальным классом для работы с бинарными данными напрямую.
Его можно инстанцировать несколькими способами.

</p>
<h3>new Buffer(size)<span><a class="mark" href="#all_new_buffer_size" id="all_new_buffer_size">#</a></span></h3>
<div class="signature"><ul>
<li><code>size</code> Number</li>
</div></ul>
<p>Создаёт новый буфер размера <code>size</code> байт.

</p>
<h3>new Buffer(array)<span><a class="mark" href="#all_new_buffer_array" id="all_new_buffer_array">#</a></span></h3>
<div class="signature"><ul>
<li><code>array</code> Array</li>
</div></ul>
<p>Создаёт новый буфер из массива <code>array</code> 8-битных символов.

</p>
<h3>new Buffer(str, [encoding])<span><a class="mark" href="#all_new_buffer_str_encoding" id="all_new_buffer_str_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>str</code> String - строка для записи в буфер.</li>
<li><code>encoding</code> String, необязательный параметр, по умолчанию: &apos;utf8&apos;</li>
</div></ul>
<p>Создаёт новый буфер, содержащий строку <code>str</code> в кодировке <code>encoding</code>.

</p>
<h3>buf.write(string, [offset], [length], [encoding])<span><a class="mark" href="#all_buf_write_string_offset_length_encoding" id="all_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String - данные для записи в буфер</li>
<li><code>offset</code> Number, необязательный параметр, по умолчанию: 0</li>
<li><code>length</code> Number, необязательный параметр</li>
<li><code>encoding</code> String, необязательный параметр, по умолчанию: &apos;utf8&apos;</li>
</div></ul>
<p>Записывает строку <code>string</code> в буфер по смещению <code>offset</code> от его начала
с использованием указанной кодировки. Возвращает количество записанных байт.
Если <code>buffer</code> не имеет достаточно места для сохранения всей строки,
то метод запишет только её часть. Этот метод не будет записывать частичные символы.

</p>
<p>Пример: записать UTF-8 строку в буфер, потом напечатать его.

</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<p>Количество записанных символов (которое может отличаться от количества записанных байт)
устанавливается в <code>Buffer._charsWritten</code>
и может быть изменено при следующем вызове <code>buf.write()</code>.

</p>
<h3>buf.toString([encoding], [start], [end])<span><a class="mark" href="#all_buf_tostring_encoding_start_end" id="all_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>encoding</code> String, необязательный параметр, по умолчанию: &apos;utf8&apos;</li>
<li><code>start</code> Number, необязательный параметр, по умолчанию: 0</li>
<li><code>end</code> Number, необязательный параметр</li>
</div></ul>
<p>Декодирует и возвращает строку из данных буфера, закодированных в кодировке
<code>encoding</code> начиная с позиции <code>start</code> и заканчивая позицией <code>end</code>.

</p>
<p>См. пример <code>buffer.write()</code> выше.


</p>
<h3>buf[index]<span><a class="mark" href="#all_buf_index" id="all_buf_index">#</a></span></h3>
<!--type=property-->
<!--name=[index]-->

<p>Получает или устанавливает байт на позиции <code>index</code>. Значения соответствуют индивидуальным
байтам и могут лежать в пределах от <code>0x00</code> до <code>0xFF</code> в шестнадцатиричной записи
и от <code>0</code> до <code>255</code> в десятичной. 

</p>
<p>Пример: скопировать ASCII строку в буфер, байт за байтом.

</p>
<pre><code>str = &quot;node.js&quot;;
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>
<h3>Метод класса: Buffer.isBuffer(obj)<span><a class="mark" href="#all_buffer_isbuffer_obj" id="all_buffer_isbuffer_obj">#</a></span></h3>
<div class="signature"><ul>
<li><code>obj</code> Object</li>
<li>Возвращает: Boolean</li>
</div></ul>
<p>Проверяет, является ли <code>obj</code> буфером.


</p>
<h3>Class Method: Buffer.byteLength(string, [encoding])<span><a class="mark" href="#all_class_method_buffer_bytelength_string_encoding" id="all_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, необязательный параметр, по умолчанию: &apos;utf8&apos;</li>
<li>Возвращает: Number</li>
</div></ul>
<p>Возвращает количество байт в строке. Это не то же самое что <code>String.prototype.length</code>,
так как этот метод возвращает число <em>символов</em> в строке.

</p>
<p>Пример:

</p>
<pre><code>str = &apos;\u00bd + \u00bc = \u00be&apos;;

console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
  Buffer.byteLength(str, &apos;utf8&apos;) + &quot; bytes&quot;);

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>buf.length<span><a class="mark" href="#all_buf_length" id="all_buf_length">#</a></span></h3>
<div class="signature"><ul>
<li>Number</li>
</div></ul>
<p>Размер буфера в байтах. Заметьте, что это значение не всегда соответствует размеру
содержимого. <code>length</code> возвращает объем памяти, зарезервированный для объекта буфера.
Это значение не изменяется при изменении содержимого буфера.

</p>
<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);
console.log(buf.length);

// 1234
// 1234</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a class="mark" href="#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="signature"><ul>
<li><code>targetBuffer</code> объект класса Buffer - целевой буффер для копирования</li>
<li><code>targetStart</code> Number, необязательный параметр, по умолчанию: 0</li>
<li><code>sourceStart</code> Number, необязательный параметр, по умолчанию: 0</li>
<li><code>sourceEnd</code> Number, необязательный параметр, по умолчанию: 0</li>
</div></ul>
<p>Копирует данные между буферами. Области <code>target</code> и <code>source</code> могут пересекаться.

</p>
<p>Пример: создадим два буфера, потом скопировать <code>buf1</code>
с байта 16 по байт 19 в <code>buf2</code>, начиная с 8-го байта в <code>buf2</code>.

</p>
<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString(&apos;ascii&apos;, 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buffer.slice([start], [end])<span><a class="mark" href="#all_buffer_slice_start_end" id="all_buffer_slice_start_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>start</code> Number, необязательный параметр, по умолчанию: 0</li>
<li><code>end</code> Number, необязательный параметр, по умолчанию: 0</li>
</div></ul>
<p>Возвращает новый буфер, указывающий на ту же область памяти что предыдущий,
но начиная со <code>start</code> и заканчивая <code>end</code> байтами.

</p>
<p><strong>Изменение содержимого нового буфера затронет содержимое старого!</strong>

</p>
<p>Пример: построить буфер с ASCII-алфавитом, вырезать часть в новый буфер, затем
изменить 1 часть в оригинальном буфере.

</p>
<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));

// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint8_offset_noassert" id="all_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16le_offset_noassert" id="all_buf_readuint16le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint16be_offset_noassert" id="all_buf_readuint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32le_offset_noassert" id="all_buf_readuint32le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readuint32be_offset_noassert" id="all_buf_readuint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a class="mark" href="#all_buf_readint8_offset_noassert" id="all_buf_readint8_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16le_offset_noassert" id="all_buf_readint16le_offset_noassert">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint16be_offset_noassert" id="all_buf_readint16be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32le_offset_noassert" id="all_buf_readint32le_offset_noassert">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a class="mark" href="#all_buf_readint32be_offset_noassert" id="all_buf_readint32be_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatle_offset_noassert" id="all_buf_readfloatle_offset_noassert">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readfloatbe_offset_noassert" id="all_buf_readfloatbe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublele_offset_noassert" id="all_buf_readdoublele_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a class="mark" href="#all_buf_readdoublebe_offset_noassert" id="all_buf_readdoublebe_offset_noassert">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint8_value_offset_noassert" id="all_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16le_value_offset_noassert" id="all_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint16be_value_offset_noassert" id="all_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32le_value_offset_noassert" id="all_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeuint32be_value_offset_noassert" id="all_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint8_value_offset_noassert" id="all_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement
signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16le_value_offset_noassert" id="all_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint16be_value_offset_noassert" id="all_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32le_value_offset_noassert" id="all_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writeint32be_value_offset_noassert" id="all_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatle_value_offset_noassert" id="all_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writefloatbe_value_offset_noassert" id="all_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 32 bit float.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublele_value_offset_noassert" id="all_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a class="mark" href="#all_buf_writedoublebe_value_offset_noassert" id="all_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>Example:

</p>
<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a class="mark" href="#all_buf_fill_value_offset_end" id="all_buf_fill_value_offset_end">#</a></span></h3>
<div class="signature"><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><code>end</code> Number, Optional</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#all_buffer_inspect_max_bytes" id="all_buffer_inspect_max_bytes">#</a></span></h2>
<div class="signature"><ul>
<li>Number, Default: 50</li>
</div></ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.

</p>
<h2>Class: SlowBuffer<span><a class="mark" href="#all_class_slowbuffer" id="all_class_slowbuffer">#</a></span></h2>
<p>This class is primarily for internal use.  JavaScript programs should
use Buffer instead of using SlowBuffer.

</p>
<p>In order to avoid the overhead of allocating many C++ Buffer objects for
small blocks of memory in the lifetime of a server, Node allocates memory
in 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it
will be backed by a parent SlowBuffer object.  If it is larger than this,
then Node will allocate a SlowBuffer slab for it directly.

</p>
<h1>Поток<span><a class="mark" href="#all_25" id="all_25">#</a></span></h1>
<pre><code>Стабильность: 2 - Нестабильно</code></pre>
<p>Поток — это абстрактный интерфейс, реализуемый многими объектами в Node.
Например, запрос к HTTP-серверу является потоком, также как stdout. Потоки
могут быть с возможностью чтения, записи или и того и другого. Все потоки
являются экземплярами <code>EventEmitter</code>.


</p>
<h2>Поток с возможностью чтения<span><a class="mark" href="#all_26" id="all_26">#</a></span></h2>
<!--type=class-->

<p><code>Поток с возможностью чтения</code> имеет следующие методы, свойства и события.

</p>
<h3>Событие: &apos;data&apos;<span><a class="mark" href="#all_data" id="all_data">#</a></span></h3>
<p><code>function (data) { }</code>

</p>
<p>Событие <code>&apos;data&apos;</code> передаёт обработчику либо <code>Buffer</code> (по умолчанию),
либо строку, если предварительно был вызван <code>setEncoding()</code>.

</p>
<p>Нужно иметь в виду, что <strong>даные будут потеряны</strong> если на момент возникновения
событиия <code>&apos;data&apos;</code> на него не было подписано ни одного обработчика.

</p>
<h3>Событие: &apos;end&apos;<span><a class="mark" href="#all_end" id="all_end">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется когда поток получает символ конца файла EOF (FIN в терминологии TCP).
Означает что событий <code>&apos;data&apos;</code> больше не предвидится. Если поток также имеет
возможность записи, писать данные можно и дальше.

</p>
<h3>Event: &apos;error&apos;<span><a class="mark" href="#all_event_error" id="all_event_error">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<p>Генерируется если при приёме данных произошла ошибка.

</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close" id="all_close">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется когда соответствующий потоку файловый дескриптор закрывается.
Не все потоки генерируют это событие. Например, входящий HTTP запрос
не генерирует <code>&apos;close&apos;</code>.

</p>
<h3>stream.readable<span><a class="mark" href="#all_stream_readable" id="all_stream_readable">#</a></span></h3>
<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>&apos;error&apos;</code>
occured, the stream came to an <code>&apos;end&apos;</code>, or <code>destroy()</code> was called.

</p>
<h3>stream.setEncoding(encoding)<span><a class="mark" href="#all_stream_setencoding_encoding" id="all_stream_setencoding_encoding">#</a></span></h3>
<p>Заставляет событие <code>&apos;data&apos;</code> передавать обработчику строку вместо буфера.
<code>encoding</code> может быть <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> или <code>&apos;base64&apos;</code>.

</p>
<h3>stream.pause()<span><a class="mark" href="#all_stream_pause" id="all_stream_pause">#</a></span></h3>
<p>Прекращает поступление событий <code>&apos;data&apos;</code>.

</p>
<h3>stream.resume()<span><a class="mark" href="#all_stream_resume" id="all_stream_resume">#</a></span></h3>
<p>Возобновляет поступление событий <code>&apos;data&apos;</code> после <code>pause()</code>.

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy" id="all_stream_destroy">#</a></span></h3>
<p>Закрывает соответствующий потоку файловый дескриптор.
Поток больше не будет генерировать событий.

</p>
<h3>stream.pipe(destination, [options])<span><a class="mark" href="#all_stream_pipe_destination_options" id="all_stream_pipe_destination_options">#</a></span></h3>
<p>Соединяет поток с возможностью чтения с потоком <code>destination</code>, доступным для записи.
Все читаемые этим поток данные будут записаны в <code>destination</code>. Для синхронизации
потоков можно использовать <code>stream.pause()</code> и <code>stream.resume()</code>.

</p>
<p>Эта функция возвращает поток <code>destination</code>.

</p>
<p>Пример эмуляции UNIX-команды <code>cat</code>:

</p>
<pre><code>process.stdin.resume();
process.stdin.pipe(process.stdout);</code></pre>
<p>По умолчанию при поступлдении события <code>end</code> у источника будет вызван метод <code>end()</code>
у приёмника <code>destination</code> is no longer writable. Если в качестве <code>options</code>
передать <code>{ end: false }</code>, то поток-приёмник останется открытым после закрытия потока-источника:

</p>
<pre><code>process.stdin.resume();

process.stdin.pipe(process.stdout, { end: false });

process.stdin.on(&quot;end&quot;, function() {
  process.stdout.write(&quot;Goodbye\n&quot;);
});</code></pre>
<h2>Поток с возможностью записи<span><a class="mark" href="#all_27" id="all_27">#</a></span></h2>
<!--type=class-->

<p>У <code>потока с возможностью записи</code> есть следующие методы, свойства и события.

</p>
<h3>Событие: &apos;drain&apos;<span><a class="mark" href="#all_drain" id="all_drain">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется после вызова метода <code>write()</code> вернувшего <code>false</code> — сигнал о том,
что можно писать дальше.

</p>
<h3>Событие: &apos;error&apos;<span><a class="mark" href="#all_error" id="all_error">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<p>Генерируется при ошибке с исключением <code>exception</code>.

</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_1" id="all_close_1">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется когда закрывается соответствующий потоку дескриптор.

</p>
<h3>Событие: &apos;pipe&apos;<span><a class="mark" href="#all_pipe" id="all_pipe">#</a></span></h3>
<p><code>function (src) { }</code>

</p>
<p>Генерируется когда поток передаётся в метод <code>pipe()</code> потока с возможностью записи.


</p>
<h3>stream.writable<span><a class="mark" href="#all_stream_writable" id="all_stream_writable">#</a></span></h3>
<p>Булево свойство, по умолчанию <code>true</code>, но становящиеся <code>false</code> после наступления
события <code>&apos;error&apos;</code> или вызова <code>end()</code> / <code>destroy()</code>.

</p>
<h3>stream.write(string, [encoding], [fd])<span><a class="mark" href="#all_stream_write_string_encoding_fd" id="all_stream_write_string_encoding_fd">#</a></span></h3>
<p>Записывает строку <code>string</code> в указанной кодировке <code>encoding</code> в поток. Возвращает
<code>true</code> если строка попала в буфер ядра. Возвращает <code>false</code> если буфер ядра полон
и данные будут отправлены позже. Когда данные будут отправлены и буфер ядра опустеет,
будет сгенерировано событие <code>&apos;drain&apos;</code>. Кодировка по умолчанию — <code>&apos;utf8&apos;</code>.

</p>
<p>Если указан необязательный параметр <code>fd</code>, он интерпретируется как файловый
дескриптор для отправки в поток. Это поддерживается только в UNIX потоках,
и просто игнорируется в другом окружении. Когда дескриптор пересылается таким
образом, если он будет закрыт до события &apos;drain&apos; потока, может быть отправлен
повреждённый (закрытый) дескриптор.

</p>
<h3>stream.write(buffer)<span><a class="mark" href="#all_stream_write_buffer" id="all_stream_write_buffer">#</a></span></h3>
<p>То же что и выше, но с использованием буфера.

</p>
<h3>stream.end()<span><a class="mark" href="#all_stream_end" id="all_stream_end">#</a></span></h3>
<p>Закрывает поток отправкой EOF или FIN.
Этот вызов позволяет отправить данные из очереди перед закрытием потока.

</p>
<h3>stream.end(string, encoding)<span><a class="mark" href="#all_stream_end_string_encoding" id="all_stream_end_string_encoding">#</a></span></h3>
<p>Посылает строку <code>string</code> в указанной кодировке <code>encoding</code> и закрывает поток
отправкой EOF или FIN. Так можно уменьшить общее число отправленных пакетов.

</p>
<h3>stream.end(buffer)<span><a class="mark" href="#all_stream_end_buffer" id="all_stream_end_buffer">#</a></span></h3>
<p>То же что выше но с использованием буфера.

</p>
<h3>stream.destroy()<span><a class="mark" href="#all_stream_destroy_1" id="all_stream_destroy_1">#</a></span></h3>
<p>Закрывает соответствующий потоку файловый дескриптор.
Поток больше не будет генерировать событий.
Все данные из очереди не будут записаны.

</p>
<h3>stream.destroySoon()<span><a class="mark" href="#all_stream_destroysoon" id="all_stream_destroysoon">#</a></span></h3>
<p>Закрывает соответствующий потоку файловый дескриптор после того, как очередь записи окажется пустой.

</p>
<h1>Модуль криптографии<span><a class="mark" href="#all_28" id="all_28">#</a></span></h1>
<p>Используйте <code>require(&apos;crypto&apos;)</code> чтобы получить доступ к функциям модуля.

</p>
<p>Криптографический модуль требует для своей работы наличия OpenSSL.
Он предоставляет возможность использовать аутентификацию в HTTPS и HTTP-соединениях.

</p>
<p>Модуль также предоставляет набор обёрток для некоторых методов OpenSSL:
hash, hmac, cipher, decipher, sign и verify.

</p>
<h2>crypto.createCredentials(details)<span><a class="mark" href="#all_crypto_createcredentials_details" id="all_crypto_createcredentials_details">#</a></span></h2>
<p>Создаёт объект данных аутентификации, может принимать параметром объект со следующими свойствами:

</p>
<ul>
<li><code>key</code> : строка с PEM-закодированным приватным ключом,</li>
<li><code>cert</code> : строка с PEM-закодированным сертификатом,</li>
<li><code>ca</code> : строка или список строк PEM-закодированных доверенных корневых сертификатов.</li>
<li><code>ciphers</code>: строка, описывающая какие способы шифрования стоит использовать или исключить.
Описание формата строки вы можете найти по адресу
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>.</li>
</ul>
<p>Если корневые сертификаты не указаны, node.js будет использовать список доверенных сертификатов,
расположенный по адресу <a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.


</p>
<h2>crypto.createHash(algorithm)<span><a class="mark" href="#all_crypto_createhash_algorithm" id="all_crypto_createhash_algorithm">#</a></span></h2>
<p>Создает и возвращает объект <code>hash</code>, который может быть использован
для создания криптографических хэшей по заданному алгоритму.

</p>
<p>Возможные значения для <code>algorithm</code> зависят от доступных алгоритмах в той версии OpenSSL,
которая у вас установлена. Например, это может быть <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code> и т.д.
В последней версии OpenSSL список поддерживаемых алгоритмов можно было узнать
с помощью команды <code>openssl list-message-digest-algorithms</code>.

</p>
<p>Пример: программа, рассчитывающая sha1 хеш-сумму содержимого файла.

</p>
<pre><code>var filename = process.argv[2];
var crypto = require(&apos;crypto&apos;);
var fs = require(&apos;fs&apos;);

var shasum = crypto.createHash(&apos;sha1&apos;);

var s = fs.ReadStream(filename);
s.on(&apos;data&apos;, function(d) {
  shasum.update(d);
});

s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
<h2>Класс: Hash<span><a class="mark" href="#all_hash" id="all_hash">#</a></span></h2>
<p>Класс для создания криптографических хэшей изс данных.

</p>
<p>Инстанцируется с помощью метода <code>crypto.createHash</code>.

</p>
<h3>hash.update(data, [input_encoding])<span><a class="mark" href="#all_hash_update_data_input_encoding" id="all_hash_update_data_input_encoding">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>, переданное в кодировке, указанной с помощью параметра
<code>input_encoding</code>, который может принимать значения <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> или <code>&apos;binary&apos;</code>
(по умолчанию <code>&apos;binary&apos;</code>). Этот метод может быть вызван несколько раз.

</p>
<h3>hash.digest([encoding])<span><a class="mark" href="#all_hash_digest_encoding" id="all_hash_digest_encoding">#</a></span></h3>
<p>Вычисляет хеш от всех поступивших данных.
Параметр <code>encoding</code> может равняться <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> или <code>&apos;base64&apos;</code> (по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Замечание: объект <code>hash</code> нельзя использовать после того, как будет вызван метод <code>digest()</code>.


</p>
<h2>crypto.createHmac(algorithm, key)<span><a class="mark" href="#all_crypto_createhmac_algorithm_key" id="all_crypto_createhmac_algorithm_key">#</a></span></h2>
<p>Создает и возвращает объект <code>hmac</code>, который может быть использован
для создания хеш-кода идентификации сообщений (HMAC) по заданному алгоритму и ключу.

</p>
<p>Возможные значения для <code>algorithm</code> зависят от доступных алгоритмах в OpenSSL,
см. описание для <code>crypto.createHash()</code> выше. <code>key</code> определяет используемый ключ.

</p>
<h2>Класс: Hmac<span><a class="mark" href="#all_hmac" id="all_hmac">#</a></span></h2>
<p>Класс для создания хеш-кода идентификации сообщений (HMAC).

</p>
<p>Инстанцируется с помощью метода <code>crypto.createHmac</code>.

</p>
<h3>hmac.update(data)<span><a class="mark" href="#all_hmac_update_data" id="all_hmac_update_data">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>. Этот метод может быть вызван несколько раз.

</p>
<h3>hmac.digest([encoding])<span><a class="mark" href="#all_hmac_digest_encoding" id="all_hmac_digest_encoding">#</a></span></h3>
<p>Вычисляет хеш от всех поступивших данных.
Параметр encoding может равняться <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> или <code>&apos;base64&apos;</code> (по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Замечание: объект <code>hmac</code> нельзя использовать после того, как будет вызван метод <code>digest()</code>.


</p>
<h2>crypto.createCipher(algorithm, password)<span><a class="mark" href="#all_crypto_createcipher_algorithm_password" id="all_crypto_createcipher_algorithm_password">#</a></span></h2>
<p>Создает и возвращает объект <code>cipher</code>, который может быть использован
для шифрования по заданному алгоритму и паролю.

</p>
<p>Возможные значения для <code>algorithm</code> зависят от доступных алгоритмах в той версии OpenSSL,
которая у вас установлена. Например, это может быть <code>&apos;aes192&apos;</code>, <code>&apos;blowfish&apos;</code> и т.д.
В последней версии OpenSSL список поддерживаемых алгоритмов можно было узнать
с помощью команды <code>openssl list-cipher-algorithms</code>.

</p>
<p><code>password</code> используется для получения информации о ключе и IV, и должен быть строкой,
закодированной с использованием кодировки <code>&apos;binary&apos;</code> (см. раздел про <a href="buffer.html">буферы</a>).


</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a class="mark" href="#all_crypto_createcipheriv_algorithm_key_iv" id="all_crypto_createcipheriv_algorithm_key_iv">#</a></span></h2>
<p>Создает и возвращает объект <code>cipher</code>, который может быть использован
для шифрования по заданному алгоритму, ключу и IV.

</p>
<p><code>algorithm</code> может иметь такие же значения, что и для метода <code>createCipher()</code>. <code>key</code> является ключём,
используемым в этом алгоритме. <code>iv</code> задаёт вектор инициализации. <code>key</code> и <code>iv</code> должны быть строками,
закодированными с использованием кодировки <code>&apos;binary&apos;</code> (см. раздел про <a href="buffer.html">буферы</a>).


</p>
<h2>Класс: Cipher<span><a class="mark" href="#all_cipher" id="all_cipher">#</a></span></h2>
<p>Класс для шифрования данных.

</p>
<p>Инстанцируется с помощью методов <code>crypto.createCipher</code> и <code>crypto.createCipheriv</code>.

</p>
<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_cipher_update_data_input_encoding_output_encoding" id="all_cipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>, кодировку которых задаёт аргумент <code>input_encoding</code>
(может равняться <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> или <code>&apos;binary&apos;</code>, по умолчанию <code>&apos;binary&apos;</code>). Аргумент <code>output_encoding</code>
определяет выходной формат и может равняться <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> или <code>&apos;hex&apos;</code> (по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Возвращает зашифрованного содержимого и может быть названо много раз с новыми данными.

</p>
<h3>cipher.final([output_encoding])<span><a class="mark" href="#all_cipher_final_output_encoding" id="all_cipher_final_output_encoding">#</a></span></h3>
<p>Возвращает все оставшиеся зашифрованного содержимого в кодировке <code>output_encoding</code>,
которая может равняться <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> или <code>&apos;utf8&apos;</code> (по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Замечание: объект <code>cipher</code> не может быть использован после вызова метода <code>final()</code>.


</p>
<h2>crypto.createDecipher(algorithm, password)<span><a class="mark" href="#all_crypto_createdecipher_algorithm_password" id="all_crypto_createdecipher_algorithm_password">#</a></span></h2>
<p>Создает и возвращает объект <code>decipher</code>, который может быть использован
для дешифрования по заданному алгоритму и паролю.
Это метод-близнец для <a href="#crypto.createCipher">createCipher()</a>`, описанному выше.

</p>
<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a class="mark" href="#all_crypto_createdecipheriv_algorithm_key_iv" id="all_crypto_createdecipheriv_algorithm_key_iv">#</a></span></h2>
<p>Создает и возвращает объект <code>decipher</code>, который может быть использован
для дешифрования по заданному алгоритму, ключу и IV.
Это метод-близнец для <a href="#crypto.createCipheriv">createCipheriv()</a>, описанному выше.


</p>
<h2>Класс: Decipher<span><a class="mark" href="#all_decipher" id="all_decipher">#</a></span></h2>
<p>Класс для дешифрования данных.

</p>
<p>Инстанцируется с помощью методов <code>crypto.createDecipher</code> и <code>crypto.createDecipheriv</code>.

</p>
<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a class="mark" href="#all_decipher_update_data_input_encoding_output_encoding" id="all_decipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>, формат которых задаёт аргумент <code>input_encoding</code>
(может равняться <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> или <code>&apos;hex&apos;</code>, по умолчанию <code>&apos;binary&apos;</code>). Аргумент <code>output_encoding</code>
определяет выходную кодировку и может равняться <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> или <code>&apos;binary&apos;</code> (по умолчанию <code>&apos;binary&apos;</code>).

</p>
<h3>decipher.final([output_encoding])<span><a class="mark" href="#all_decipher_final_output_encoding" id="all_decipher_final_output_encoding">#</a></span></h3>
<p>Возвращает все оставшиеся разшифрованного содержимого в виде простого текста.
Значение аргументо output_encoding объяснено выше.

</p>
<p>Замечание: объект <code>decipher</code> не может быть использован после вызова метода <code>final()</code>.


</p>
<h2>crypto.createSign(algorithm)<span><a class="mark" href="#all_crypto_createsign_algorithm" id="all_crypto_createsign_algorithm">#</a></span></h2>
<p>Создает и возвращает объект <code>signer</code>, который может быть использован
для создания электронной подписи по заданному алгоритму.


</p>
<h2>Класс: Signer<span><a class="mark" href="#all_signer" id="all_signer">#</a></span></h2>
<p>Класс для создания цифровых подписей.

</p>
<p>Инстанцируется с помощью метода <code>crypto.createSign</code>.

</p>
<h3>signer.update(data)<span><a class="mark" href="#all_signer_update_data" id="all_signer_update_data">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>. Этот метод может быть вызван несколько раз.

</p>
<h3>signer.sign(private_key, [output_format])<span><a class="mark" href="#all_signer_sign_private_key_output_format" id="all_signer_sign_private_key_output_format">#</a></span></h3>
<p>Вычисляет подпись для всех данных. <code>private_key</code> задаёт закрытый ключ в формате PEM.

</p>
<p>Возвращает подпись в формате <code>output_format</code>, который может равняться <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> или <code>&apos;base64&apos;</code>
(по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Замечание: объект <code>signer</code> не может быть использован после вызова метода <code>sign()</code>.


</p>
<h2>crypto.createVerify(algorithm)<span><a class="mark" href="#all_crypto_createverify_algorithm" id="all_crypto_createverify_algorithm">#</a></span></h2>
<p>Создает и возвращает объект <code>verifier</code>, который может быть использован
для проверки электронной подписи. Это объект-близнец для объекта <code>signer</code>.


</p>
<h2>Класс: Verify<span><a class="mark" href="#all_verify" id="all_verify">#</a></span></h2>
<p>Класс для проверки цифровых подписей.

</p>
<p>Инстанцируется с помощью метод <code>crypto.createVerify</code>.

</p>
<h3>verifier.update(data)<span><a class="mark" href="#all_verifier_update_data" id="all_verifier_update_data">#</a></span></h3>
<p>Обновляет содержимое на <code>data</code>. Этот метод может быть вызван несколько раз.

</p>
<h3>verifier.verify(cert, signature, [signature_format])<span><a class="mark" href="#all_verifier_verify_cert_signature_signature_format" id="all_verifier_verify_cert_signature_signature_format">#</a></span></h3>
<p>Проверяет данные с помощью сертификата <code>cert</code> в формате PEM и подписи
<code>signature</code> формата <code>signature_format</code>, который может равняться <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> или <code>&apos;base64&apos;</code>
(по умолчанию <code>&apos;binary&apos;</code>).

</p>
<p>Возвращает <code>true</code> или <code>false</code> в зависимости от действительности подписи и публичного ключа.

</p>
<p>Замечание: объект <code>verifier</code> не может быть использован после вызова метода <code>verify()</code>.


</p>
<h2>crypto.createDiffieHellman(prime_length)<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_length" id="all_crypto_creatediffiehellman_prime_length">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of the
given bit length. The generator used is <code>2</code>.

</p>
<h2>crypto.createDiffieHellman(prime, [encoding])<span><a class="mark" href="#all_crypto_creatediffiehellman_prime_encoding" id="all_crypto_creatediffiehellman_prime_encoding">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied prime. The
generator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>&apos;binary&apos;</code>.

</p>
<h2>Class: DiffieHellman<span><a class="mark" href="#all_class_diffiehellman" id="all_class_diffiehellman">#</a></span></h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>Returned by <code>crypto.createDiffieHellman</code>.

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a class="mark" href="#all_diffiehellman_generatekeys_encoding" id="all_diffiehellman_generatekeys_encoding">#</a></span></h3>
<p>Generates private and public Diffie-Hellman key values, and returns the
public key in the specified encoding. This key should be transferred to the
other party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>.
Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a class="mark" href="#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding" id="all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other party&apos;s
public key and returns the computed shared secret. Supplied key is
interpreted using specified <code>input_encoding</code>, and secret is encoded using
specified <code>output_encoding</code>. Encodings can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or
<code>&apos;base64&apos;</code>. The input encoding defaults to <code>&apos;binary&apos;</code>.
If no output encoding is given, the input encoding is used as output encoding.

</p>
<h3>diffieHellman.getPrime([encoding])<span><a class="mark" href="#all_diffiehellman_getprime_encoding" id="all_diffiehellman_getprime_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getGenerator([encoding])<span><a class="mark" href="#all_diffiehellman_getgenerator_encoding" id="all_diffiehellman_getgenerator_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a class="mark" href="#all_diffiehellman_getpublickey_encoding" id="all_diffiehellman_getpublickey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman public key in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a class="mark" href="#all_diffiehellman_getprivatekey_encoding" id="all_diffiehellman_getprivatekey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman private key in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setpublickey_public_key_encoding" id="all_diffiehellman_setpublickey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h3>diffieHellman.setPrivateKey(public_key, [encoding])<span><a class="mark" href="#all_diffiehellman_setprivatekey_public_key_encoding" id="all_diffiehellman_setprivatekey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>. Defaults to <code>&apos;binary&apos;</code>.

</p>
<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a class="mark" href="#all_crypto_pbkdf2_password_salt_iterations_keylen_callback" id="all_crypto_pbkdf2_password_salt_iterations_keylen_callback">#</a></span></h2>
<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments <code>(err, derivedKey)</code>.

</p>
<h2>crypto.randomBytes(size, [callback])<span><a class="mark" href="#all_crypto_randombytes_size_callback" id="all_crypto_randombytes_size_callback">#</a></span></h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<pre><code>// async
crypto.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
});

// sync
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;Have %d bytes of random data: %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
<h2>TLS (SSL)<span><a class="mark" href="#all_tls_ssl" id="all_tls_ssl">#</a></span></h2>
<p>Используйте <code>require(&apos;tls&apos;)</code> чтобы получить доступ к функциям этого модуля.

</p>
<p>Модуль <code>tls</code> использует OpenSSL чтобы предоставить Transport Layer Security и/или
Secure Socket Layer (SSL): зашифрованные соединения.

</p>
<p>TLS/SSL это инфраструктура с публичными ключами. Каждый клиент и каждый сервер должны иметь собственный приватный ключ. Приватный ключ создаётся таким образом:

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<p>Все серверы и некоторые клиенты должны иметь сертификат. Сертификаты это публичные ключи подписанные Центром Сертификации или самим создателем сертификата. Первый шаг в получени сертификата: создание файла запроса на подпись сертификата (CSR, Certificate Signing Request). Это делается следующим образом:

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>Чтобы создать самостоятельно подписанный сертификат CSR, сделайте:

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>Либо Вы можете отправить CSR в Центр Сертификации для подписи.

</p>
<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)


</p>
<h3>s = tls.connect(port, [host], [options], callback)<span><a class="mark" href="#all_s_tls_connect_port_host_options_callback" id="all_s_tls_connect_port_host_options_callback">#</a></span></h3>
<p>Создаёт новое соединение на выбранный порт и хост (хост по умолчанию - <code>localhost</code>). Опции <code>options</code> должны быть объектом, содержащим

</p>
<ul>
<li><p><code>key</code>: Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)</p>
</li>
<li><p><code>cert</code>: Строка или буфер содержащие ключ сертификата сервера в формате PEM.</p>
</li>
<li><p><code>ca</code>: Массив строк или буферов с доверенными сертификатами. Если этот массив пропущен, будут использованы &quot;корневые&quot; Центры Сертификации, например VeriSign. Они будут использованы для авторизации соединения.</p>
</li>
</ul>
<p><code>tls.connect()</code> возвращает текстовый объект <a href="#tls.CleartextStream">CleartextStream</a>.

</p>
<p>После рукопожатия TLS/SSL вызывается переданная функция. Вызов произойдёт независимо от того был ли авторизрван сертификат. Пользователь сам должен проверить значение <code>s.authorized</code> чтобы увидеть был ли сертификат подписан одним из указанных центров. Если <code>s.authorized === false</code> то в переменной <code>s.authorizationError</code> будет содержаться объект соответствующей ошибки.

</p>
<h3>STARTTLS<span><a class="mark" href="#all_starttls" id="all_starttls">#</a></span></h3>
<p>В ветке v0.4 нет функций для начала TLS-сессии для существующего TCP-соединения.
Тем не менее это возможно сделать. техника состоит в вызове <code>tls.createSecurePair()</code>,
который возвратит два потока: шифрованный и текстовый. Далее вам необходимо
перенаправить шифрованный поток в сокет, а в приложении использовать текстовый.

</p>
<p><a href="http://gist.github.com/848444">Пример использование этой техники</a>.


</p>
<h3>pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])<span><a class="mark" href="#all_pair_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized" id="all_pair_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">#</a></span></h3>
<p>Создаёт защищённый объект из пары потоков, один из которых производит
чтение/запись защифрованных данных, а другой производит чтение/запись исходных данных.
Обычно защифрованный поток связывается с входящим защифрованным потоком,
а получившийся поток с исходными данным используется в качестве замены зашифрованному потоку.

</p>
<ul>
<li><p><code>credentials</code>: Объект с данными о сертификатах, полученный с помощью <code>crypto.createCredentials(...)</code></p>
</li>
<li><p><code>isServer</code>: Булево значение, задающее, нужно ли открывать соединения в качестве сервера или клиента.</p>
</li>
<li><p><code>requestCert</code>: Булево значение, задающее, необходимо ли запрашивать сертификат соединябщегося клиента.
Применимо только к соединениям в роли сервера.</p>
</li>
<li><p><code>rejectUnauthorized</code>: Булево значение, задающее, необходимо ли отклонять соединения от клиентов с недействительными сертификатами.
Применимо только к соединениям в роли сервера c <code>requestCert</code> равным <code>true</code>.</p>
</li>
</ul>
<p><code>tls.createSecurePair()</code> возвращает объект <code>SecurePair</code> со свойствами
<a href="#tls.CleartextStream">cleartext</a> и <code>encrypted</code>, представляющие из себя потоки.

</p>
<h4>Событие: &apos;secure&apos;<span><a class="mark" href="#all_secure" id="all_secure">#</a></span></h4>
<p>Это событие возникает в случае когда SecurePair успешно устанавливает защищённое соединение.

</p>
<p>Аналогично случаю с событием &apos;secureConnection&apos; сервера, для подтверждения авторизации
нужно проверить свойство <code>pair.cleartext.authorized</code>.


</p>
<h3>tls.Server<span><a class="mark" href="#all_tls_server" id="all_tls_server">#</a></span></h3>
<p>Этот класс - подкласс <code>net.Server</code> и имеет те же методы. Вместо приёма простых TCP соединений он принимает защищённые соединения с использованием TLS или SSL.

</p>
<p>Простой пример эхо-сервера (возвращает полученные данные):

</p>
<pre><code>var tls = require(&apos;tls&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;server-key.pem&apos;),
  cert: fs.readFileSync(&apos;server-cert.pem&apos;)
};

tls.createServer(options, function (s) {
  s.write(&quot;welcome!\n&quot;);
  s.pipe(s);
}).listen(8000);</code></pre>
<p>Вы можете проверить сервер, присоединившись к нему с помощью <code>openssl s_client</code>:


</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h4>tls.createServer(options, secureConnectionListener)<span><a class="mark" href="#all_tls_createserver_options_secureconnectionlistener" id="all_tls_createserver_options_secureconnectionlistener">#</a></span></h4>
<p>Это конструктор для класса <code>tls.Server</code>. Объект опций может содержать следующие значения:

</p>
<ul>
<li><p><code>key</code>:  Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)</p>
</li>
<li><p><code>cert</code>: Строка или буфер содержащие ключ сертификата сервера в формате PEM.</p>
</li>
<li><p><code>ca</code>: Массив строк или буферов с доверенными сертификатами.
Если этот массив пропущен, будут использованы &quot;корневые&quot; Центры Сертификации, например VeriSign.
Они будут использованы для авторизации соединения.</p>
</li>
<li><p><code>requestCert</code>: Если принимает значение <code>true</code> сервер будет запрашивать у клиентов сертификаты
и пытаться проверять их подлинность. По умолчанию принимает значение <code>false</code>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: Если равно <code>true</code> сервер будет сбрасывать соединения сертификаты которых
не подтверждены списком доверенных Центров Сертификации. Эта опция действует только если <code>requestCert</code> равен <code>true</code>.
Значение по умолчанию: <code>false</code>.</p>
</li>
</ul>
<h4>Событие: &apos;secureConnection&apos;<span><a class="mark" href="#all_secureconnection" id="all_secureconnection">#</a></span></h4>
<p><code>function (cleartextStream) {}</code>

</p>
<p>Это событие генерируется при приёме нового соединения после успешного прохождения рукопожатия.
Аргумент - экземпляр <a href="#tls.CleartextStream">CleartextStream</a> открытый на чтение и запись. Он имеет все методы и события обычного потока.

</p>
<p><code>cleartextStream.authorized</code> - двоичное значение, сообщающее что клиент был проверен одним из заданных для сервера доверенных Центров Сертификации.
Если это свойство принимает значение <code>false</code>, в <code>cleartextStream.authorizationError</code> будет храниться ошибка авторизации.
Стоит заметить что в зависимости от настроек TLS-сервера неавторизованные соединения могут приниматься либо сбрасываться.


</p>
<h4>server.listen(port, [host], [callback])<span><a class="mark" href="#all_server_listen_port_host_callback" id="all_server_listen_port_host_callback">#</a></span></h4>
<p>Начинает приём соединений на указанном порту и адресе. Если адрес не указан, сервер принимает соединения на любой адрес IPv4 (<code>INADDR_ANY</code>).

</p>
<p>Эта функция асинхронна. Коллбек, переданный последним параметром, будет вызван когда сервер будет готов к приёму соединений.

</p>
<p>См. <code>net.Server</code> для дальнейшей информации.


</p>
<h4>server.close()<span><a class="mark" href="#all_server_close" id="all_server_close">#</a></span></h4>
<p>Прекращает приём новых соединений сервером. Эта функция асинхронна, сервер окончательно закрывается когда генерируется событие <code>&apos;close&apos;</code>.


</p>
<h4>server.maxConnections<span><a class="mark" href="#all_server_maxconnections" id="all_server_maxconnections">#</a></span></h4>
<p>Задайте это свойство чтобы сбрасывать новые соединения как только количество одновременных соединений достигнет указанного значения.

</p>
<h4>server.connections<span><a class="mark" href="#all_server_connections" id="all_server_connections">#</a></span></h4>
<p>Число одновременных соединений с сервером.


</p>
<h3>tls.CleartextStream<span><a class="mark" href="#all_tls_cleartextstream" id="all_tls_cleartextstream">#</a></span></h3>
<p>Представляет собой поток, созданный поверх <em>зашифрованного</em> потока, и позволяющий осуществлять чтение и запись в него исходных данных.

</p>
<p>Он имеет полностью совместимый со <a href="stream.html#streams">Stream</a> интерфейс и имеет обычные метогды и события потоков.

</p>
<h4>cleartextStream.authorized<span><a class="mark" href="#all_cleartextstream_authorized" id="all_cleartextstream_authorized">#</a></span></h4>
<p>Булевый индикатор, принимающий значение <code>true</code> если сертификат клиента
подписан одним из сертифицированных CAs и <code>false</code> в противном случае.

</p>
<h4>cleartextStream.authorizationError<span><a class="mark" href="#all_cleartextstream_authorizationerror" id="all_cleartextstream_authorizationerror">#</a></span></h4>
<p>Содержит причину, по которой сертификат клиента не может быть подтверждён.
Это свойство доступно только в случае если <code>cleartextStream.authorized === false</code>.

</p>
<h4>cleartextStream.getPeerCertificate()<span><a class="mark" href="#all_cleartextstream_getpeercertificate" id="all_cleartextstream_getpeercertificate">#</a></span></h4>
<p>Возвращает объект, представлябщий сертификат клиента. Этот объект содержит свойства, соответствующие полям сертификата.

</p>
<p>Пример:

</p>
<pre><code>{ subject: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  issuer: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  valid_from: &apos;Nov 11 09:52:22 2009 GMT&apos;,
  valid_to: &apos;Nov  6 09:52:22 2029 GMT&apos;,
  fingerprint: &apos;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&apos; }</code></pre>
<p>Если клиент не предоставляет сертификат, этот метод возвращает <code>null</code> или пустой объект (<code>{}</code>).


</p>
<h2>Файловая система<span><a class="mark" href="#all_29" id="all_29">#</a></span></h2>
<p>Файловый ввод/вывод обеспечивается с помощью простой обертки вокруг стандартных
функций POSIX. Используйте <code>require(&apos;fs&apos;)</code> чтобы получить к ним доступ.
Все эти методы имеют асинхронную и синхронную версии.

</p>
<p>Асинхронные версии всегда принимают функцию обратного вызова в качестве
последнего аргумента. Аргументы, передаваемые в функцию обратного вызова зависят
от вызываемой функции, но первый из них всегда зарезервирован для исключения.
Если операция завершается без ошибок, то в качется первого аргумента
передаётся <code>null</code> или <code>undefined</code>.

</p>
<p>Пример использования асинхронной версии:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<p>Пример использования асинхронной версии:

</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<p>Асинхронные методы не гарантируют порядок выполнения операций.
Следующий код может сработать неправильно:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<p>Вполне возможно что fs.stat выполнится до fs.rename. Правильный способ сделать
то же самое — выполнение этих методов по цепочке.

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<p>В нагруженных процессах программисту <em>строго рекомендуется</em> использовать
асинхронные версии вызовов. Синхронные версии будут блокировать весь процесс
до своего завершения — предотвращая любые новые соединения.

</p>
<p>В агрументах приведённых функций можно указывать относительные пути до файлов,
тогда в качестве родительской папки будет использоваться <code>process.cwd()</code>.


</p>
<h3>fs.rename(path1, path2, [callback])<span><a class="mark" href="#all_fs_rename_path1_path2_callback" id="all_fs_rename_path1_path2_callback">#</a></span></h3>
<p>Асинхронное переименование (rename(2)).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.renameSync(path1, path2)<span><a class="mark" href="#all_fs_renamesync_path1_path2" id="all_fs_renamesync_path1_path2">#</a></span></h3>
<p>Синхронный rename(2).

</p>
<h3>fs.truncate(fd, len, [callback])<span><a class="mark" href="#all_fs_truncate_fd_len_callback" id="all_fs_truncate_fd_len_callback">#</a></span></h3>
<p>Асинхронный ftruncate(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.truncateSync(fd, len)<span><a class="mark" href="#all_fs_truncatesync_fd_len" id="all_fs_truncatesync_fd_len">#</a></span></h3>
<p>Синхронный ftruncate(2).

</p>
<h3>fs.chown(path, uid, gid, [callback])<span><a class="mark" href="#all_fs_chown_path_uid_gid_callback" id="all_fs_chown_path_uid_gid_callback">#</a></span></h3>
<p>Асинхронный chown(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.chownSync(path, uid, gid)<span><a class="mark" href="#all_fs_chownsync_path_uid_gid" id="all_fs_chownsync_path_uid_gid">#</a></span></h3>
<p>Синхронный chown(2).

</p>
<h3>fs.fchown(path, uid, gid, [callback])<span><a class="mark" href="#all_fs_fchown_path_uid_gid_callback" id="all_fs_fchown_path_uid_gid_callback">#</a></span></h3>
<p>Асинхронный fchown(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.fchownSync(path, uid, gid)<span><a class="mark" href="#all_fs_fchownsync_path_uid_gid" id="all_fs_fchownsync_path_uid_gid">#</a></span></h3>
<p>Синхронный fchown(2).

</p>
<h3>fs.lchown(path, uid, gid, [callback])<span><a class="mark" href="#all_fs_lchown_path_uid_gid_callback" id="all_fs_lchown_path_uid_gid_callback">#</a></span></h3>
<p>Асинхронный lchown(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.lchownSync(path, uid, gid)<span><a class="mark" href="#all_fs_lchownsync_path_uid_gid" id="all_fs_lchownsync_path_uid_gid">#</a></span></h3>
<p>Синхронный lchown(2).

</p>
<h3>fs.chmod(path, mode, [callback])<span><a class="mark" href="#all_fs_chmod_path_mode_callback" id="all_fs_chmod_path_mode_callback">#</a></span></h3>
<p>Асинхронное изменение прав доступа (chmod(2)).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.chmodSync(path, mode)<span><a class="mark" href="#all_fs_chmodsync_path_mode" id="all_fs_chmodsync_path_mode">#</a></span></h3>
<p>Синхронный chmod(2).

</p>
<h3>fs.fchmod(fd, mode, [callback])<span><a class="mark" href="#all_fs_fchmod_fd_mode_callback" id="all_fs_fchmod_fd_mode_callback">#</a></span></h3>
<p>Асинхронный fchmod(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.fchmodSync(path, mode)<span><a class="mark" href="#all_fs_fchmodsync_path_mode" id="all_fs_fchmodsync_path_mode">#</a></span></h3>
<p>Синхронный fchmod(2).

</p>
<h3>fs.lchmod(fd, mode, [callback])<span><a class="mark" href="#all_fs_lchmod_fd_mode_callback" id="all_fs_lchmod_fd_mode_callback">#</a></span></h3>
<p>Асинхронный lchmod(2).
Обработчику не передаётся аргументов кроме возможного исключения.

</p>
<h3>fs.lchmodSync(path, mode)<span><a class="mark" href="#all_fs_lchmodsync_path_mode" id="all_fs_lchmodsync_path_mode">#</a></span></h3>
<p>Синхронный lchmod(2).

</p>
<h3>fs.stat(path, [callback])<span><a class="mark" href="#all_fs_stat_path_callback" id="all_fs_stat_path_callback">#</a></span></h3>
<p>Асинхронный stat(2). Обработчик получает два аргумента <code>(err, stats)</code>,
где <code>stats</code> это экземпляр <code>fs.Stats</code>. Он выглядит примерно так:

</p>
<pre><code>{ dev: 2049,
  ino: 305352,
  mode: 16877,
  nlink: 12,
  uid: 1000,
  gid: 1000,
  rdev: 0,
  size: 4096,
  blksize: 4096,
  blocks: 8,
  atime: &apos;2009-06-29T11:11:55Z&apos;,
  mtime: &apos;2009-06-29T11:11:40Z&apos;,
  ctime: &apos;2009-06-29T11:11:40Z&apos; }</code></pre>
<p>См. <code>fs.Stats</code> ниже для дополнительной информации.

</p>
<h3>fs.lstat(path, [callback])<span><a class="mark" href="#all_fs_lstat_path_callback" id="all_fs_lstat_path_callback">#</a></span></h3>
<p>Асинхронный lstat(2). Обработчик получает два аргумента <code>(err, stats)</code>,
где <code>stats</code> это экземпляр <a href="#fs.Stats"><code>fs.Stats</code></a>.

</p>
<h3>fs.fstat(fd, [callback])<span><a class="mark" href="#all_fs_fstat_fd_callback" id="all_fs_fstat_fd_callback">#</a></span></h3>
<p>Асинхронный fstat(2). Обработчик получает два аргумента <code>(err, stats)</code>,
где <code>stats</code> это экземпляр <a href="#fs.Stats"><code>fs.Stats</code></a>.

</p>
<h3>fs.statSync(path)<span><a class="mark" href="#all_fs_statsync_path" id="all_fs_statsync_path">#</a></span></h3>
<p>Синхронный stat(2). Возвращает экземпляр <code>fs.Stats</code>.

</p>
<h3>fs.lstatSync(path)<span><a class="mark" href="#all_fs_lstatsync_path" id="all_fs_lstatsync_path">#</a></span></h3>
<p>Синхронный lstat(2). Возвращает экземпляр <code>fs.Stats</code>.

</p>
<h3>fs.fstatSync(fd)<span><a class="mark" href="#all_fs_fstatsync_fd" id="all_fs_fstatsync_fd">#</a></span></h3>
<p>Синхронный fstat(2). Возвращает экземпляр <code>fs.Stats</code>.

</p>
<h3>fs.link(srcpath, dstpath, [callback])<span><a class="mark" href="#all_fs_link_srcpath_dstpath_callback" id="all_fs_link_srcpath_dstpath_callback">#</a></span></h3>
<p>Асинхронное создание ссылки (link(2)).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.linkSync(srcpath, dstpath)<span><a class="mark" href="#all_fs_linksync_srcpath_dstpath" id="all_fs_linksync_srcpath_dstpath">#</a></span></h3>
<p>Синхронный link(2).

</p>
<h3>fs.symlink(linkdata, path, [callback])<span><a class="mark" href="#all_fs_symlink_linkdata_path_callback" id="all_fs_symlink_linkdata_path_callback">#</a></span></h3>
<p>Асинхронное создание символической ссылки (symlink(2)).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.symlinkSync(linkdata, path)<span><a class="mark" href="#all_fs_symlinksync_linkdata_path" id="all_fs_symlinksync_linkdata_path">#</a></span></h3>
<p>Синхронный symlink(2).

</p>
<h3>fs.readlink(path, [callback])<span><a class="mark" href="#all_fs_readlink_path_callback" id="all_fs_readlink_path_callback">#</a></span></h3>
<p>Асинхронное разрешение ссылки (readlink(2)).
Обработчик принимает два аргумента <code>(err, resolvedPath)</code>.

</p>
<h3>fs.readlinkSync(path)<span><a class="mark" href="#all_fs_readlinksync_path" id="all_fs_readlinksync_path">#</a></span></h3>
<p>Синхронный readlink(2). Возвращает полученный путь.

</p>
<h3>fs.realpath(path, [callback])<span><a class="mark" href="#all_fs_realpath_path_callback" id="all_fs_realpath_path_callback">#</a></span></h3>
<p>Асинхронный realpath(2).
Обработчик принимает два аргумента <code>(err, resolvedPath)</code>.

</p>
<h3>fs.realpathSync(path)<span><a class="mark" href="#all_fs_realpathsync_path" id="all_fs_realpathsync_path">#</a></span></h3>
<p>Синхронный realpath(2). Возвращает полученный путь.

</p>
<h3>fs.unlink(path, [callback])<span><a class="mark" href="#all_fs_unlink_path_callback" id="all_fs_unlink_path_callback">#</a></span></h3>
<p>Асинхронный unlink(2).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.unlinkSync(path)<span><a class="mark" href="#all_fs_unlinksync_path" id="all_fs_unlinksync_path">#</a></span></h3>
<p>Синхронный unlink(2).

</p>
<h3>fs.rmdir(path, [callback])<span><a class="mark" href="#all_fs_rmdir_path_callback" id="all_fs_rmdir_path_callback">#</a></span></h3>
<p>Асинхронный rmdir(2).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.rmdirSync(path)<span><a class="mark" href="#all_fs_rmdirsync_path" id="all_fs_rmdirsync_path">#</a></span></h3>
<p>Синхронный rmdir(2).

</p>
<h3>fs.mkdir(path, mode, [callback])<span><a class="mark" href="#all_fs_mkdir_path_mode_callback" id="all_fs_mkdir_path_mode_callback">#</a></span></h3>
<p>Асинхронный mkdir(2).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.mkdirSync(path, mode)<span><a class="mark" href="#all_fs_mkdirsync_path_mode" id="all_fs_mkdirsync_path_mode">#</a></span></h3>
<p>Синхронный mkdir(2).

</p>
<h3>fs.readdir(path, [callback])<span><a class="mark" href="#all_fs_readdir_path_callback" id="all_fs_readdir_path_callback">#</a></span></h3>
<p>Асинхронное чтение содержимого директории (readdir(3)).
Обработчик принимает два аргумента <code>(err, files)</code>,
где <code>files</code> это массив имён файлов в директории исключая <code>&apos;.&apos;</code> и <code>&apos;..&apos;</code>.


</p>
<h3>fs.readdirSync(path)<span><a class="mark" href="#all_fs_readdirsync_path" id="all_fs_readdirsync_path">#</a></span></h3>
<p>Синхронный readdir(3). Возвращает массив имён файлов исключая <code>&apos;.&apos;</code> и <code>&apos;..&apos;</code>.

</p>
<h3>fs.close(fd, [callback])<span><a class="mark" href="#all_fs_close_fd_callback" id="all_fs_close_fd_callback">#</a></span></h3>
<p>Асинхронный close(2).
Передаваемой функции не передаётся ничего кроме возможного исключения.

</p>
<h3>fs.closeSync(fd)<span><a class="mark" href="#all_fs_closesync_fd" id="all_fs_closesync_fd">#</a></span></h3>
<p>Синхронный close(2).

</p>
<h3>### fs.open(path, flags, [mode], [callback])<span><a class="mark" href="#all_fs_open_path_flags_mode_callback" id="all_fs_open_path_flags_mode_callback">#</a></span></h3>
<p>Асинхронное открытие файла. См. open(2).
Флаги могут быть:

</p>
<ul>
<li><p><code>&apos;r&apos;</code> - Файл открывается для чтения.
Если файл не существуется, произойдёт исключение.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - Файл открывается для чтения и записи.
Если файл не существуется, произойдёт исключение.</p>
</li>
<li><p><code>&apos;w&apos;</code> - Файл открывается для записи.
Файл будет создан (если не существует) или очищен (если существует).</p>
</li>
<li><p><code>&apos;w+&apos;</code> - Файл открывается для чтения и записи.
Файл будет создан (если не существует) или очищен (если существует).</p>
</li>
<li><p><code>&apos;a&apos;</code> - Файл открывается для для добавления данных.
Если файл не существуется, он будет создан.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - Файл открывается для добавления данных и чтения.
Если файл не существуется, он будет создан.</p>
</li>
</ul>
<p>По умолчанию <code>mode</code> равняется 0666. Обработчик принимает два аргумента: <code>(err, fd)</code>.

</p>
<h3>fs.openSync(path, flags, [mode])<span><a class="mark" href="#all_fs_opensync_path_flags_mode" id="all_fs_opensync_path_flags_mode">#</a></span></h3>
<p>Синхронный open(2).

</p>
<h3>fs.write(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_write_fd_buffer_offset_length_position_callback" id="all_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h3>
<p>Записывает буфер <code>buffer</code> в файл указанный дескриптором <code>fd</code>.

</p>
<p>Сдвиг <code>offset</code> и длина <code>length</code> определяют часть буфера, которая будет записана.

</p>
<p>Позиция <code>position</code> задаёт смещение от начала файла куда должны быть записаны данные.
Если <code>position</code> равна <code>null</code>, данные записываются с текущей позиции. См. pwrite(2).

</p>
<p>Обработчик принимает три аргумента <code>(err, written, buffer)</code>,
где <code>written</code> указывает сколько <em>байт</em> было записано в буфер buffer.

</p>
<p>Нужно иметь в виду, что вызов <code>fs.write</code> несколько раз для одного файла не дожидаясь
коллбека не безопасен. При таком сценарии лучше использовать <code>fs.createWriteStream</code>.

</p>
<h3>fs.writeSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_writesync_fd_buffer_offset_length_position" id="all_fs_writesync_fd_buffer_offset_length_position">#</a></span></h3>
<p>Синхронная версия <code>fs.write()</code>. Возвращает число записанных <em>байт</em>.

</p>
<h3>fs.writeSync(fd, str, position, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_fs_writesync_fd_str_position_encoding_utf8" id="all_fs_writesync_fd_str_position_encoding_utf8">#</a></span></h3>
<p>Синхронная версия <code>fs.write()</code>, записывающая в файл строку, а не буфер.
Возвращает число записанных <em>байт</em>.

</p>
<h3>fs.read(fd, buffer, offset, length, position, [callback])<span><a class="mark" href="#all_fs_read_fd_buffer_offset_length_position_callback" id="all_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h3>
<p>Читает данные из файла, указанного дескриптором <code>fd</code>.

</p>
<p><code>buffer</code> — буфер, в который будут помещены прочитанные данные.

</p>
<p><code>offset</code> — смещение внутри буфера с которого начнётся запись.

</p>
<p><code>length</code> — число байт для чтения.

</p>
<p><code>position</code> — число означающее позицию, с которой начнётся чтение файла.
Если <code>position</code> принимает значение <code>null</code>, данные будут прочитаны с текущей позиции.

</p>
<p>Функция-обработчик принимает два аргумента, <code>(err, bytesRead, buffer)</code>.

</p>
<h3>fs.readSync(fd, buffer, offset, length, position)<span><a class="mark" href="#all_fs_readsync_fd_buffer_offset_length_position" id="all_fs_readsync_fd_buffer_offset_length_position">#</a></span></h3>
<p>Синхронная версия <code>fs.read</code>. Возвращает количество прочитанных <em>байт</em>.

</p>
<h3>fs.readSync(fd, length, position, encoding)<span><a class="mark" href="#all_fs_readsync_fd_length_position_encoding" id="all_fs_readsync_fd_length_position_encoding">#</a></span></h3>
<p>Синхронная версия <code>fs.read</code>, читающая из файл строку, а не буфер.
Возвращает количество прочитанных <em>байт</em>.

</p>
<h3>fs.readFile(filename, [encoding], [callback])<span><a class="mark" href="#all_fs_readfile_filename_encoding_callback" id="all_fs_readfile_filename_encoding_callback">#</a></span></h3>
<p>Асинхронно загружает в память содержимое файла. Пример:

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>Обработчику передаются два аргумента: <code>(err, data)</code>, где <code>data</code> — содержимое файла.

</p>
<p>Если кодировка не указана, возвращается буфер.


</p>
<h3>fs.readFileSync(filename, [encoding])<span><a class="mark" href="#all_fs_readfilesync_filename_encoding" id="all_fs_readfilesync_filename_encoding">#</a></span></h3>
<p>Синхронная версия <code>fs.readFile</code>. Возвращает содержимое файла <code>filename</code>.

</p>
<p>Если указана кодировка <code>encoding</code>, то функция возвращает строку. Иначе — возвращает буфер.


</p>
<h3>fs.writeFile(filename, data, encoding=&apos;utf8&apos;, [callback])<span><a class="mark" href="#all_fs_writefile_filename_data_encoding_utf8_callback" id="all_fs_writefile_filename_data_encoding_utf8_callback">#</a></span></h3>
<p>Асинхронно записывает данные в файл. В случае существования файла перезаписывает его.
<code>data</code> может быть строкой или буфером.

</p>
<p>Пример:

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;);
});</code></pre>
<h3>fs.writeFileSync(filename, data, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_fs_writefilesync_filename_data_encoding_utf8" id="all_fs_writefilesync_filename_data_encoding_utf8">#</a></span></h3>
<p>Синхронная версия <code>fs.writeFile</code>.

</p>
<h3>fs.watchFile(filename, [options], listener)<span><a class="mark" href="#all_fs_watchfile_filename_options_listener" id="all_fs_watchfile_filename_options_listener">#</a></span></h3>
<p>Наблюдает за файлом <code>filename</code>. Обработчик <code>listener</code> вызывается каждый раз
при обращении к файлу.

</p>
<p>Второй аргумент необязателен. Объект <code>options</code>, если он передан, должен содержать
два свойства: булево <code>persistent</code> и <code>interval</code>, задержку между проверками
файла в миллисекундах. Значение по умолчанию: <code>{ persistent: true, interval: 0 }</code>.

</p>
<p>Обработчик <code>listener</code> принимает два аргумента: текущий объект stat и предыдущий объект stat.

</p>
<pre><code>fs.watchFile(&apos;message.text&apos;, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<p>Эти объекты — экземпляры <code>fs.Stat</code>.

</p>
<p>Если вы хотите обрабатывать только события изменения файла, вам следует сравнивать
<code>curr.mtime</code> и <code>prev.mtime</code>.


</p>
<h3>fs.unwatchFile(filename)<span><a class="mark" href="#all_fs_unwatchfile_filename" id="all_fs_unwatchfile_filename">#</a></span></h3>
<p>Прекращает следить за файлом <code>filename</code>.

</p>
<h2>fs.Stats<span><a class="mark" href="#all_fs_stats" id="all_fs_stats">#</a></span></h2>
<p>Объекты, возвращаемые <code>fs.stat()</code>, <code>fs.lstat()</code> и <code>fs.fstat()</code> являются
экземплярами этого класса.

</p>
<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (доступно только после <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<h2>fs.ReadStream<span><a class="mark" href="#all_fs_readstream" id="all_fs_readstream">#</a></span></h2>
<p><code>ReadStream</code> является <code>потоком с возможностью чтения</code>.

</p>
<h3>Событие: &apos;open&apos;<span><a class="mark" href="#all_open" id="all_open">#</a></span></h3>
<p><code>function (fd) { }</code>

</p>
<p><code>fd</code> содержит файловый дескриптов, используемый ReadStream.

</p>
<h3>fs.createReadStream(path, [options])<span><a class="mark" href="#all_fs_createreadstream_path_options" id="all_fs_createreadstream_path_options">#</a></span></h3>
<p>Возвращает новый объект ReadStream.

</p>
<p><code>options</code> это объект со следующими полями по умолчанию:

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>
<p>Объект <code>options</code> может содержать поля <code>start</code> и <code>end</code> для чтения фрагмента файла
вместо всего файла. И <code>start</code>, и <code>end</code> являются границами с включением
и начинаюся с 0. При использовании необходимо задавать обе границы.

</p>
<p>Пример чтения последних 10 байт файла размером 100 байт:

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>fs.WriteStream<span><a class="mark" href="#all_fs_writestream" id="all_fs_writestream">#</a></span></h2>
<p><code>WriteStream</code> является <code>потоком с возможностью записи</code>.

</p>
<h3>Событие: &apos;open&apos;<span><a class="mark" href="#all_open_1" id="all_open_1">#</a></span></h3>
<p><code>function (fd) { }</code>

</p>
<p><code>fd</code> содержит файловый дескриптов, используемый WriteStream.

</p>
<h3>fs.createWriteStream(path, [options])<span><a class="mark" href="#all_fs_createwritestream_path_options" id="all_fs_createwritestream_path_options">#</a></span></h3>
<p>Возвращает новый объект WriteStream.

</p>
<p><code>options</code> это объект со следующими свойствами по умолчанию:

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<h2>Path<span><a class="mark" href="#all_path" id="all_path">#</a></span></h2>
<p>Этот модуль содержит средства для работы с путями.
Используйте <code>require(&apos;path&apos;)</code> чтобы получить к нему доступ.

</p>
<h3>path.normalize(p)<span><a class="mark" href="#all_path_normalize_p" id="all_path_normalize_p">#</a></span></h3>
<p>Нормализует строку пути, обрабатывая <code>&apos;..&apos;</code> и <code>&apos;.&apos;</code>.

</p>
<p>Пример:

</p>
<pre><code>path.normalize(&apos;/foo/bar/baz/asdf/quux/..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h3>path.join([path1], [path2], [...])<span><a class="mark" href="#all_path_join_path1_path2" id="all_path_join_path1_path2">#</a></span></h3>
<p>Соединяет все аргументы и нормализует получившийся путь.

</p>
<p>Пример:

</p>
<pre><code>node&gt; require(&apos;path&apos;).join(
...   &apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h3>path.resolve([from ...], to)<span><a class="mark" href="#all_path_resolve_from_to" id="all_path_resolve_from_to">#</a></span></h3>
<p>Разрешает путь <code>to</code> в абсолютный.

</p>
<p>Если <code>to</code> не является абсолютным, то к нему добавляют пути, справа налево,
из аргументов <code>from</code> до тех пор, пока полученный путь не будет абсолютным.
Если в итоге путь останется относительным, он будет разрешён относительно
рабочей директории. полученный путь нормализуется и у него удаляется
завершающий слеш, если конечно это не корневая директория.

</p>
<p>Возможно, вам будет проще понять механизм работы этого метода,
если считать что он последовательно выполняет команду <code>cd</code> и возвращает конечный путь, т.е.

</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>
<p>возвращает тоже самое, что и:

</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<p>Разница в том, что промежуточные пути могут не существовать или быть файлами.

</p>
<p>Примеры:

</p>
<pre><code>path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)
// returns
&apos;/foo/bar/baz&apos;

path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)
// returns
&apos;/tmp/file&apos;

path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)
// if currently in /home/myself/node, it returns
&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>
<h3>path.dirname(p)<span><a class="mark" href="#all_path_dirname_p" id="all_path_dirname_p">#</a></span></h3>
<p>Возвращает имя директории для пути. Действует как Unix-команда <code>dirname</code>.

</p>
<p>Пример:

</p>
<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h3>path.basename(p, [ext])<span><a class="mark" href="#all_path_basename_p_ext" id="all_path_basename_p_ext">#</a></span></h3>
<p>Возвращает последнюю часть пути. Действует как Unix-команда <code>basename</code>.

</p>
<p>Пример:

</p>
<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;)
// returns
&apos;quux.html&apos;

path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)
// returns
&apos;quux&apos;</code></pre>
<h3>path.extname(p)<span><a class="mark" href="#all_path_extname_p" id="all_path_extname_p">#</a></span></h3>
<p>Возвращает расширение пути. Учитывается всё после последней &apos;.&apos; в последней части пути.
Если в последней части нет &apos;.&apos; или &apos;.&apos; единственный символ, возвращает пустую строку.

</p>
<p>Пример:

</p>
<pre><code>path.extname(&apos;index.html&apos;)
// returns 
&apos;.html&apos;

path.extname(&apos;index&apos;)
// returns
&apos;&apos;</code></pre>
<h3>path.exists(p, [callback])<span><a class="mark" href="#all_path_exists_p_callback" id="all_path_exists_p_callback">#</a></span></h3>
<p>Проверяет, существует ли данный путь. Вызывает переданный обработчик
с аргументом <code>true</code> или <code>false</code>.

</p>
<p>Пример:

</p>
<pre><code>path.exists(&apos;/etc/passwd&apos;, function (exists) {
  util.debug(exists ? &quot;it&apos;s there&quot; : &quot;no passwd!&quot;);
});</code></pre>
<h3>path.existsSync(p)<span><a class="mark" href="#all_path_existssync_p" id="all_path_existssync_p">#</a></span></h3>
<p>Синхронная версия <code>path.exists</code>.


</p>
<h2>TCP / Сеть<span><a class="mark" href="#all_tcp" id="all_tcp">#</a></span></h2>
<p>Модуль <code>net</code> предоставляет асинхронные методы для работы с сетью. Он включает
методы для создания как серверов, так и клиентов (называемых потоками).
Вы может использовать этот модуль вызвав <code>require(&quot;net&quot;)</code>.

</p>
<h3>net.createServer([options], [connectionListener])<span><a class="mark" href="#all_net_createserver_options_connectionlistener" id="all_net_createserver_options_connectionlistener">#</a></span></h3>
<p>Создаёт новый TCP сервер. Аргумент <code>connection_listener</code> автоматически
становится обработчиком события <code>&apos;connection&apos;</code>.

</p>
<p>Параметр <code>options</code> содержит свойства сервера со следующими значениями по умолчанию:

</p>
<pre><code>{ allowHalfOpen: false
}</code></pre>
<p>Если <code>allowHalfOpen</code> равно <code>true</code>, то сокет не буждет автоматически посылать
пакет FIN при получении его от адресата. Сокет будет становиться доступным
только для записи. Необходимо вручную вызвать метод <code>end()</code> для закрытия сокета.
См. описанеи события <code>&apos;end&apos;</code> для более подробной информации.


</p>
<h3>net.createConnection(arguments...)<span><a class="mark" href="#all_net_createconnection_arguments" id="all_net_createconnection_arguments">#</a></span></h3>
<p>Создаёт новый сокет. Когда соединение установлено, будет сгенерировано
событие <code>&apos;connect&apos;</code>.

</p>
<p>Аргументы для этого метода определяются типом соединения:

</p>
<ul>
<li><p><code>net.createConnection(port, [host])</code></p>
<p>Открывает TCP-соединение с указанным портом <code>port</code> и адресом <code>host</code>.
Если второй параметр не задан, предполагается значение <code>localhost</code>.</p>
</li>
<li><p><code>net.createConnection(path)</code></p>
<p>Создаёт соединение с Unix-сокетом <code>path</code>.</p>
</li>
</ul>
<hr>
<h3>net.Server<span><a class="mark" href="#all_net_server" id="all_net_server">#</a></span></h3>
<p>Этот класс используется для создания TCP или UNIX сервера.

</p>
<p>Вот простой пример сервера, который возвращает полученный запрос
и слушает на порту 8124:

</p>
<pre><code>var net = require(&apos;net&apos;);
var server = net.createServer(function (c) {
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.listen(8124, &apos;localhost&apos;);</code></pre>
<p>Проверить работу сервера можно с помощью <code>telnet</code>:

</p>
<pre><code>telnet localhost 8124</code></pre>
<p>Чтобы слушать сокет <code>&apos;/tmp/echo.sock&apos;</code>, последнюю строку скрипта надо заменить на

</p>
<pre><code>server.listen(&apos;/tmp/echo.sock&apos;);</code></pre>
<p>Для подключения к UNIX-сокеты используйте <code>nc</code>:

</p>
<pre><code>nc -U /tmp/echo.sock</code></pre>
<h4>server.listen(port, [host], [callback])<span><a class="mark" href="#all_server_listen_port_host_callback_1" id="all_server_listen_port_host_callback_1">#</a></span></h4>
<p>Начинает принимать соединения на указанном порту <code>port</code> и имени хоста <code>host</code>.
Если <code>host</code> пропущен, сервер будет принимать соединения
на каждом IPv4-адресе (INADDR_ANY).

</p>
<p>Эта функция асинхронна. Последний параметр <code>callback</code> будет вызван когда сервер
начнёт принимать соединения.

</p>
<h4>server.listen(path, [callback])<span><a class="mark" href="#all_server_listen_path_callback" id="all_server_listen_path_callback">#</a></span></h4>
<p>Запускает сервер слушающий UNIX-сокет по указанному адресу <code>path</code>.

</p>
<p>Эта функция асинхронна. Последний параметр <code>callback</code> будет вызван когда сервер
начнёт принимать соединения.

</p>
<p>Часто пользователи сообщают об ошибке <code>EADDRINUSE</code>. Она означает, что на этом порту
уже запущен другой сервер. Одним из способов обработки ошибки <code>EADDRINUSE</code> является
ожидание в течении, напрмиер, одной секунды и повторная попытка вызова <code>server.listen</code>.
Это можно сделать с помощью следующего кода:

</p>
<pre><code>server.on(&apos;error&apos;, function (e) {
  if (e.code == &apos;EADDRINUSE&apos;) {
    console.log(&apos;Address in use, retrying...&apos;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<p>ПРИМЕЧАНИЕ: Все сокеты в Node имеют установленную опцию SO_REUSEADDR.


</p>
<h4>server.listenFD(fd)<span><a class="mark" href="#all_server_listenfd_fd" id="all_server_listenfd_fd">#</a></span></h4>
<p>Запускает сервер, слушающий указанный файловый дескриптор.

</p>
<p>Для указанного файлового дескриптора должны быть уже выполнены
системные вызовы <code>bind(2)</code> и <code>listen(2)</code>. Кроме того,
он должен быть неблокирующим, это устанавливается с помощью
<code>fcntl(fd, F_SETFL, O_NONBLOCK)</code>.

</p>
<h4>server.pause([msecs])<span><a class="mark" href="#all_server_pause_msecs" id="all_server_pause_msecs">#</a></span></h4>
<p>Приостанавливает приём подключений на указанное количество миллисекунд
(по умолчанию секунда). Это может быть использовано для регулирования
количества новых подключений во время DoS атаки.

</p>
<h4>server.close()<span><a class="mark" href="#all_server_close_1" id="all_server_close_1">#</a></span></h4>
<p>Прекращает приём соединений сервером. Эта функция асинхронна,
сервер полностью закрывается только после генерации события <code>&apos;close&apos;</code>.


</p>
<h4>server.address()<span><a class="mark" href="#all_server_address" id="all_server_address">#</a></span></h4>
<p>Возвращает адрес, к которому привязан сервер. Удобно использовать, если выбор
адреса предоставляется системе. Возвращает объект с двумя свойствами:
<code>{&quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:2121}</code>.

</p>
<p>Пример:

</p>
<pre><code>var server = net.createServer(function (socket) {
  socket.end(&quot;goodbye\n&quot;);
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<h4>server.maxConnections<span><a class="mark" href="#all_server_maxconnections_1" id="all_server_maxconnections_1">#</a></span></h4>
<p>Установите это свойство, если хотите запретить серверу принимать
больше определённого числа соединений единовременно.

</p>
<h4>server.connections<span><a class="mark" href="#all_server_connections_1" id="all_server_connections_1">#</a></span></h4>
<p>Текущее число соединений с сервером.

</p>
<hr>
<p><code>net.Server</code> — экземпляр <code>EventEmitter</code> со следующими событиями:

</p>
<h4>Событие: &apos;connection&apos;<span><a class="mark" href="#all_connection" id="all_connection">#</a></span></h4>
<p><code>function (socket) {}</code>

</p>
<p>Генерируется при новом соединении. <code>socket</code> — экземпляр <code>net.Socket</code>.

</p>
<h4>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_2" id="all_close_2">#</a></span></h4>
<p><code>function () {}</code>

</p>
<p>Генерируется при завершении работы сервера.

</p>
<hr>
<h3>net.Socket<span><a class="mark" href="#all_net_socket" id="all_net_socket">#</a></span></h3>
<p>Этот объект — абстракция TCP порта или UNIX сокета. Экземпляр <code>net.Socket</code>
имеет возможность как чтения, так и записи. Он может быть создан и использован
как клиентом (с помощью <code>connect()</code>) либо создан внутри Node и передан
пользователю через обработчик события <code>&apos;connection&apos;</code>.

</p>
<h4>new net.Socket([options])<span><a class="mark" href="#all_new_net_socket_options" id="all_new_net_socket_options">#</a></span></h4>
<p>Создаёт новый объект сокета.

</p>
<p>Объект <code>options</code> может содержать следующие поля со значениями по умолчанию:

</p>
<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>
<p>Параметр <code>fd</code> позволяет вам указать существующий файловый дескриптор для создания сокета.
Параметр <code>type</code> определяет протокол и может равняться <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code> или <code>&apos;unix&apos;</code>.
Параметр <code>allowHalfOpen</code> более подробно описан в функциях <code>createServer()</code> и событии <code>&apos;end&apos;</code> сокета.

</p>
<h4>socket.connect(port, [host])<span><a class="mark" href="#all_socket_connect_port_host" id="all_socket_connect_port_host">#</a></span></h4>
<h4>socket.connect(path)<span><a class="mark" href="#all_socket_connect_path" id="all_socket_connect_path">#</a></span></h4>
<p>Открывает TCP-соединение с указанным портом <code>port</code> и адресом <code>host</code>. Если второй
параметр не задан, предполагается значение <code>localhost</code>. Если указан параметр
<code>path</code>, то создаёт соединение с Unix-сокетом <code>path</code>.

</p>
<p>Обычно этот метод не нужен. Используйте его только если поток закрыт и вы хотите
повторно использовать тот же объект для соединения с другим сервером.

</p>
<p>Эта функция асинхронна. Когда генерируется событие <code>&apos;connect&apos;</code>, соединение
установлено. Если при соединении возникли проблемы, событие <code>&apos;connect&apos;</code>
не будет сгенерировано, вместо него будет сгенерировано событие <code>&apos;error&apos;</code>
с аргументом исключения.

</p>
<p>Функция <code>callback</code> будет добавлена как обработчик события <code>&apos;connect&apos;</code>.


</p>
<h4>socket.bufferSize<span><a class="mark" href="#all_socket_buffersize" id="all_socket_buffersize">#</a></span></h4>
<p><code>net.Socket</code> имеет свойство, которое постоянно используется в <code>socket.write()</code>.
Это нужно для быстрой работы Node. Компьютер не может самостоятельно определить,
сколько данных реально записано в сокет, так как сетевые соединения могут быть
очень медленными. Node содержит очередь записи для сокетов и производит её
при первой же возможности. (Внутри это представялет из себя polling файлового
дескриптора сокета на предмет возможности записи).

</p>
<p>ЕСледствием этой внутренней буферизации является возможное увеличение затрат памяти.
Это совйство (<code>bufferSize</code>) показывает количество символов, которые содержатся
на данный момент в очереди на запись. (Количество символов примерно равно количеству
байтов, однако в буфере могут находиться строки и тогда это не совсем верно).

</p>
<p>Если вы наблюдаете большую величину <code>bufferSize</code> или её быстрое увеличение, то вы
можете попробовать посылать данные порциями (&quot;throttle&quot;), используя методы <code>pause()</code> и resume()`.


</p>
<h4>socket.setEncoding(encoding=null)<span><a class="mark" href="#all_socket_setencoding_encoding_null" id="all_socket_setencoding_encoding_null">#</a></span></h4>
<p>Задаёт кодировку (<code>&apos;ascii&apos;</code>, <code>&apos;utf8&apos;</code> или <code>&apos;base64&apos;</code>) для принимаемых данных.

</p>
<h4>socket.setSecure([credentials])<span><a class="mark" href="#all_socket_setsecure_credentials" id="all_socket_setsecure_credentials">#</a></span></h4>
<p>Эта функция удалена в v0.3. Она использовалась для установки защищённого соединения.
См. модуль TLS с описанием нового API.

</p>
<h4>socket.write(data, [encoding], [callback])<span><a class="mark" href="#all_socket_write_data_encoding_callback" id="all_socket_write_data_encoding_callback">#</a></span></h4>
<p>Отправляет данные в поток. Второй параметр означает кодировку, если первым
параметром передана строка. По умолчанию используется UTF-8.

</p>
<p>Возвращает <code>true</code> если все данные были успешно переданы в буфер ядра. Возвращает
<code>false</code> если все данные или их часть были помещены в очередь в памяти. Событие
<code>&apos;drain&apos;</code> будет сгенерировано когда буфер ядра снова будет пуст.

</p>
<p>Необязательый параметр-функци <code>callback</code> будет вызвана после завершения записи данных.

</p>
<h4>socket.write(data, [encoding], [fileDescriptor], [callback])<span><a class="mark" href="#all_socket_write_data_encoding_filedescriptor_callback" id="all_socket_write_data_encoding_filedescriptor_callback">#</a></span></h4>
<p>UNIX-сокеты позволяют передавать через них файловые дескрипторы между приложениями.
Для этого достаточно передать параметр <code>fileDescriptor</code> и ожидать события <code>&apos;fd&apos;</code>
во втором приложении.

</p>
<h4>socket.end([data], [encoding])<span><a class="mark" href="#all_socket_end_data_encoding" id="all_socket_end_data_encoding">#</a></span></h4>
<p>Наполовину закрывает соединение, т.е. отправляет пакет FIN. Возможно сервер ещё
получит какие-то данные.

</p>
<p>Если определён аргумент <code>data</code>, то этот вызов эквивалентен последовательному вызову
<code>socket.write(data, encoding)</code> и <code>socket.end()</code>.

</p>
<h4>socket.destroy()<span><a class="mark" href="#all_socket_destroy" id="all_socket_destroy">#</a></span></h4>
<p>Закрывает сокет таким образом чтобы в нём больше не происходило ввода-вывода.
Необходимо только для закрытия соединения в случае серьёзных ошибок.

</p>
<h4>socket.pause()<span><a class="mark" href="#all_socket_pause" id="all_socket_pause">#</a></span></h4>
<p>Приостанавливает чтение данных. Т.е. события &apos;data&apos; не будут генерироваться.
Используется при приёме файлов.

</p>
<h4>socket.resume()<span><a class="mark" href="#all_socket_resume" id="all_socket_resume">#</a></span></h4>
<p>Возобновляет чтение данных после вызова pause().

</p>
<h4>socket.setTimeout(timeout, [callback])<span><a class="mark" href="#all_socket_settimeout_timeout_callback" id="all_socket_settimeout_timeout_callback">#</a></span></h4>
<p>Устанавливает таймаут в <code>timeout</code> миллисекунд бездействия сокета. По умолчанию
<code>net.Stream</code> не имеет таймаута.

</p>
<p>Если сокет не будет проявлять активности указанное количество миллисекунд будет
сгенерировано событие <code>&apos;timeout&apos;</code>, но само соединение не будет затронуто.
Пользователь должен самостоятельно вызвать <code>end()</code> или <code>destroy()</code> для закрытия сокета.

</p>
<p>Если в качестве <code>timeout</code> передан 0, существующий таймаут перестаёт действовать.

</p>
<p>Необязательный аргумент <code>callback</code> будет добавлен в качестве обработчика события <code>&apos;timeout&apos;</code>.

</p>
<h4>socket.setNoDelay(noDelay=true)<span><a class="mark" href="#all_socket_setnodelay_nodelay_true" id="all_socket_setnodelay_nodelay_true">#</a></span></h4>
<p>Выключает алгоритм Нагла. По умолчанию TCP-соединения используют алгоритм Нагла,
собирая данные в буфер перед отправкой. Установка noDelay приведёт к немедленной
отправке всех данных, передаваемых в <code>stream.write()</code>.

</p>
<h4>socket.setKeepAlive(enable=false, [initialDelay])<span><a class="mark" href="#all_socket_setkeepalive_enable_false_initialdelay" id="all_socket_setkeepalive_enable_false_initialdelay">#</a></span></h4>
<p>Включает/выключает функционал keep-alive, и дополнительно позволяет установить
начальную задержку после которой будет отправлен первый пакет проверки соединения
при неактивности. Значение <code>initialDelay</code> (в миллисекундах) означает интервал
между последним отправленным пакетом и первой проверкой соединения. Установка
<code>initialDelay</code> в 0 оставит в силе предыдущее значение.

</p>
<h4>socket.address()<span><a class="mark" href="#all_socket_address" id="all_socket_address">#</a></span></h4>
<p>Возвращает адрес, к которому привязан сокет. Удобно использовать, если выбор
адреса предоставляется системе. Возвращает объект с двумя свойствами:
<code>{&quot;address&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:2121}</code>.

</p>
<h4>socket.remoteAddress<span><a class="mark" href="#all_socket_remoteaddress" id="all_socket_remoteaddress">#</a></span></h4>
<p>Строковое представление удалённого IP адреса. Например, <code>&apos;74.125.127.100&apos;</code> или
<code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<p>Это свойство доступно только для соединений сервер-сервер.


</p>
<hr>
<p>Экземпляры <code>net.Stream</code> — экземпляры <code>EventEmitter</code> со следующими событиями:

</p>
<h4>Событие: &apos;connect&apos;<span><a class="mark" href="#all_connect" id="all_connect">#</a></span></h4>
<p><code>function () { }</code>

</p>
<p>Генерируется после успешной установки соединения. См. <code>connect()</code>.

</p>
<h4>Событие: &apos;data&apos;<span><a class="mark" href="#all_data_1" id="all_data_1">#</a></span></h4>
<p><code>function (data) { }</code>

</p>
<p>Генерируется при приёме данных. Аргумент <code>data</code> будет экземпляром <code>Buffer</code>
или <code>String</code>. Кодировка передаваемых данных устанавливается методом
<code>socket.setEncoding()</code>. (См. секцию о <code>потоках с возможностью чтения</code> для
более подробной информации.)

</p>
<h4>Событие: &apos;end&apos;<span><a class="mark" href="#all_end_1" id="all_end_1">#</a></span></h4>
<p><code>function () { }</code>

</p>
<p>Генерируется когда другой участник соединения посылает пакет FIN.

</p>
<p>По умолчанию (<code>allowHalfOpen == false</code>) сокет уничтожает свой файловый дескриптор
после завершения обработки очереди записи. Но если установить <code>allowHalfOpen == true</code>,
то поток не будет автоматически завершаться (<code>end()</code>), т.е. пользоввателю
требуется вручную вызвать <code>end()</code>.


</p>
<h4>Событие: &apos;timeout&apos;<span><a class="mark" href="#all_timeout" id="all_timeout">#</a></span></h4>
<p><code>function () { }</code>

</p>
<p>Генерируется если сокет долгое время не используется. Это просто уведомление
о длительной неактивности сокета. Пользователь должен сам закрыть соединение.

</p>
<p>См. также: <code>socket.setTimeout()</code>.


</p>
<h4>Событие: &apos;drain&apos;<span><a class="mark" href="#all_drain_1" id="all_drain_1">#</a></span></h4>
<p><code>function () { }</code>

</p>
<p>Генерируется когда буфер записи становится пустым (все данные, переданные в поток,
были отправлены получателю). Может быть использоваться для отправки файлов.

</p>
<h4>Событие: &apos;error&apos;<span><a class="mark" href="#all_error_1" id="all_error_1">#</a></span></h4>
<p><code>function (exception) { }</code>

</p>
<p>Генерируется при возникновении ошибки. Сразу после этого будет сгенерировано
событие <code>&apos;close&apos;</code>.

</p>
<h4>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_3" id="all_close_3">#</a></span></h4>
<p><code>function (had_error) { }</code>

</p>
<p>Генерируется один раз когда поток полностью закрывается. Аргумент had_error —
двоичное значение, устанавливаемое в true если поток был закрыт из за ошибки передачи.

</p>
<hr>
<h3>net.isIP<span><a class="mark" href="#all_net_isip" id="all_net_isip">#</a></span></h3>
<h4>net.isIP(input)<span><a class="mark" href="#all_net_isip_input" id="all_net_isip_input">#</a></span></h4>
<p>Проверяет. является ли <code>input</code> валидным IP адресом. Возвращает 0 для неверных строк,
4 для IPv4 адресов и 6 для IPv6 адресов.


</p>
<h4>net.isIPv4(input)<span><a class="mark" href="#all_net_isipv4_input" id="all_net_isipv4_input">#</a></span></h4>
<p>Возвращает <code>true</code> если <code>input</code> является IPv4 адресов, в осатльных случаях <code>false</code>.


</p>
<h4>net.isIPv6(input)<span><a class="mark" href="#all_net_isipv6_input" id="all_net_isipv6_input">#</a></span></h4>
<p>Возвращает <code>true</code> если <code>input</code> является IPv6 адресов, в осатльных случаях <code>false</code>.


</p>
<h1>UDP / Датаграммы<span><a class="mark" href="#all_udp" id="all_udp">#</a></span></h1>
<!-- name=dgram -->

<p>Сокеты для датаграмм доступны при включении <code>require(&apos;dgram&apos;)</code>.

</p>
<h2>dgram.createSocket(type, [callback])<span><a class="mark" href="#all_dgram_createsocket_type_callback" id="all_dgram_createsocket_type_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>type</code> String. Может принимать значения &apos;udp4&apos; или &apos;udp6&apos;</li>
<li><code>callback</code> Function. Функция назвачается обработчиков события <code>message</code> сокета. Необязательный параметр</li>
<li>Возвращает: Объект сокета</li>
</div></ul>
<p>Создаёт сокет для датаграмм заданного типа. Доступные типы: <code>udp4</code>, <code>udp6</code>.

</p>
<p>Call <code>socket.bind</code> if you want to receive datagrams. <code>socket.bind()</code> will bind
to the &quot;all interfaces&quot; address on a random port (it does the right thing for
both <code>udp4</code> and <code>udp6</code> sockets). You can then retrieve the address and port
with <code>socket.address().address</code> and <code>socket.address().port</code>.

</p>
<p>Принимает необязательную функцию, которая добавляется обработчиком событий <code>message</code>.

</p>
<h2>Класс: Socket<span><a class="mark" href="#all_socket" id="all_socket">#</a></span></h2>
<p>Класс сокета датаграмм инкапсулирует всю функциональность, которая для них доступна.
Должен быть инстанцирован с помощью метода <code>dgram.createSocket(type, [callback])</code>.

</p>
<h3>Событие: &apos;message&apos;<span><a class="mark" href="#all_message" id="all_message">#</a></span></h3>
<p><code>function (msg, rinfo) { }</code>

</p>
<p>Генерируется когда новая датаграмма доступна на сокете. <code>msg</code> это <code>Buffer</code>,
а <code>rinfo</code> это объект с информацией об адресе отправителя и количестве байт в датаграмме.

</p>
<h3>Событие: &apos;listening&apos;<span><a class="mark" href="#all_listening" id="all_listening">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генеритуется когда сокет начинает приём датаграмм. Для UDP-сокета это происходит
при создании. Сокеты Unix не начинают приём до вызова для них <code>bind()</code>.

</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_4" id="all_close_4">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется когда сокет закрывается с помощью <code>close()</code>.
События <code>message</code> на этом сокете больше не будут генерироваться.


</p>
<h3>dgram.send(buf, offset, length, path, [callback])<span><a class="mark" href="#all_dgram_send_buf_offset_length_path_callback" id="all_dgram_send_buf_offset_length_path_callback">#</a></span></h3>
<p>Для датаграмм на Unix-сокетах адрес назначения это путь в файловой системе.
Принимает необязательную функцию, которая будет вызвана после завершения
вызова <code>sendto</code> операционной системой. Пока идёт вызов, повторное использование
буфера <code>buf</code> небезопасно. Заметьте, что если сокет не привязан к пути в файловой
системе с помощью <code>bind()</code>, на нём невозможно получать сообщения.

</p>
<p>Пример отправки сообщения демону syslogd в OSX через Unix-сокет <code>/var/run/syslog</code>:

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;A message to log.&quot;);
var client = dgram.createSocket(&quot;unix_dgram&quot;);
client.send(message, 0, message.length, &quot;/var/run/syslog&quot;,
  function (err, bytes) {
    if (err) {
      throw err;
    }
    console.log(&quot;Wrote &quot; + bytes + &quot; bytes to socket.&quot;);
});</code></pre>
<h3>dgram.send(buf, offset, length, port, address, [callback])<span><a class="mark" href="#all_dgram_send_buf_offset_length_port_address_callback" id="all_dgram_send_buf_offset_length_port_address_callback">#</a></span></h3>
<p>Для UDP сокета, адрес назначения представляет port and IP-адрес. В качетве
аргумента <code>address</code> может быть передана строка, которая может быть разрешена
с помощью DNS. Принимает необязательную функцию, которая будет вызвана после
завершения разрешения DNS имени и когда буфер можно будет использовать заново.
Следует иметь в виду, что DNS запросы требуют времени, по крайне мере
до следующего витка цикола событий. Единственный способ узнать, что отправка
состоялась — использовать callback.

</p>
<p>Пример отправки UDP-пакета на произвольный порт <code>localhost</code>:

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Some bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;);
client.close();</code></pre>
<h3>dgram.bind(path)<span><a class="mark" href="#all_dgram_bind_path" id="all_dgram_bind_path">#</a></span></h3>
<p>Для Unix-сокета задаёт путь <code>path</code>. Имейте в виду, что клиент может вызывать
<code>send()</code> перед <code>bind()</code>, но данные не будут отправлены до вызова <code>bind()</code>.

</p>
<p>Пример сервера на Unix-сокете, который отправляет обратно поступающие сообщения:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);
var serverPath = &quot;/tmp/dgram_server_sock&quot;;
var server = dgram.createSocket(&quot;unix_dgram&quot;);

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;got: &quot; + msg + &quot; from &quot; + rinfo.address);
  server.send(msg, 0, msg.length, rinfo.address);
});

server.on(&quot;listening&quot;, function () {
  console.log(&quot;server listening &quot; + server.address().address);
})

server.bind(serverPath);</code></pre>
<p>Пример клиента на Unix-сокете, обращающегося к серверу:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);
var serverPath = &quot;/tmp/dgram_server_sock&quot;;
var clientPath = &quot;/tmp/dgram_client_sock&quot;;

var message = new Buffer(&quot;A message at &quot; + (new Date()));

var client = dgram.createSocket(&quot;unix_dgram&quot;);

client.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;got: &quot; + msg + &quot; from &quot; + rinfo.address);
});

client.on(&quot;listening&quot;, function () {
  console.log(&quot;client listening &quot; + client.address().address);
  client.send(message, 0, message.length, serverPath);
});

client.bind(clientPath);</code></pre>
<h3>dgram.bind(port, [address])<span><a class="mark" href="#all_dgram_bind_port_address" id="all_dgram_bind_port_address">#</a></span></h3>
<p>Для UDP сокетов задаёт порт <code>port</code> и необязательный адрес <code>address</code>
для прослушивания. Если <code>address</code> не задан, то будет предпринята попытка
прослушивания всех адресов.

</p>
<p>Пример UDP-сервера, слушающего на 41234 порту:

</p>
<pre><code>var dgram = require(&quot;dgram&quot;);

var server = dgram.createSocket(&quot;udp4&quot;);

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;server got: &quot; + msg + &quot; from &quot; +
    rinfo.address + &quot;:&quot; + rinfo.port);
});

server.on(&quot;listening&quot;, function () {
  var address = server.address();
  console.log(&quot;server listening &quot; +
      address.address + &quot;:&quot; + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>
<h3>dgram.close()<span><a class="mark" href="#all_dgram_close" id="all_dgram_close">#</a></span></h3>
<p>Закрывает сокет и прекращает приём данных.

</p>
<h3>dgram.address()<span><a class="mark" href="#all_dgram_address" id="all_dgram_address">#</a></span></h3>
<p>Возвращает объект с информацией об адресе, на который настроен сокет. Для UDP
сокетов этот объект содержит свойства <code>address</code> и <code>port</code>, а для Unix-сокетов
только свойство <code>address</code>.

</p>
<h3>dgram.setBroadcast(flag)<span><a class="mark" href="#all_dgram_setbroadcast_flag" id="all_dgram_setbroadcast_flag">#</a></span></h3>
<p>Устанавливает или сбрасывает опцию <code>SO_BROADCAST</code> сокета. если эта опция установлена,
то UDP пакеты могут оправляться по широковещательному адресу локального интерфейса.

</p>
<h3>dgram.setTTL(ttl)<span><a class="mark" href="#all_dgram_setttl_ttl" id="all_dgram_setttl_ttl">#</a></span></h3>
<p>Устанавливает опуцию <code>IP_TTL</code> сокета.  TTL означает &quot;время жизни&quot;, и его значение
определяет количество IP, сквозь которые может быть передан пакет. Каждый роутер
или шлюз на пути пакета уменьшают TTL. Как только он станет равным нуля, пакет уничтожится.
Изменение TTL может быть полезно для тестирования сети или широковещательной рассылки.

</p>
<p>Аргументом <code>setTTL()</code> является число от 1 до 255. По умолчанию на большинстве
систем ипользуется 64.

</p>
<h3>dgram.setMulticastTTL(ttl)<span><a class="mark" href="#all_dgram_setmulticastttl_ttl" id="all_dgram_setmulticastttl_ttl">#</a></span></h3>
<p>Устанавливает опцию <code>IP_MULTICAST_TTL</code> сокета.  TTL означает &quot;время жизни&quot;,
и его значение определяет количество IP, сквозь которые может быть передан пакет,
в данном случае при широковещательной рассылке. Каждый роутер или шлюз на пути пакета
уменьшают TTL. Как только он станет равным нуля, пакет уничтожится.

</p>
<p>Аргументом <code>setMulticastTTL()</code> является число от 0 до 255. По умолчанию на большинстве
систем ипользуется 64.

</p>
<h3>dgram.setMulticastLoopback(flag)<span><a class="mark" href="#all_dgram_setmulticastloopback_flag" id="all_dgram_setmulticastloopback_flag">#</a></span></h3>
<p>Устанавливает или очищает опцию <code>IP_MULTICAST_LOOP</code> сокета. Если эта опция установлена,
то широковещательные пакеты также будут получены на локальных сетевых интерфейсах.

</p>
<h3>dgram.addMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_addmembership_multicastaddress_multicastinterface" id="all_dgram_addmembership_multicastaddress_multicastinterface">#</a></span></h3>
<p>Указывает ядру вступить в широковещательную группу используя опцию <code>IP_ADD_MEMBERSHIP</code> сокета.

</p>
<p>Если <code>multicastInterface</code> не указан, то ОС будет пытаться вступить в группу,
используя каждый доступный сетевой интерфейс.

</p>
<h3>dgram.dropMembership(multicastAddress, [multicastInterface])<span><a class="mark" href="#all_dgram_dropmembership_multicastaddress_multicastinterface" id="all_dgram_dropmembership_multicastaddress_multicastinterface">#</a></span></h3>
<p>Противоположность <code>addMembership</code> &mdash; указывает ядру покинуть широковещательную
группу используя опцию <code>IP_DROP_MEMBERSHIP</code> сокета. В большинстве приложений
не обязательно вызывать эту функцию, так как ОС сделает это автоматически
при закрытии сокета.

</p>
<p>Если <code>multicastInterface</code> не указан, то ОС будет пытаться покинуть группу,
используя каждый доступный сетевой интерфейс.


</p>
<h2>DNS<span><a class="mark" href="#all_dns" id="all_dns">#</a></span></h2>
<p>Используйте <code>require(&apos;dns&apos;)</code> чтобы получить доступ к модулю.

</p>
<p>Пример, преобразующий в IP-адрес хост <code>&apos;www.google.com&apos;</code>
и преобразовывающий обратно полученные адреса.

</p>
<pre><code>var dns = require(&apos;dns&apos;);

dns.resolve4(&apos;www.google.com&apos;, function (err, addresses) {
  if (err) throw err;

  console.log(&apos;addresses: &apos; + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log(&apos;reverse for &apos; + a + &apos; failed: &apos; +
          err.message);
      } else {
        console.log(&apos;reverse for &apos; + a + &apos;: &apos; +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>
<h3>dns.lookup(domain, family=null, callback)<span><a class="mark" href="#all_dns_lookup_domain_family_null_callback" id="all_dns_lookup_domain_family_null_callback">#</a></span></h3>
<p>Разрешает домен (например <code>&apos;google.com&apos;</code>) в первую найденную A (для IPv4) или
AAAA (для IPv6) запись.

</p>
<p>Обработчик принимает аргументы <code>(err, address, family)</code>.  Аргумент <code>address</code> это строка, содержащая представление адреса в формате IPv4 или IPv6. Аргумент <code>family</code> это число 4 или 6 и обозначает семейство <code>address</code> (необязательно совпадает со значением, изначально переданным в <code>lookup</code>).


</p>
<h3>dns.resolve(domain, rrtype=&apos;A&apos;, callback)<span><a class="mark" href="#all_dns_resolve_domain_rrtype_a_callback" id="all_dns_resolve_domain_rrtype_a_callback">#</a></span></h3>
<p>Разрешает домен (например <code>&apos;google.com&apos;</code>) в массив записей типа, указанного в <code>rrtype</code>.
Допустимые значения rrtypes: <code>&apos;A&apos;</code> (адреса IPV4), <code>&apos;AAAA&apos;</code> (адреса IPV6),
<code>&apos;MX&apos;</code> (записи mail exchange), <code>&apos;TXT&apos;</code> (текстовые записи), <code>&apos;SRV&apos;</code> (записи SRV), <code>&apos;PTR&apos;</code> (используются для запросов домена по IP), <code>NS</code> (записи серверов имён)
и <code>CNAME</code> (канонические записи).

</p>
<p>Обработчик принимает аргументы <code>(err, addresses)</code>. Тип каждого элемента <code>addresses</code>
определяется типом записи и описан в документации по соответствующим методам запроса ниже.

</p>
<p>При ошибке <code>err</code> будет экземпляром объекта <code>Error</code>, где <code>err.errno</code> — один из кодов ошибки, перечисленных ниже, а <code>err.message</code> — строка, содержащая описание ошибки на английском.

</p>
<h3>dns.resolve4(domain, callback)<span><a class="mark" href="#all_dns_resolve4_domain_callback" id="all_dns_resolve4_domain_callback">#</a></span></h3>
<p>То же что <code>dns.resolve()</code>, но только для IPv4 адресов (записи типа A).
<code>addresses</code> это массив IPv4 адресов (например<br><code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>).

</p>
<h3>dns.resolve6(domain, callback)<span><a class="mark" href="#all_dns_resolve6_domain_callback" id="all_dns_resolve6_domain_callback">#</a></span></h3>
<p>То же что <code>dns.resolve4()</code> но только для IPv6 адресов (записи типа AAAA).

</p>
<h3>dns.resolveMx(domain, callback)<span><a class="mark" href="#all_dns_resolvemx_domain_callback" id="all_dns_resolvemx_domain_callback">#</a></span></h3>
<p>То же что <code>dns.resolve()</code>, но только для MX-записей.

</p>
<p><code>addresses</code> это массив MX записей, каждая с атрибутами <code>priority</code> и <code>exchange</code>
(например <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>).

</p>
<h3>dns.resolveTxt(domain, callback)<span><a class="mark" href="#all_dns_resolvetxt_domain_callback" id="all_dns_resolvetxt_domain_callback">#</a></span></h3>
<p>То же что <code>dns.resolve()</code>, но только для текстовых записей (тип записи <code>TXT</code>).
<code>addresses</code> это массив текстовых записей, доступных для домена <code>domain</code>
(например <code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>).

</p>
<h3>dns.resolveSrv(domain, callback)<span><a class="mark" href="#all_dns_resolvesrv_domain_callback" id="all_dns_resolvesrv_domain_callback">#</a></span></h3>
<p>То же, что <code>dns.resolve()</code>, но только для сервисных записей (записей типа <code>SRV</code>).
<code>addresses</code> это массив SRV записей, доступных для домена <code>domain</code>.
Свойства SRV записей: <code>priority</code>, <code>weight</code>, <code>port</code>, и <code>name</code>
(например, <code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>).

</p>
<h3>dns.reverse(ip, callback)<span><a class="mark" href="#all_dns_reverse_ip_callback" id="all_dns_reverse_ip_callback">#</a></span></h3>
<p>Обратно разрешает IP-адрес в массив доменных имён.

</p>
<p>Аргументы обработчика: <code>(err, domains)</code>.

</p>
<h3>dns.resolveNs(domain, callback)<span><a class="mark" href="#all_dns_resolvens_domain_callback" id="all_dns_resolvens_domain_callback">#</a></span></h3>
<p>То же, что <code>dns.resolve()</code>, но для записей серверов имён (<code>NS</code> записей).
<code>addresses</code> это массив NS записей, доступных для домена <code>domain</code>.
(например, <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<h3>dns.resolveCname(domain, callback)<span><a class="mark" href="#all_dns_resolvecname_domain_callback" id="all_dns_resolvecname_domain_callback">#</a></span></h3>
<p>То же, что <code>dns.resolve()</code>, но для канонических записей (<code>CNAME</code>
записей). <code>addresses</code> это массив канонических записей, доступных для домена
<code>domain</code> (например, <code>[&apos;bar.example.com&apos;]</code>).


</p>
<p>Если произошла ошибка, err будет ненулевым экземпляром объекта <code>Error</code>.

</p>
<p>Каждый запрос к DNS может вернуть код ошибки.

</p>
<ul>
<li><code>dns.TEMPFAIL</code>: таймаут, SERVFAIL или что-то подобное.</li>
<li><code>dns.PROTOCOL</code>: получен повреждённый ответ.</li>
<li><code>dns.NXDOMAIN</code>: домен не существует.</li>
<li><code>dns.NODATA</code>: домен существует, но нет данных требуемого типа.</li>
<li><code>dns.NOMEM</code>: при обработке закончилась память.</li>
<li><code>dns.BADQUERY</code>: запрос неверно сформирован.</li>
</ul>
<h2>HTTP<span><a class="mark" href="#all_http" id="all_http">#</a></span></h2>
<p>Для использования клиента и сервера HTTP необходимо подключить
соответствующий модуль с помощью <code>require(&apos;http&apos;)</code>.

</p>
<p>Интерфейс HTTP спроектирован в Node таким образом, чтобы поддерживать многие
возможности протокола, которые традиционно было довольно сложно использовать.
В частности, большие сообщения с возможным chunk-encoding. Интерфейс никогда
не сохраняет в буфере целиком запрос или ответ, давая пользователю возможность
принимать и отправлять данные в потоковом режиме.

</p>
<p>Заголовки сообщения HTTP представлены примерно таким объектом:

</p>
<pre><code>{ &apos;content-length&apos;: &apos;123&apos;,
  &apos;content-type&apos;: &apos;text/plain&apos;,
  &apos;connection&apos;: &apos;keep-alive&apos;,
  &apos;accept&apos;: &apos;*/*&apos; }</code></pre>
<p>Ключи приводятся к нижнему регистру. Значения не изменяются.

</p>
<p>Для поддержки всего спектра возможных применений HTTP, соответствующее API
в Node довольно низкоуровневое. Оно основано на потоках и передаче сообщений.
Node разбирает HTTP-сообщение на заголовки и тело, остальное должен сделать
программист.

</p>
<h2>http.Server<span><a class="mark" href="#all_http_server" id="all_http_server">#</a></span></h2>
<p>Это <code>EventEmitter</code> со следующими событиями:

</p>
<h3>Событие: &apos;request&apos;<span><a class="mark" href="#all_request" id="all_request">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p>Генерируется каждый раз при получении запроса. Заметьте, что в течении одного
соединения может происходить несколько запросов (в случае keep-alive соединения).
Объект <code>request</code> — экземпляр <code>http.ServerRequest</code>,
объект <code>response</code> — экземпляр <code>http.ServerResponse</code>.

</p>
<h3>Событие: &apos;connection&apos;<span><a class="mark" href="#all_connection_1" id="all_connection_1">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<p>Генерируется при установке нового HTTP-соединения. <code>socket</code> — объект типа <code>net.Socket</code>.
Обычно пользователи не используют это событие. Объект потока <code>socket</code> также можно
найти в свойстве объекта запроса <code>request.connection</code>.

</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_5" id="all_close_5">#</a></span></h3>
<p><code>function (errno) { }</code>

</p>
<p>Генерируется при завершении работы сервера.

</p>
<h3>Событие: &apos;checkContinue&apos;<span><a class="mark" href="#all_checkcontinue" id="all_checkcontinue">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p>Событие наступает кажды раз при получении заголовка <code>&apos;Expect: 100&apos;</code>.
Если для этого события не назначен ни один обработчик, то сервер автоматически
отвечает <code>&apos;100 Continue&apos;</code>.

</p>
<p>Обработка этого события подразумевает вызов <code>response.writeContinue</code> если клиент
должен продолжить отправку тела запроса, или генерацию другого HTTP запроса
(например <code>&apos;400 Bad Request&apos;</code>) если клиент не должен этого делать.

</p>
<p>Имейте в виду, что если это событие наступило и было обработано, то событие
<code>request</code> не наступает.

</p>
<h3>Событие: &apos;upgrade&apos;<span><a class="mark" href="#all_upgrade" id="all_upgrade">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<p>Генерируется каждый раз когда клиент запрашивает апгрейд соединения
до защищённого (см. RFC 2817). Если это событие никак не обрабатывается
соединение для которого запрошен апгрейд будет закрыто.

</p>
<ul>
<li><code>request</code> — аргументы для HTTP запроса, как в событии <code>&apos;request&apos;</code>.</li>
<li><code>socket</code> — сетевой сокет между сервером и клиентом.</li>
<li><code>head</code> — экземпляр Buffer, первый пакет защищенного потока, может быть пустым.</li>
</ul>
<p>После генерации этого события, у объекта <code>server</code> не будет обработчика события
<code>data</code>, и программисту нужно назначить его заново чтобы обрабатывать данные,
получаемые этим соединением.

</p>
<h3>Событие: &apos;clientError&apos;<span><a class="mark" href="#all_clienterror" id="all_clienterror">#</a></span></h3>
<p><code>function (exception) { }</code>

</p>
<p>Если соединение с клиентом генерирует событие <code>&apos;error&apos;</code> — оно поднимается сюда.

</p>
<h3>http.createServer([requestListener])<span><a class="mark" href="#all_http_createserver_requestlistener" id="all_http_createserver_requestlistener">#</a></span></h3>
<p>Возвращает новый объект web-сервера.

</p>
<p>Функция <code>requestListener</code> автоматически добавляется к событию <code>&apos;request&apos;</code> сервера.

</p>
<h3>server.listen(port, [hostname], [callback])<span><a class="mark" href="#all_server_listen_port_hostname_callback" id="all_server_listen_port_hostname_callback">#</a></span></h3>
<p>Начинает приём соединений на указанном порту и имени хоста. Если имя хоста не указано,
сервер будет принимать соединения на любой IPv4-адрес машины (<code>INADDR_ANY</code>).

</p>
<p>Чтобы слушать unix-сокет, передайте имя файла вместо порта и имени хоста.

</p>
<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с портом.


</p>
<h3>server.listen(path, [callback])<span><a class="mark" href="#all_server_listen_path_callback_1" id="all_server_listen_path_callback_1">#</a></span></h3>
<p>Начинает слушать unix-сокет с заданным путём <code>path</code>.

</p>
<p>Эта функция асинхронна. Функция, переданная последним параметром <code>callback</code>
будет вызвана когда сервер будет связан с сокетом.


</p>
<h3>server.close()<span><a class="mark" href="#all_server_close_2" id="all_server_close_2">#</a></span></h3>
<p>Прекращает приём новых соединений сервером.


</p>
<h2>http.ServerRequest<span><a class="mark" href="#all_http_serverrequest" id="all_http_serverrequest">#</a></span></h2>
<p>Этот объект создаётся автоматически HTTP-сервером (не пользователем)
и передаётся первым аргументом обработчику события <code>&apos;request&apos;</code>.

</p>
<p>Это <code>EventEmitter</code> со следующими событиями:

</p>
<h3>Событие: &apos;data&apos;<span><a class="mark" href="#all_data_2" id="all_data_2">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<p>Генерируется при получении части тела сообщения.
Пример: Порция данных передаётся единственных аргументов, декодируется в соответствии
с transfer-encoding. Эта порция представляется строкой, кодировку которой
можно установить с помощью <code>request.setEncoding()</code>.

</p>
<h3>Событие: &apos;end&apos;<span><a class="mark" href="#all_end_2" id="all_end_2">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется строго один раз для каждого сообщения. После этого
события не будут генерироваться другие события типа <code>&apos;data&apos;</code>.


</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_6" id="all_close_6">#</a></span></h3>
<p><code>function (err) { }</code>

</p>
<p>Указывает, что соединение было разорвано до вызова <code>response.end()</code>
или возможности отправить данные.

</p>
<p>Аргумент <code>err</code> всегда присутствует и указывает на причину разрыва соединения:

</p>
<p><code>err.code === &apos;timeout&apos;</code> указывает на превышение таймаута соединения.
Одной из причин может быть то, что все входящие подключения имеют таймаут по умолчанию 2 минуты.

</p>
<p><code>err.code === &apos;aborted&apos;</code> означает, что клиент преждевременно закрыл соединение.

</p>
<p>Как и событие <code>&apos;end&apos;</code>, это событие может наступить только один раз за соединение
и после этого события не будут генерироваться другие события типа <code>&apos;data&apos;</code>.

</p>
<p>Примечание: <code>&apos;close&apos;</code> может случиться до <code>&apos;end&apos;</code>, но не наоборот.


</p>
<h3>request.method<span><a class="mark" href="#all_request_method" id="all_request_method">#</a></span></h3>
<p>Метод запроса в виде строки. Только для чтения. Пример <code>&apos;GET&apos;</code> или <code>&apos;DELETE&apos;</code>.

</p>
<h3>request.url<span><a class="mark" href="#all_request_url" id="all_request_url">#</a></span></h3>
<p>Строка с URL запроса. Здесь содержится URL в том виде, в котором он задан
в самом HTTP-запросе. Если запрос выглядит так:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Тогда значением <code>request.url</code> будет:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<p>Если вы хотите разделить URL на составные части, вы можете использовать
<code>require(&apos;url&apos;).parse(request.url)</code>. Пример:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<p>Если вам нужно извлечь параметры из строки запроса, можно использовать функцию
<code>require(&apos;querystring&apos;).parse</code>, или передать <code>true</code> в качестве второго аргумента
<code>require(&apos;url&apos;).parse</code>. Пример:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>request.headers<span><a class="mark" href="#all_request_headers" id="all_request_headers">#</a></span></h3>
<p>Заголовки запроса. Только для чтения.

</p>
<h3>request.trailers<span><a class="mark" href="#all_request_trailers" id="all_request_trailers">#</a></span></h3>
<p>HTTP trailers (если есть). Только для чтения.
Доступны тольк после наступления события <code>&apos;end&apos;</code>.

</p>
<h3>request.httpVersion<span><a class="mark" href="#all_request_httpversion" id="all_request_httpversion">#</a></span></h3>
<p>Версия протокола HTTP в виде строки. Только чтение. Пример: <code>&apos;1.1&apos;</code>, <code>&apos;1.0&apos;</code>.
Также <code>request.httpVersionMajor</code> содержит первое число и <code>request.httpVersionMinor</code> — второе.


</p>
<h3>request.setEncoding(encoding=null)<span><a class="mark" href="#all_request_setencoding_encoding_null" id="all_request_setencoding_encoding_null">#</a></span></h3>
<p>Задаёт кодировку тела запроса. Либо <code>&apos;utf8&apos;</code>, либо <code>&apos;binary&apos;</code>. По умолчанию
принимает значение <code>null</code>, что означает что в обработчик события <code>&apos;data&apos;</code>
поступает буфер.


</p>
<h3>request.pause()<span><a class="mark" href="#all_request_pause" id="all_request_pause">#</a></span></h3>
<p>Прекращает генерирование событий запросом.
Можно использовать для ускорения закачки файла.


</p>
<h3>request.resume()<span><a class="mark" href="#all_request_resume" id="all_request_resume">#</a></span></h3>
<p>Возобновляет генерирование событий запросом

</p>
<h3>request.connection<span><a class="mark" href="#all_request_connection" id="all_request_connection">#</a></span></h3>
<p>Объект соединения, экземпляр <code>net.Socket</code>.

</p>
<p>При поддержке HTTPS достоверность и содержимое сертификата могут быть проверены
с помощью методов <code>verifyPeer()</code> и <code>getPeerCertificate()</code>
объекта <code>request.connection</code> сервера.



</p>
<h2>http.ServerResponse<span><a class="mark" href="#all_http_serverresponse" id="all_http_serverresponse">#</a></span></h2>
<p>Этот объект создаётся внутри HTTP-сервера — не пользователем. Он передаётся
вторым параметром в обработчик события <code>&apos;request&apos;</code> и является <code>потоком с возможностью записи</code>.

</p>
<h3>response.writeContinue()<span><a class="mark" href="#all_response_writecontinue" id="all_response_writecontinue">#</a></span></h3>
<p>Отправдяет клиенту сообщение <code>&apos;HTTP/1.1 100 Continue&apos;</code>, которое разрешает отправку тела запроса.
См. описанеи события <a href="#event_checkContinue_">&apos;checkContinue&apos;</a> объекта <code>http.Server</code>.

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a class="mark" href="#all_response_writehead_statuscode_reasonphrase_headers" id="all_response_writehead_statuscode_reasonphrase_headers">#</a></span></h3>
<p>Отправляет заголовки ответа клиенту. <code>statusCode</code> это три цифры кода статуса HTTP,
например 404. Последний аргумент, <code>headers</code>, это заголовки ответа. Также вторым
аргументом можно передать фразу <code>reasonPhrase</code>.

</p>
<p>Пример:

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<p>Этот метод должен быть вызван только однажды для каждого сообщения
и должен быть вызван до <code>response.end()</code>.

</p>
<p>Если вы вызываете <code>response.write()</code> или <code>response.end()</code> перед <code>response.writeHead()</code>,
то эта функция будет вызвана автоматически со всеми неявно отправленными заголовками.

</p>
<p>Примечание: Content-Length содержит количество байт, а не символов. Пример выше
корректен потому, что строка <code>&apos;hello world&apos;</code> содержит только однобайтные символы.
Если тело сообщения содержит многобайтные символы, то необходимо использовать
<code>Buffer.byteLength()</code> для определения количества использованных для кодирования байтов.
Node не проверяет, совпадает ли значение заголовка Content-Length и размер тела принятого ответа.

</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode" id="all_response_statuscode">#</a></span></h3>
<p>При использовании неявных заголовков (без явного вызова <code>response.writeHead()</code>)
это свойство устанавливает код ответа, который будет послан клиенту
при отправке заголовков.

</p>
<p>Пример:

</p>
<pre><code>response.statusCode = 404;</code></pre>
<p>Это свойство отражает код статуса ответа после отправки заголовков.

</p>
<h3>response.setHeader(name, value)<span><a class="mark" href="#all_response_setheader_name_value" id="all_response_setheader_name_value">#</a></span></h3>
<p>Устанавливает неявный заголовок. Если этот заголовок уже существует в очереди
для отправки, то его значение будет переобпределено новым. если вы хотите
установить несколько заголовков с одинаковым именем, используйте массив строк.

</p>
<p>Пример:

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>или

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.getHeader(name)<span><a class="mark" href="#all_response_getheader_name" id="all_response_getheader_name">#</a></span></h3>
<p>Возвращает значение заголовка, который был поставлен в очередь, но ещё не был
отправлен клиенту. Обратите внимание, что имя заголовка регистро независимо.
Этот метод может быть вызван только до явной отправки заголовков.

</p>
<p>Пример:

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a class="mark" href="#all_response_removeheader_name" id="all_response_removeheader_name">#</a></span></h3>
<p>Удаляет заголовок из очередь для отправки.

</p>
<p>Пример:

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_response_write_chunk_encoding_utf8" id="all_response_write_chunk_encoding_utf8">#</a></span></h3>
<p>Если этот метод вызывается, а <code>response.writeHead()</code> ещё не был вызван,
то происходит выключение неявного режима отправки заголовков и все заголовки
из очереди немедленно отправляются клиенту.

</p>
<p>Данный метод отправляет часть тела ответа. Метод может быть вызван несколько раз
для отправки последующих частей тела ответа.

</p>
<p>Аргумент <code>chunk</code> может быть буфером или строкой. Если <code>chunk</code> это строка, то
бойвторой параметр указывает в какой кодировке отправлять её в поток.
По умолчанию encoding принимает значение &apos;utf8&apos;.

</p>
<p><strong>Замечание:</strong> Это необработанное тело HTTP-ответа и не имеет отношения к более
высокоуровневым вещам вроде multi-part encoding, которые тоже могут использоваться.

</p>
<p>После первого вызова <code>response.write()</code> клиенту будет отправлены заголовки
и первая часть тела сообщения. После второго вызова <code>response.write()</code> Node
предполагает что вы начинаете потоковую передачу данных и отправляет часть
тела отдельно. Таким образом, данные буферизуются только до первой части тела ответа.

</p>
<h3>response.addTrailers(headers)<span><a class="mark" href="#all_response_addtrailers_headers" id="all_response_addtrailers_headers">#</a></span></h3>
<p>Этот метод добавляет завершающие заголовки HTTP, следующие после тела ответа.

</p>
<p>Эти заголовки могут быть использованы <em>*только</em> в случае использование ответом 
<code>chunked encoding</code>; в противном случае они будут проигнорированы.

</p>
<p>Имейте в виду, что протокол HTTP требует указания заголовка <code>Trailer</code>
в случае использования HTTP trailers, например:

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;TraceInfo&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a class="mark" href="#all_response_end_data_encoding" id="all_response_end_data_encoding">#</a></span></h3>
<p>Этот метод отправляет серверу сигнал что все заголовки и тело ответа отправлены;
сервер должен считать это сообщение законченным. Метод <code>response.end()</code>
<strong>ДОЛЖЕН</strong> быть вызван при каждом ответе.

</p>
<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>response.write(data, encoding)</code> и <code>response.end()</code>.


</p>
<h2>http.request(options, callback)<span><a class="mark" href="#all_http_request_options_callback" id="all_http_request_options_callback">#</a></span></h2>
<p>Node поддерживает множественные соединения для выполнения HTTP запросов.
Эта функция позволяет легко создавать их.

</p>
<p>Параметры <code>options</code>:

</p>
<ul>
<li><code>host</code>: Доменное имя или IP адрес для запроса.</li>
<li><code>port</code>: Порт на удалённом сервере.</li>
<li><code>method</code>: Строка, определяющая HTTP метод. возможные значения:
<code>&apos;GET&apos;</code> (по умолчанию), <code>&apos;POST&apos;</code>, <code>&apos;PUT&apos;</code> и <code>&apos;DELETE&apos;</code>.</li>
<li><code>path</code>: HTTP-путь, может включать строку запроса при необходимости.
 Например <code>&apos;/index.html?page=12&apos;</code>.</li>
<li><code>headers</code>: Объект со списком дополнительных заголовков.</li>
<li><code>agent</code>: Задаёт поведения для объекта <code>Agent</code>. Допустимые значения:<ul>
<li><code>undefined</code> (default): использовать стандартный <code>Agent</code> для этого хоста и порта.</li>
<li>объекта <code>Agent</code>: использовать переданный <code>Agent</code>.</li>
<li><code>false</code>: создать новый <code>Agent</code> для этого хоста и порта. Этот <code>Agent</code> не будет переиспользоваться.</li>
</ul>
</li>
</ul>
<p><code>http.request()</code> возвращает объект класса <code>http.ClientRequest</code>, являющийся
потоком с возможностью записи. Если вы хотите отпавить файл с помощью POST-запроса,
вам нужно записать его в этот объект.

</p>
<p>Пример подключения к <code>google.com</code>:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/upload&apos;,
  method: &apos;POST&apos;
};

var req = http.request(options, function(res) {
  console.log(&apos;STATUS: &apos; + res.statusCode);
  console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));
  res.setEncoding(&apos;utf8&apos;);
  res.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

req.on(&apos;error&apos;, function(e) {
  console.log(&apos;problem with request: &apos; + e.message);
});

// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<p>Обратите внимание на вызов <code>req.end()</code> в примере. Используя <code>http.request()</code>
вы должны вызвать <code>req.end()</code>, иначе всё что вы делали до этого с объектом
не произойдёт и никакие данные не будут отправлены.

</p>
<p>В случае возникновение ошибки (на уровне разрешения DNS имени, на уровне TCP
или на уровне обработки тела HTTP запроса) будет сгенерировано событие <code>&apos;error&apos;</code>
объекта запроса <code>req</code>.

</p>
<p>Нужно иметь в виду следующие особенности реализации:

</p>
<ul>
<li><p>Отправка заголовка &apos;Connection: keep-alive&apos; сообщает Node о необходимости
сохранять соединения для последующих запросов.</p>
</li>
<li><p>Отправка заголовка <code>&apos;Content-length&apos;</code> отключит &apos;chunked encoding&apos;.</p>
</li>
<li><p>Отправка заголовка &apos;Expect&apos; немедленно приведёт к отправке всех заголовков.
Обычно, при отправке &apos;Expect: 100-continue&apos;, вы должны установить таймаут
и установить обработчик события <code>continue</code>.
См. <a href="http://tools.ietf.org/html/rfc2616#section-8.2.3">RFC2616 Section 8.2.3</a>
для дополнительной информации.</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a class="mark" href="#all_http_get_options_callback" id="all_http_get_options_callback">#</a></span></h2>
<p>Так как большинство запросов являются GET запросами без тела, Node содержит этот дополнительный метод.
Единственное отличие от метода <code>http.request()</code> заключается в использовании
запроса типа GET и автоматическом вызове <code>req.end()</code>.

</p>
<p>Пример:

</p>
<pre><code>var options = {
  host: &apos;www.google.com&apos;,
  port: 80,
  path: &apos;/index.html&apos;
};

http.get(options, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h3>Событие: &apos;upgrade&apos;<span><a class="mark" href="#all_upgrade_1" id="all_upgrade_1">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<p>Генерируется каждый раз когда сервер отвечает на запрос предложением улучшить
соединение до безопасного. Если это событие не обрабатывается, клиент
при получении заголовка <code>upgrade</code> будет закрывать соединение.

</p>
<p>Пример клиента и сервера, который демонстрирует использование события <code>upgrade</code> для <code>http.getAgent</code>:

</p>
<pre><code>var http = require(&apos;http&apos;);
var net = require(&apos;net&apos;);

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
  res.end(&apos;okay&apos;);
});
srv.on(&apos;upgrade&apos;, function(req, socket, upgradeHead) {
  socket.write(&apos;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&apos; +
               &apos;Upgrade: WebSocket\r\n&apos; +
               &apos;Connection: Upgrade\r\n&apos; +
               &apos;\r\n\r\n&apos;);

  socket.ondata = function(data, start, end) {
    socket.write(data.toString(&apos;utf8&apos;, start, end), &apos;utf8&apos;); // echo back
  };
});

// now that server is running
srv.listen(1337, &apos;127.0.0.1&apos;, function() {

  // make a request
  var agent = http.getAgent(&apos;127.0.0.1&apos;, 1337);

  var options = {
    agent: agent,
    port: 1337,
    host: &apos;127.0.0.1&apos;,
    headers: {
      &apos;Connection&apos;: &apos;Upgrade&apos;,
      &apos;Upgrade&apos;: &apos;websocket&apos;
    }
  };

  var req = http.request(options);
  req.end();

  agent.on(&apos;upgrade&apos;, function(res, socket, upgradeHead) {
    console.log(&apos;got upgraded!&apos;);
    socket.end();
    process.exit(0);
  });
});</code></pre>
<h2>http.Agent<span><a class="mark" href="#all_http_agent" id="all_http_agent">#</a></span></h2>
<h2>http.getAgent(host, port)<span><a class="mark" href="#all_http_getagent_host_port" id="all_http_getagent_host_port">#</a></span></h2>
<p><code>http.request()</code> использует специального <code>Агента</code> для обработки множества
соединений с HTTP сервером. Обычно объекты класса <code>Agent</code> не должны быть доступны
в пользовательском коде, однако иногда это может быть полезно. Метод <code>http.getAgent()</code>
позволяет получить доступ к этому объекту.

</p>
<h3>agent.maxSockets<span><a class="mark" href="#all_agent_maxsockets" id="all_agent_maxsockets">#</a></span></h3>
<p>По умолчанию равно 5. Определяет максимальное количество сокетов,
одновременно открытых клиентом.

</p>
<h3>agent.sockets<span><a class="mark" href="#all_agent_sockets" id="all_agent_sockets">#</a></span></h3>
<p>Массив сокетов, используемых в данный момент. Не изменяйте этот массив.

</p>
<h3>agent.queue<span><a class="mark" href="#all_agent_queue" id="all_agent_queue">#</a></span></h3>
<p>Очередь запросов, ожидающих отправки.


</p>
<h2>http.ClientRequest<span><a class="mark" href="#all_http_clientrequest" id="all_http_clientrequest">#</a></span></h2>
<p>Объект создаётся внутри Node и возвращается методом <code>http.request()</code>.
Он представляет собой <em>незаконченный запрос</em>, заголовки которого ещё не отправлены.
Заголовки могут быть изменены с помощью методов <code>setHeader(name, value)</code>,
<code>getHeader(name)</code> и <code>removeHeader(name)</code>. Установленные заголовки посылаются клиенту
с первым фрагментом данных или при закрытии соединения.

</p>
<p>Чтобы получить ответ, добавьте обработчик событию <code>&apos;response&apos;</code> объекта запроса.
Событие <code>&apos;response&apos;</code> будет сгенерировано объектом запроса при получении
заголовков ответа. Обработчик события <code>&apos;response&apos;</code> выполняется с одним
аргументом — экземпляром <code>http.ClientResponse</code>.

</p>
<p>Во время события <code>&apos;response&apos;</code> можно добавлять обработчики к объекту ответа;
в частности, чтобы получать части тела ответа надо добавить обработчик
событию <code>&apos;data&apos;</code>. Заметьте что обработчик события <code>&apos;response&apos;</code> вызывается
до того, как будут получены части тела ответа, поэтому не надо беспокоиться,
что первая часть тела будет пропущена. Если обработчик <code>&apos;data&apos;</code> добавляется
во время события <code>&apos;response&apos;</code>, то всё тело ответа будет получено наверняка.


</p>
<pre><code>// Good
request.on(&apos;response&apos;, function (response) {
  response.on(&apos;data&apos;, function (chunk) {
    console.log(&apos;BODY: &apos; + chunk);
  });
});

// Bad - misses all or part of the body
request.on(&apos;response&apos;, function (response) {
  setTimeout(function () {
    response.on(&apos;data&apos;, function (chunk) {
      console.log(&apos;BODY: &apos; + chunk);
    });
  }, 10);
});</code></pre>
<p>Это <code>поток с возможностью записи</code>.

</p>
<p>Это экземпляр <code>EventEmitter</code> со следующими событиями:

</p>
<h3>Событие: &apos;continue&apos;<span><a class="mark" href="#all_continue" id="all_continue">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется когда сервер посылайет HTTP ответ &apos;100 Continue&apos; HTTP,
обычно если запрос содержит заголовок &apos;Expect: 100-continue&apos;.
Эта инструкция говорит клиенту о необходимости начать передачу тела запроса.


</p>
<h3>Событие: &apos;response&apos;<span><a class="mark" href="#all_response" id="all_response">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p>Генерируется когда на запрос приходит ответ. Это событие генерируется только
один раз. Аргументом обработчика <code>response</code> будет экземпляр <code>http.ClientResponse</code>.


</p>
<h3>request.write(chunk, encoding=&apos;utf8&apos;)<span><a class="mark" href="#all_request_write_chunk_encoding_utf8" id="all_request_write_chunk_encoding_utf8">#</a></span></h3>
<p>Отправляет часть тела запроса. Вызывая этот метод несколько раз, пользователь
может отправлять тело ответа серверу в потоковом режиме — в таком случае
предпочтительно добавлять в заголовки <code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code>
при создании запроса.

</p>
<p>Аргумент <code>chunk</code> должен быть массивом чисел или строкой.

</p>
<p>Аргумент <code>encoding</code> необязателен и имеет значение только если <code>chunk</code> строка.

</p>
<h3>request.end([data], [encoding])<span><a class="mark" href="#all_request_end_data_encoding" id="all_request_end_data_encoding">#</a></span></h3>
<p>Завершает отправку запроса. Если какие то части тела запроса ещё не были
отправлены, они отправляются. Если запрос разбит на части, будет послана
завершающая последовательность <code>&apos;0\r\n\r\n&apos;</code>.

</p>
<p>Если задан аргумент <code>data</code>, то этот вызов эквивалентен поледовательному вызову
<code>request.write(data, encoding)</code> и <code>request.end()</code>.

</p>
<h3>request.abort()<span><a class="mark" href="#all_request_abort" id="all_request_abort">#</a></span></h3>
<p>Прерывает запрос. (Добавлено в версии v0.3.8)


</p>
<h2>http.ClientResponse<span><a class="mark" href="#all_http_clientresponse" id="all_http_clientresponse">#</a></span></h2>
<p>Этот объект создаётся при создании запроса с помощью <code>http.request()</code>.
Он передаётся обработчику события <code>&apos;response&apos;</code> объекта запроса.

</p>
<p>Объект ответа — <code>поток с возможностью чтения</code>.

</p>
<h3>Событие: &apos;data&apos;<span><a class="mark" href="#all_data_3" id="all_data_3">#</a></span></h3>
<p><code>function (chunk) { }</code>

</p>
<p>Часть тела сообщения передаётся обработчику в качестве единственного аргуметна.
Строка уже преобразована из кодировки с помощью которой осуществлялась передача.
Часть тела сообщения передаётся обработчику в виде строки. Кодировка тела
сообщения задаётся <code>response.setBodyEncoding()</code>.

</p>
<h3>Событие: &apos;end&apos;<span><a class="mark" href="#all_end_3" id="all_end_3">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p>Генерируется только однажды для каждого сообщения. Обработчик вызывается
без аргументов. После этого сообщение не будет генерировать никаких событий.

</p>
<h3>Событие: &apos;close&apos;<span><a class="mark" href="#all_close_7" id="all_close_7">#</a></span></h3>
<p><code>function (err) { }</code>

</p>
<p>Указывает на то, что соединения было закрыто до генерации события <code>end</code>.
См. описание события <code>&apos;close&apos;</code> для <a href="#http.ServerRequest">http.ServerRequest</a>.


</p>
<h3>response.statusCode<span><a class="mark" href="#all_response_statuscode_1" id="all_response_statuscode_1">#</a></span></h3>
<p>Код статуса HTTP из трёх цифр, например <code>404</code>.

</p>
<h3>response.httpVersion<span><a class="mark" href="#all_response_httpversion" id="all_response_httpversion">#</a></span></h3>
<p>Версия HTTP для текущего соединения. Скорее всего либо <code>&apos;1.1&apos;</code>, либо <code>&apos;1.0&apos;</code>.
Также <code>response.httpVersionMajor</code> — первая цифра версии,
а <code>response.httpVersionMinor</code> — вторая.


</p>
<h3>response.headers<span><a class="mark" href="#all_response_headers" id="all_response_headers">#</a></span></h3>
<p>Заголовки ответа.

</p>
<h3>response.trailers<span><a class="mark" href="#all_response_trailers" id="all_response_trailers">#</a></span></h3>
<p>См. описание выше.

</p>
<h3>response.setEncoding(encoding=null)<span><a class="mark" href="#all_response_setencoding_encoding_null" id="all_response_setencoding_encoding_null">#</a></span></h3>
<p>Задаёт кодировку тела ответа. Может принимать значения <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>
или <code>&apos;base64&apos;</code>. По умолчанию используется <code>null</code>, что означает что в обработчик
события <code>&apos;data&apos;</code> поступает буфер.

</p>
<h3>response.pause()<span><a class="mark" href="#all_response_pause" id="all_response_pause">#</a></span></h3>
<p>Приостанавливает генерацию событий ответом.
Можно использовать для ускорения закачки файла.

</p>
<h3>response.resume()<span><a class="mark" href="#all_response_resume" id="all_response_resume">#</a></span></h3>
<p>Возобновляет генерацию событий ответом.


</p>
<h2>HTTPS<span><a class="mark" href="#all_https" id="all_https">#</a></span></h2>
<p>HTTPS представляет из себя HTTP протокол с использованием TLS/SSL канала
для передачи данных. Node включает отдельный модуль для HTTP.

</p>
<h2>https.Server<span><a class="mark" href="#all_https_server" id="all_https_server">#</a></span></h2>
<p>Этот класс является потомком <code>tls.Server</code> и генерирует те же события, что и <code>http.Server</code>.
См. описание <code>http.Server</code> для более подробной информации.

</p>
<h2>https.createServer(options, [requestListener])<span><a class="mark" href="#all_https_createserver_options_requestlistener" id="all_https_createserver_options_requestlistener">#</a></span></h2>
<p>Возвращает новый объект HTTPS веб сервера. Параметры <code>options</code> такие же,
как у <code>tls.createServer()</code>. Функция <code>requestListener</code> будет автоматически
добавлена в качестве обработчика события <code>&apos;request&apos;</code>.

</p>
<p>Пример:

</p>
<pre><code>// curl -k https://localhost:8000/
var https = require(&apos;https&apos;);
var fs = require(&apos;fs&apos;);

var options = {
  key: fs.readFileSync(&apos;test/fixtures/keys/agent2-key.pem&apos;),
  cert: fs.readFileSync(&apos;test/fixtures/keys/agent2-cert.pem&apos;)
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<h2>https.request(options, callback)<span><a class="mark" href="#all_https_request_options_callback" id="all_https_request_options_callback">#</a></span></h2>
<p>Создаёт запрос к защищённому серверу.
Параметры аналогичны параметрам <code>http.request()</code>.

</p>
<p>Пример:

</p>
<pre><code>var https = require(&apos;https&apos;);

var options = {
  host: &apos;encrypted.google.com&apos;,
  port: 443,
  path: &apos;/&apos;,
  method: &apos;GET&apos;
};

var req = https.request(options, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&apos;data&apos;, function(d) {
    process.stdout.write(d);
  });
});
req.end();

req.on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<p>Параметры <code>options</code>:

</p>
<ul>
<li><code>host</code>: Доменное имя или IP адрес для запроса. По умолчанию <code>&apos;localhost&apos;</code>.</li>
<li><code>port</code>: Порт на удалённом сервере. По умолчанию 443.</li>
<li><code>method</code>: Строка, определяющая HTTP метод. возможные значения:
<code>&apos;GET&apos;</code> (по умолчанию), <code>&apos;POST&apos;</code>, <code>&apos;PUT&apos;</code> и <code>&apos;DELETE&apos;</code>.</li>
<li><code>path</code>: HTTP-путь, может включать строку запроса при необходимости.
По умолчанию <code>&apos;/&apos;</code>.</li>
<li>key: Приватный ключ для SSL. По умолчанию <code>null</code>.</li>
<li>cert: Публичный x509 сертификат. По умолчанию <code>null</code>.</li>
<li>ca: Сертификат или список доверенных сертификатов
для проверки подлинности удалённого хоста.</li>
</ul>
<h2>https.get(options, callback)<span><a class="mark" href="#all_https_get_options_callback" id="all_https_get_options_callback">#</a></span></h2>
<p>Аналог <code>http.get()</code> для HTTPS.

</p>
<p>Пример:

</p>
<pre><code>var https = require(&apos;https&apos;);

https.get({ host: &apos;encrypted.google.com&apos;, path: &apos;/&apos; }, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&apos;data&apos;, function(d) {
    process.stdout.write(d);
  });

}).on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<h2>URL<span><a class="mark" href="#all_url" id="all_url">#</a></span></h2>
<p>В это модуле собраны инструменты для разрешения и разбора URL.
Вызовите <code>require(&apos;url&apos;)</code> чтобы его использовать.

</p>
<p>Объекты разобранного URL имеют либо все либо некоторые из перечисленных полей,
в зависимости от их присутствия в строке URL. Части которых не было в URL
не будут присутствовать в объекте. Примеры показаны для URL

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<ul>
<li><p><code>href</code>: Полный URL который был разобран.</p>
<p>Пример: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
</li>
<li><p><code>protocol</code>: Протокол запроса.</p>
<p>Пример: <code>&apos;http:&apos;</code></p>
</li>
<li><p><code>host</code>: Полный host, включая порт и информацию аутентификации.</p>
<p>Пример: <code>&apos;user:pass@host.com:8080&apos;</code></p>
</li>
<li><p><code>auth</code>: Информация для аутентификации.</p>
<p>Пример: <code>&apos;user:pass&apos;</code></p>
</li>
<li><p><code>hostname</code>: Имя хоста.</p>
<p>Пример: <code>&apos;host.com&apos;</code></p>
</li>
<li><p><code>port</code>: Номер порта.</p>
<p>Пример: <code>&apos;8080&apos;</code></p>
</li>
<li><p><code>pathname</code>: Секция пути, которая идёт после хоста и перед строкой параметров, включая начальный слеш если он есть.</p>
<p>Пример: <code>&apos;/p/a/t/h&apos;</code></p>
</li>
<li><p><code>search</code>: Строка запроса, включая ведущий знак вопроса.</p>
<p>Пример: <code>&apos;?query=string&apos;</code></p>
</li>
<li><p><code>query</code>: Параметры из строки запроса, либо уже разобранный объект с параметрами.</p>
<p>Пример: <code>&apos;query=string&apos;</code> or <code>{&apos;query&apos;:&apos;string&apos;}</code></p>
</li>
<li><p><code>hash</code>: &quot;Якорь&quot; URL, включая знак решётки.</p>
<p>Пример: <code>&apos;#hash&apos;</code></p>
</li>
</ul>
<p>Модуль URL предоставляет следующие методы:

</p>
<h3>url.parse(urlStr, parseQueryString=false, slashesDenoteHost=false)<span><a class="mark" href="#all_url_parse_urlstr_parsequerystring_false_slashesdenotehost_false" id="all_url_parse_urlstr_parsequerystring_false_slashesdenotehost_false">#</a></span></h3>
<p>Получает строку URL и возвращает объект.

</p>
<p>Передайте <code>true</code> вторым аргументом, чтобы одновременно
разобрать строку запроса модулем <code>querystring</code>.

</p>
<p>Передайте <code>true</code> третьим аргументом, чтоы строка <code>//foo/bar</code> разрешалась как
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> вместо <code>{ pathname: &apos;//foo/bar&apos; }</code>.


</p>
<h3>url.format(urlObj)<span><a class="mark" href="#all_url_format_urlobj" id="all_url_format_urlobj">#</a></span></h3>
<p>Получает объект URL и возвращает отформатированный URL в виде строки.


</p>
<h3>url.resolve(from, to)<span><a class="mark" href="#all_url_resolve_from_to" id="all_url_resolve_from_to">#</a></span></h3>
<p>Получает базовый URL и относительный URL, и разрешает их как это сделал бы браузер для гиперссылки.


</p>
<h2>Разбор строки запроса<span><a class="mark" href="#all_30" id="all_30">#</a></span></h2>
<p>Этот модуль предоставляет инструменты для работы со строкой запроса.
Используйте <code>require(&apos;querystring&apos;)</code> чтобы получить доступ к функциям модуля.


</p>
<h3>querystring.stringify(obj, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)<span><a class="mark" href="#all_querystring_stringify_obj_sep_eq" id="all_querystring_stringify_obj_sep_eq">#</a></span></h3>
<p>Сериализует объект в строку запроса. Можно менять символы разделителя и присваивания.

</p>
<p>Пример:

</p>
<pre><code>querystring.stringify({foo: &apos;bar&apos;})
// returns
&apos;foo=bar&apos;

querystring.stringify({foo: &apos;bar&apos;, baz: &apos;bob&apos;}, &apos;;&apos;, &apos;:&apos;)
// returns
&apos;foo:bar;baz:bob&apos;</code></pre>
<h3>querystring.parse(str, sep=&apos;&amp;&apos;, eq=&apos;=&apos;)<span><a class="mark" href="#all_querystring_parse_str_sep_eq" id="all_querystring_parse_str_sep_eq">#</a></span></h3>
<p>Десериализует строку запроса в объект. Можно менять символы разделителя и присваивания.

</p>
<p>Пример:

</p>
<pre><code>querystring.parse(&apos;a=b&amp;b=c&apos;)
// returns
{ a: &apos;b&apos;, b: &apos;c&apos; }</code></pre>
<h3>querystring.escape<span><a class="mark" href="#all_querystring_escape" id="all_querystring_escape">#</a></span></h3>
<p>Функция экранирования, используемая в <code>querystring.stringify</code>,
предоставляется для того чтобы проще было заменить её собственной.

</p>
<h3>querystring.unescape<span><a class="mark" href="#all_querystring_unescape" id="all_querystring_unescape">#</a></span></h3>
<p>Функция декодирования, используемая <code>querystring.parse</code>,
предоставляется для того чтобы проще было заменить её собственной.


</p>
<h2>Readline<span><a class="mark" href="#all_readline" id="all_readline">#</a></span></h2>
<p>To use this module, do <code>require(&apos;readline&apos;)</code>. Readline allows reading of a
stream (such as STDIN) on a line-by-line basis.

</p>
<p>Note that once you&apos;ve invoked this module, your node program will not
terminate until you&apos;ve closed the interface, and the STDIN stream. Here&apos;s how
to allow your program to gracefully terminate:

</p>
<pre><code>var rl = require(&apos;readline&apos;);

var i = rl.createInterface(process.sdtin, process.stdout, null);
i.question(&quot;What do you think of node.js?&quot;, function(answer) {
  // TODO: Log the answer in a database
  console.log(&quot;Thank you for your valuable feedback.&quot;);

  // These two lines together allow the program to terminate. Without
  // them, it would run forever.
  i.close();
  process.stdin.destroy();
});</code></pre>
<h3>rl.createInterface(input, output, completer)<span><a class="mark" href="#all_rl_createinterface_input_output_completer" id="all_rl_createinterface_input_output_completer">#</a></span></h3>
<p>Takes two streams and creates a readline interface. The <code>completer</code> function
is used for autocompletion. When given a substring, it returns <code>[[substr1,
substr2, ...], originalsubstring]</code>.

</p>
<p><code>createInterface</code> is commonly used with <code>process.stdin</code> and
<code>process.stdout</code> in order to accept user input:

</p>
<pre><code>var readline = require(&apos;readline&apos;),
  rl = readline.createInterface(process.stdin, process.stdout);</code></pre>
<h3>rl.setPrompt(prompt, length)<span><a class="mark" href="#all_rl_setprompt_prompt_length" id="all_rl_setprompt_prompt_length">#</a></span></h3>
<p>Sets the prompt, for example when you run <code>node</code> on the command line, you see
<code>&gt; </code>, which is node&apos;s prompt.

</p>
<h3>rl.prompt()<span><a class="mark" href="#all_rl_prompt" id="all_rl_prompt">#</a></span></h3>
<p>Readies readline for input from the user, putting the current <code>setPrompt</code>
options on a new line, giving the user a new spot to write.

</p>
<!-- ### rl.getColumns() Not available? -->

<h3>rl.question(query, callback)<span><a class="mark" href="#all_rl_question_query_callback" id="all_rl_question_query_callback">#</a></span></h3>
<p>Prepends the prompt with <code>query</code> and invokes <code>callback</code> with the user&apos;s
response. Displays the query to the user, and then invokes <code>callback</code> with the
user&apos;s response after it has been typed.

</p>
<p>Example usage:

</p>
<pre><code>interface.question(&apos;What is your favorite food?&apos;, function(answer) {
  console.log(&apos;Oh, so your favorite food is &apos; + answer);
});</code></pre>
<h3>rl.close()<span><a class="mark" href="#all_rl_close" id="all_rl_close">#</a></span></h3>
<p>  Closes tty.

</p>
<h3>rl.pause()<span><a class="mark" href="#all_rl_pause" id="all_rl_pause">#</a></span></h3>
<p>  Pauses tty.

</p>
<h3>rl.resume()<span><a class="mark" href="#all_rl_resume" id="all_rl_resume">#</a></span></h3>
<p>  Resumes tty.

</p>
<h3>rl.write()<span><a class="mark" href="#all_rl_write" id="all_rl_write">#</a></span></h3>
<p>  Writes to tty.

</p>
<h3>Event: &apos;line&apos;<span><a class="mark" href="#all_event_line" id="all_event_line">#</a></span></h3>
<p><code>function (line) {}</code>

</p>
<p>Emitted whenever the <code>in</code> stream receives a <code>\n</code>, usually received when the
user hits enter, or return. This is a good hook to listen for user input.

</p>
<p>Example of listening for <code>line</code>:

</p>
<pre><code>rl.on(&apos;line&apos;, function (cmd) {
  console.log(&apos;You just typed: &apos;+cmd);
});</code></pre>
<h3>Event: &apos;close&apos;<span><a class="mark" href="#all_event_close" id="all_event_close">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>in</code> stream receives a <code>^C</code> or <code>^D</code>, respectively known
as <code>SIGINT</code> and <code>EOT</code>. This is a good way to know the user is finished using
your program.

</p>
<p>Example of listening for <code>close</code>, and exiting the program afterward:

</p>
<pre><code>rl.on(&apos;close&apos;, function() {
  console.log(&apos;goodbye!&apos;);
  process.exit(0);
});</code></pre>
<p>Here&apos;s an example of how to use all these together to craft a tiny command
line interface:

</p>
<pre><code>var readline = require(&apos;readline&apos;),
  rl = readline.createInterface(process.stdin, process.stdout),
  prefix = &apos;OHAI&gt; &apos;;

rl.on(&apos;line&apos;, function(line) {
  switch(line.trim()) {
    case &apos;hello&apos;:
      console.log(&apos;world!&apos;);
      break;
    default:
      console.log(&apos;Say what? I might have heard `&apos; + line.trim() + &apos;`&apos;);
      break;
  }
  rl.setPrompt(prefix, prefix.length);
  rl.prompt();
}).on(&apos;close&apos;, function() {
  console.log(&apos;Have a great day!&apos;);
  process.exit(0);
});
console.log(prefix + &apos;Good to see you. Try typing stuff.&apos;);
rl.setPrompt(prefix, prefix.length);
rl.prompt();</code></pre>
<p>Take a look at this slightly more complicated
<a href="https://gist.github.com/901104">example</a>, and
<a href="http://github.com/cloudhead/http-console">http-console</a> for a real-life use
case.

</p>
<h2>Интерактивная консоль (REPL)<span><a class="mark" href="#all_repl" id="all_repl">#</a></span></h2>
<p>Интерактивная консоль (Read-Eval-Print-Loop, REPL) доступна как самостоятельная
программа и может включаться в другие скрипты. REPL предоставляет возможность
интерактивно выполнять JavaScript и сразу видеть результат. Он может использоваться
для отладки, тестирования, и просто знакомства с системой.

</p>
<p>Выполняя <code>node</code> без аргументов из командной строки вы попадёте прямо в REPL.
В нём есть простое редактирование строк по образцу emacs.

</p>
<pre><code>mjr:~$ node
Type &apos;.help&apos; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<p>Чтобы использовать продвинутые редакторы, запустите Node с переменной окружения
<code>NODE_NO_READLINE=1</code>. Это запустит REPL с обычными терминальными настройками,
позволяющими использовать <code>rlwrap</code>.

</p>
<p>К примеру, можно добавить следующее к Вашему файлу bashrc:

</p>
<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<h3>repl.start(prompt=&apos;&gt; &apos;, stream=process.openStdin())<span><a class="mark" href="#all_repl_start_prompt_stream_process_openstdin" id="all_repl_start_prompt_stream_process_openstdin">#</a></span></h3>
<p>Запускает REPL с <code>prompt</code> в качестве приглашения и потоком <code>stream</code> для ввода/вывода.
Параметр <code>prompt</code> необязателен и по умолчанию принимает значение <code>&apos;&gt;&apos;</code>.
Параметр <code>stream</code> также необязателен и по умолчанию принимает значение <code>process.stdin</code>.

</p>
<p>В одном экземпляре node могут быть запущены несколько консолей REPL.
Все будут использовать один глобальный объект но разный ввод-вывод.

</p>
<p>Вот пример, запускающий консоль REPL на стандартном потоке ввода-вывода,
сокете Unix, и TCP-сокете:

</p>
<pre><code>var net = require(&quot;net&quot;),
    repl = require(&quot;repl&quot;);

connections = 0;

repl.start(&quot;node via stdin&gt; &quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via Unix socket&gt; &quot;, socket);
}).listen(&quot;/tmp/node-repl-sock&quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start(&quot;node via TCP socket&gt; &quot;, socket);
}).listen(5001);</code></pre>
<p>Запуск этой программы из командной строки запустит консоль на <code>stdin</code>. Другие
клиенты могут подключаться через Unix-сокет или TCP-сокет. Для подключения
к TCP сокетам можно использовать <code>telnet</code>, a <code>socat</code> можно использовать
для обоих типов сокетов.

</p>
<p>Запуская REPL на сокете вместо стандартного ввода-вывода Вы можете подключаться
к работающему процессу node не перезапуская его.


</p>
<h3>Возможности REPL<span><a class="mark" href="#all_repl_1" id="all_repl_1">#</a></span></h3>
<p>Внутри REPL Control+D завершает его работу. Можно вводить многострочные выражения.

</p>
<p>Специальная переменная <code>_</code> (знак подчёркивания) содержит результат последнего выражения.

</p>
<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
&gt; _.length 
3
&gt; _ += 1
4</code></pre>
<p>REPL предоставляет доступ к любым переменным глобальной области видимости.
Вы можете явно передать переменную в REPL, присвоив её объекту <code>context</code>,
ассоциированному с каждым экземпляром <code>REPLServer</code>. Например:

</p>
<pre><code>// repl_test.js
var repl = require(&quot;repl&quot;),
    msg = &quot;message&quot;;

repl.start().context.m = msg;</code></pre>
<p>Свойства объекта <code>context</code> выглядят внутри REPL как локальные:

</p>
<pre><code>mjr:~$ node repl_test.js
&gt; m
&apos;message&apos;</code></pre>
<p>В REPL есть несколько специальных команд:

</p>
<ul>
<li><code>.break</code> - При вводе многострочного выражения иногда можно ошибиться,
либо совсем отказаться от его ввода. <code>.break</code> начнёт ввод заново.</li>
<li><code>.clear</code> - Сбрасывает объект <code>context</code> в пустой и очищает введённое многострочное выражение.</li>
<li><code>.exit</code> - Закрывает потоки ввода-вывода, принуждая REPL завершиться.</li>
<li><code>.help</code> - Показывает список специальных команд.</li>
</ul>
<h2>Выполнение JavaScript<span><a class="mark" href="#all_javascript" id="all_javascript">#</a></span></h2>
<p>Для доступа к модулю используйте:

</p>
<pre><code>var vm = require(&apos;vm&apos;);</code></pre>
<p>JavaScript-код может быть скомпилирован и исполнен немедленно,
либо сохранён для последующего запуска.


</p>
<h3>vm.runInThisContext(code, [filename])<span><a class="mark" href="#all_vm_runinthiscontext_code_filename" id="all_vm_runinthiscontext_code_filename">#</a></span></h3>
<p><code>vm.runInThisContext()</code> компилирует <code>code</code> как будто он загружен из файла <code>filename</code>,
выполняет его и возвращает результат выполнения. Запускаемый код не имеет доступа
к локальной области видимости. <code>filename</code> не является обязательным аргументом.

</p>
<p>Пример использования <code>vm.runInThisContext</code> и <code>eval</code> для выполнения одинакового кода:

</p>
<pre><code>var localVar = 123,
    usingscript, evaled,
    vm = require(&apos;vm&apos;);

usingscript = vm.runInThisContext(&apos;localVar = 1;&apos;,
  &apos;myfile.vm&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, usingscript: &apos; +
  usingscript);
evaled = eval(&apos;localVar = 1;&apos;);
console.log(&apos;localVar: &apos; + localVar + &apos;, evaled: &apos; +
  evaled);

// localVar: 123, usingscript: 1
// localVar: 1, evaled: 1</code></pre>
<p><code>vm.runInThisContext</code> не имеет доступа к локальной области видимости, поэтому
<code>localVar</code> остаётся неизменной. <code>eval</code> имеет доступ к локальной области видимости,
поэтому <code>localVar</code> изменяется.

</p>
<p>В случае синтаксической ошибке в <code>code</code>, <code>vm.runInThisContext</code> выводит ошибку
на stderr и бросает исключение.


</p>
<h3>vm.runInNewContext(code, [sandbox], [filename])<span><a class="mark" href="#all_vm_runinnewcontext_code_sandbox_filename" id="all_vm_runinnewcontext_code_sandbox_filename">#</a></span></h3>
<p><code>vm.runInNewContext</code> компилирует <code>code</code> для запуска в области видимости
<code>sandbox</code> как будто он загружен из файла <code>filename</code>, выполняет его и возвращает
результат выполнения. Запускаемый код не имеет доступа к локальной области
видимости, и использует объект <code>sandbox</code> в качестве глобального объекта.
<code>sandbox</code> и <code>filename</code> не являются обязательными аргументами.

</p>
<p>Пример: компиляция и выполнение кода, который увеличивает глобальную переменную
юи создаёт новую. Эти глобальные переменные становятся доступными в <code>sandbox</code>.

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

vm.runInNewContext(&apos;count += 1; name = &quot;kitty&quot;&apos;, sandbox, &apos;myfile.vm&apos;);
console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>
<p>Имейте в виду, что исполнение непроверенного кода довольно опасно. Для предотвращения
изменения таким кодом глобальных переменных можно использовать <code>vm.runInNewContext</code>,
но лучше всего выполнять такой код в отдельном процессе.

</p>
<p>В случае синтаксической ошибке в <code>code</code>, <code>vm.runInNewContext</code> выводит ошибку
на stderr и бросает исключение.


</p>
<h3>vm.createScript(code, [filename])<span><a class="mark" href="#all_vm_createscript_code_filename" id="all_vm_createscript_code_filename">#</a></span></h3>
<p><code>createScript</code> компилирует <code>code</code> как будто он загружен из файла <code>filename</code>,
но нен выполняет его. Эта функция возвращает объект <code>vm.Script</code>, представляющий
гдаоткомпилированный кода. Этот код может быть запущель позже с помощью описанных
ниже методов. Возвращаемый скрипт не связан с каким-лтбо глобальным объектом,
это связаванеи происходит при каждом выполнение. <code>filename</code> не является
обязательным аргументом.

</p>
<p>В случае синтаксической ошибке в <code>code</code>, <code>vm.createScript</code> выводит ошибку
на stderr и бросает исключение.


</p>
<h2>Класс: Script<span><a class="mark" href="#all_script" id="all_script">#</a></span></h2>
<p>Класс, используемый для запуска скриптов. Экземпляры этого класса создаются с помощью vm.createScript.

</p>
<h3>script.runInThisContext()<span><a class="mark" href="#all_script_runinthiscontext" id="all_script_runinthiscontext">#</a></span></h3>
<p>Тоже самое, что и <code>vm.runInThisContext</code>, но для предварительно скомпилированного
объекта `vm.Script. Запускаемый код не имет доступа к локальным переменным,
но имеет дост к глобальным (v8: in actual context).

</p>
<p>Пример использования <code>script.runInThisContext</code> для компиляции кода
и множественного его исполнения:

</p>
<pre><code>var vm = require(&apos;vm&apos;);

globalVar = 0;

var script = vm.createScript(&apos;globalVar += 1&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 1000 ; i += 1) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>
<h3>script.runInNewContext([sandbox])<span><a class="mark" href="#all_script_runinnewcontext_sandbox" id="all_script_runinnewcontext_sandbox">#</a></span></h3>
<p>Тоже самое, что и <code>vm.runInNewContext</code>, но для предварительно скомпилированного
объекта `vm.Script.

</p>
<p>Пример: компиляция кода, который увеличивает глобальную переменную
юи создаёт новую, и множественное его выполнение. Эти глобальные переменные
становятся доступными в <code>sandbox</code>.

</p>
<pre><code>var util = require(&apos;util&apos;),
    vm = require(&apos;vm&apos;),
    sandbox = {
      animal: &apos;cat&apos;,
      count: 2
    };

var script = vm.createScript(&apos;count += 1; name = &quot;kitty&quot;&apos;, &apos;myfile.vm&apos;);

for (var i = 0; i &lt; 10 ; i += 1) {
  script.runInNewContext(sandbox);
}

console.log(util.inspect(sandbox));

// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>
<p>Имейте в виду, что исполнение непроверенного кода довольно опасно. Для предотвращения
изменения таким кодом глобальных переменных можно использовать <code>script.runInNewContext</code>,
но лучше всего выполнять такой код в отдельном процессе.


</p>
<h1>Дочерний процесс<span><a class="mark" href="#all_31" id="all_31">#</a></span></h1>
<pre><code>Стабильность: 3 - Стабильно</code></pre>
<p>Node предоставляет tri-directional popen(3) с помощью модуля <code>child_process</code>.

</p>
<p>С дочерним потоком можно обмениваться данными через <code>stdin</code>, <code>stdout</code> и <code>stderr</code>
в полностью неблокирующем стиле.

</p>
<p>Для создания дочернего процесса используйте <code>require(&apos;child_process&apos;).spawn()</code> или
<code>require(&apos;child_process&apos;).fork()</code>. Различие между этими вызовами опасаны ниже.

</p>
<h2>Class: ChildProcess<span><a class="mark" href="#all_class_childprocess" id="all_class_childprocess">#</a></span></h2>
<p><code>ChildProcess</code> — экземпляр <code>EventEmitter</code>.

</p>
<p>С дочерним процессом всегда ассоциированы три потока: <code>child.stdin</code>, <code>child.stdout</code> и <code>child.stderr</code>.
Они могут быть общими с соответствующими потоками родителя, или различаться.

</p>
<p>Класс ChildProcess не должен быть использован напрямую, используйте метод <code>spawn()</code> или <code>fork()</code>
модуля <code>child_process</code> для создания дочернего процесса.

</p>
<h3>Событие: &apos;exit&apos;<span><a class="mark" href="#all_exit_1" id="all_exit_1">#</a></span></h3>
<div class="signature"><ul>
<li><code>code</code> <span class="type">Number</span> Код выхода, в случае успешного совершения работы.</li>
<li><code>signal</code> <span class="type">String</span> Сигнал, завершивший процесс, если он был завершён родителем.</li>
</div></ul>
<p><code>function (code, signal) {}</code>

</p>
<p>Это событие генерируется при завершении дочернего процесса. Если процесс
завершён нормально, в <code>code</code> передаётся код завершения процесса, иначе
передаётся <code>null</code>. Если процесс завершился от принятия сигнала, то <code>signal</code> —
это строка, содержащая имя сигнала, либо <code>null</code>.

</p>
<p>См. также: <code>waitpid(2)</code>.

</p>
<h3>child.stdin<span><a class="mark" href="#all_child_stdin" id="all_child_stdin">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p><code>Поток с возможностью записи</code>, связанный со <code>stdin</code> процесса дочернего.
Закрытие потока с помощью <code>end()</code> часто приводит к завершению процесса.

</p>
<p>Если поток <code>stdin</code> дочернего потока совпадает с соответствующим поток родителя, то это свойство не задано.

</p>
<h3>child.stdout<span><a class="mark" href="#all_child_stdout" id="all_child_stdout">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p><code>Поток с возможностью чтения</code>, связанный со <code>stdout</code> дочернего процесса.

</p>
<p>Если поток <code>stdout</code> дочернего потока совпадает с соответствующим поток родителя, то это свойство не задано.

</p>
<h3>child.stderr<span><a class="mark" href="#all_child_stderr" id="all_child_stderr">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p><code>Поток с возможностью чтения</code>, связанный со <code>stderr</code> дочернего процесса.

</p>
<p>Если поток <code>stderr</code> дочернего потока совпадает с соответствующим поток родителя, то это свойство не задано.

</p>
<h3>child.pid<span><a class="mark" href="#all_child_pid" id="all_child_pid">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Integer</span></li>
</div></ul>
<p>Идентификатор дочернего процесса.

</p>
<p>Пример:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

console.log(&apos;Spawned child pid: &apos; + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.kill(signal=&apos;SIGTERM&apos;)<span><a class="mark" href="#all_child_kill_signal_sigterm" id="all_child_kill_signal_sigterm">#</a></span></h3>
<div class="signature"><ul>
<li><code>signal</code> <span class="type">String</span></li>
</div></ul>
<p>Отправляет сигнал дочернему процессу. Если аргументы не переданы, то процессу
будет отправлен сигнал <code>&apos;SIGTERM&apos;</code>. См. <code>signal(7)</code> для списка возможных имён сигналов.

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

grep.on(&apos;exit&apos;, function (code, signal) {
  console.log(&apos;child process terminated due to receipt of signal &apos;+signal);
});

// send SIGHUP to process
grep.kill(&apos;SIGHUP&apos;);</code></pre>
<p>Заметьте, что хотя функция называется <code>kill</code>, сигнал, отправляемый дочернему процессу,
не обязательно его завершит. Метод <code>kill</code> просто отправляет сигналы.

</p>
<p>См. также: <code>kill(2)</code>.

</p>
<h3>child.send(message, [sendHandle])<span><a class="mark" href="#all_child_send_message_sendhandle" id="all_child_send_message_sendhandle">#</a></span></h3>
<div class="signature"><ul>
<li><code>message</code> <span class="type">Object</span></li>
<li><code>sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<p>Send a message (and, optionally, a handle object) to a child process.

</p>
<p>See <code>child_process.fork()</code> for details.

</p>
<h2>child_process.spawn(command, [args], [options])<span><a class="mark" href="#all_child_process_spawn_command_args_options" id="all_child_process_spawn_command_args_options">#</a></span></h2>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> Команда для исполнения</li>
<li><code>args</code> <span class="type">Array</span> Список строк-аргументов</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Рабочая директория дочернего процесса</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Устарело</strong> Файловые дескрипторы для использования дочерним процессом, см. ниже</li>
<li><code>env</code> <span class="type">Object</span> Переменные окружение дочернего процесса, пары имя-значение</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
</ul>
</li>
<li>Возвращает: <span class="type">ChildProcess object</span></li>
</div></ul>
<p>Запускает новый процесс с указанной командой <code>command</code> и аргументами командной
строки <code>args</code>. Если аргументы пропущены, args будет пустым массивом.

</p>
<p>Третий аргумент функции используется для задания дополнительных опций
со следующими значениями по умолчанию:

</p>
<pre><code>{ cwd: undefined,
  env: process.env,
  customFds: [-1, -1, -1],
  setsid: false
}</code></pre>
<p><code>cwd</code> позволяет вам задать рабочую папку для дочернего процесса.
Используйте <code>env</code> для определия переменных окружения, видимых дочернему процессу.
С помощью <code>customFds</code> возможно связать <code>stdin</code>, <code>stdout</code> и <code>stderr</code> дочернего процесса
с существующими потоками; -1 означает, что нужно создать новый поток.
Если <code>setsid</code> истинно, то процесс будет создан в новой пользовательской сессии.

</p>
<p>Пример запуска <code>ls -lh /usr</code>, чтения <code>stdout</code>, <code>stderr</code> и получения кода завершения:

</p>
<pre><code>var util   = require(&apos;util&apos;),
    spawn  = require(&apos;child_process&apos;).spawn,
    ls     = spawn(&apos;ls&apos;, [&apos;-lh&apos;, &apos;/usr&apos;]);

ls.stdout.on(&apos;data&apos;, function (data) {
  console.log(&apos;stdout: &apos; + data);
});

ls.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;stderr: &apos; + data);
});

ls.on(&apos;exit&apos;, function (code) {
  console.log(&apos;child process exited with code &apos; + code);
});</code></pre>
<p>Пример: достаточно сложный способ выполнить &apos;ps ax | grep ssh&apos;.

</p>
<pre><code>var util  = require(&apos;util&apos;),
    spawn = require(&apos;child_process&apos;).spawn,
    ps    = spawn(&apos;ps&apos;, [&apos;ax&apos;]),
    grep  = spawn(&apos;grep&apos;, [&apos;ssh&apos;]);

ps.stdout.on(&apos;data&apos;, function (data) {
  grep.stdin.write(data);
});

ps.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;ps stderr: &apos; + data);
});

ps.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;ps process exited with code &apos; + code);
  }
  grep.stdin.end();
});

grep.stdout.on(&apos;data&apos;, function (data) {
  console.log(data);
});

grep.stderr.on(&apos;data&apos;, function (data) {
  console.log(&apos;grep stderr: &apos; + data);
});

grep.on(&apos;exit&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;grep process exited with code &apos; + code);
  }
});</code></pre>
<p>Пример проверки ошибки запуска приложения:

</p>
<pre><code>var spawn = require(&apos;child_process&apos;).spawn,
    child = spawn(&apos;bad_command&apos;);

child.stderr.setEncoding(&apos;utf8&apos;);
child.stderr.on(&apos;data&apos;, function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log(&apos;Failed to start child process.&apos;);
  }
});</code></pre>
<p>См. также: <code>child_process.exec()</code> и <code>child_process.fork()</code>.


</p>
<h2>child_process.exec(command, [options], callback)<span><a class="mark" href="#all_child_process_exec_command_options_callback" id="all_child_process_exec_command_options_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>command</code> <span class="type">String</span> Команда для исполнения, с аргументами, разделёнными пробелами</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Рабочая директория дочернего процесса</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Устарело</strong> Файловые дескрипторы для использования дочерним процессом, см. ниже</li>
<li><code>env</code> <span class="type">Object</span> Переменные окружение дочернего процесса, пары имя-значение</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (По умолчанию: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (По умолчанию: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> (По умолчанию: 200*1024)</li>
<li><code>killSignal</code> <span class="type">String</span> (По умолчанию: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> Функция обратного вызова, принимающая вывод процесса после его завершения<ul>
<li><code>code</code> <span class="type">Integer</span> Код выхода</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Возвращает: <span class="type">ChildProcess object</span></li>
</div></ul>
<p>Высокоуровневый способ выполнить команду в качестве дочернего процесса,
сохранить весь её вывод, и передать его в callback.

</p>
<pre><code>var util = require(&apos;util&apos;),
    exec = require(&apos;child_process&apos;).exec,
    child;

child = exec(&apos;cat *.js bad_file | wc -l&apos;,
  function (error, stdout, stderr) {
    console.log(&apos;stdout: &apos; + stdout);
    console.log(&apos;stderr: &apos; + stderr);
    if (error !== null) {
      console.log(&apos;exec error: &apos; + error);
    }
});</code></pre>
<p>Функция-callback получает аргументы <code>(error, stdout, stderr)</code>. При удачном
выполнении в <code>error</code> будет <code>null</code>. При ошибке <code>error</code> будет экземпляром <code>Error</code>,
<code>err.code</code> будет кодом завершения дочернего процесса, а в <code>err.signal</code> будет
содержаться имя сигнала, завершившего процесс.

</p>
<p>Вторым аргументом могут быть переданы дополнительные опции
со следующими значениями по умолчанию:

</p>
<pre><code>{ encoding: &apos;utf8&apos;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &apos;SIGTERM&apos;,
  cwd: null,
  env: null }</code></pre>
<p>Если <code>timeout</code> больше 0, процесс будет завершён, если он выполняется дольше,
чем <code>timeout</code> миллисекунд. Дочерний процесс завершается с помощью сигнала
<code>killSignal</code>. В <code>maxBuffer</code> указывается максимальный объём данных, разрешённый
на <code>stdout</code> или <code>stderr</code> — если этот объём будет превышен,
то дочерний процесс будет завершён.

</p>
<h2>child_process.execFile(file, args, options, callback)<span><a class="mark" href="#all_child_process_execfile_file_args_options_callback" id="all_child_process_execfile_file_args_options_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>file</code> <span class="type">String</span> Файл для исполнения</li>
<li><code>args</code> <span class="type">Array</span> Список строк-аргументов</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Рабочая директория дочернего процесса</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Устарело</strong> Файловые дескрипторы для использования дочерним процессом, см. ниже</li>
<li><code>env</code> <span class="type">Object</span> Переменные окружение дочернего процесса, пары имя-значение</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (По умолчанию: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (По умолчанию: 0)</li>
<li><code>maxBuffer</code> <span class="type">Number</span> (По умолчанию: 200*1024)</li>
<li><code>killSignal</code> <span class="type">String</span> (По умолчанию: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> Функция обратного вызова, принимающая вывод процесса после его завершения<ul>
<li><code>code</code> <span class="type">Integer</span> Код выхода</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Возвращает: <span class="type">ChildProcess object</span></li>
</div></ul>
<p>Идентично <code>child_process.exec()</code>, но не создаёт subshell, а выполняет файл напрямую.
Это делает его компактнее <code>child_process.exec</code>. Имеет аналогичные опции.

</p>
<h2>child_process.fork(modulePath, [args], [options])<span><a class="mark" href="#all_child_process_fork_modulepath_args_options" id="all_child_process_fork_modulepath_args_options">#</a></span></h2>
<div class="signature"><ul>
<li><code>modulePath</code> <span class="type">String</span> The module to run in the child</li>
<li><code>args</code> <span class="type">Array</span> List of string arguments</li>
<li><code>options</code> <span class="type">Object</span><ul>
<li><code>cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code>customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code>setsid</code> <span class="type">Boolean</span></li>
<li><code>encoding</code> <span class="type">String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span class="type">Number</span> (Default: 0)</li>
</ul>
</li>
<li><code>callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code>code</code> <span class="type">Integer</span> Exit code</li>
<li><code>stdout</code> <span class="type">Buffer</span></li>
<li><code>stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>This is a special case of the <code>spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. The
channel is written to with <code>child.send(message, [sendHandle])</code> and messages
are received by a <code>&apos;message&apos;</code> event on the child.

</p>
<p>For example:

</p>
<pre><code>var cp = require(&apos;child_process&apos;);

var n = cp.fork(__dirname + &apos;/sub.js&apos;);

n.on(&apos;message&apos;, function(m) {
  console.log(&apos;PARENT got message:&apos;, m);
});

n.send({ hello: &apos;world&apos; });</code></pre>
<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:

</p>
<pre><code>process.on(&apos;message&apos;, function(m) {
  console.log(&apos;CHILD got message:&apos;, m);
});

process.send({ foo: &apos;bar&apos; });</code></pre>
<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>By default the spawned Node process will have the stdin, stdout, stderr
associated with the parent&apos;s.

</p>
<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.

</p>
<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to
another process. Child will receive the handle as as second argument to the
<code>message</code> event. Here is an example of sending a handle:

</p>
<pre><code>var server = require(&apos;net&apos;).createServer();
var child = require(&apos;child_process&apos;).fork(__dirname + &apos;/child.js&apos;);
// Open up the server object and send the handle.
server.listen(1337, function() {
  child.send({ server: true }, server._handle);
});</code></pre>
<p>Here is an example of receiving the server handle and sharing it between
processes:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, serverHandle) {
  if (serverHandle) {
    var server = require(&apos;net&apos;).createServer();
    server.listen(serverHandle);
  }
});</code></pre>
<h1>Тестирование (asserts)<span><a class="mark" href="#all_asserts" id="all_asserts">#</a></span></h1>
<p>Этот модуль используется для написания юнит-тестов для ваших приложений,
вы можете использовать его вызвав <code>require(&apos;assert&apos;)</code>.

</p>
<h2>assert.fail(actual, expected, message, operator)<span><a class="mark" href="#all_assert_fail_actual_expected_message_operator" id="all_assert_fail_actual_expected_message_operator">#</a></span></h2>
<p>Проверяет что <code>actual</code> соответствует <code>expected</code> используя указанный оператор.

</p>
<h2>assert.ok(value, [message])<span><a class="mark" href="#all_assert_ok_value_message" id="all_assert_ok_value_message">#</a></span></h2>
<p>Проверяет что значение <code>value</code> равно <code>true</code>, то же самое что
<code>assert.equal(true, value, message);</code>.

</p>
<h2>assert.equal(actual, expected, [message])<span><a class="mark" href="#all_assert_equal_actual_expected_message" id="all_assert_equal_actual_expected_message">#</a></span></h2>
<p>Неглубокая проверка на равенство с использованием соответствующего оператора ( <code>==</code> ).

</p>
<h2>assert.notEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notequal_actual_expected_message" id="all_assert_notequal_actual_expected_message">#</a></span></h2>
<p>Неглубокая проверка на неравенство с использованием соответствующего оператора ( <code>!=</code> ).

</p>
<h2>assert.deepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_deepequal_actual_expected_message" id="all_assert_deepequal_actual_expected_message">#</a></span></h2>
<p>Глубокая проверка на равенство.

</p>
<h2>assert.notDeepEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notdeepequal_actual_expected_message" id="all_assert_notdeepequal_actual_expected_message">#</a></span></h2>
<p>Глубокая проверка на неравенство.

</p>
<h2>assert.strictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_strictequal_actual_expected_message" id="all_assert_strictequal_actual_expected_message">#</a></span></h2>
<p>Проверка на строгое равенство, с использованием соответствующего оператора ( <code>===</code> ).

</p>
<h2>assert.notStrictEqual(actual, expected, [message])<span><a class="mark" href="#all_assert_notstrictequal_actual_expected_message" id="all_assert_notstrictequal_actual_expected_message">#</a></span></h2>
<p>Проверка на строгое неравенство, с использованием соответствующего оператора ( <code>!==</code> ).

</p>
<h2>assert.throws(block, [error], [message])<span><a class="mark" href="#all_assert_throws_block_error_message" id="all_assert_throws_block_error_message">#</a></span></h2>
<p>Ожидает что блок кода <code>block</code> вызовет ошибку <code>error</code>.
<code>error</code> может быть конструкторов, регулярным выражением или функцией валидации.

</p>
<p>Проверка ошибки по типу конструктора:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  Error
);</code></pre>
<p>Проверка ошибки с помощью регулярного выражения:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  /value/
);</code></pre>
<p>Произвольная проверка с помощью функции валидации:

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<h2>assert.doesNotThrow(block, [error], [message])<span><a class="mark" href="#all_assert_doesnotthrow_block_error_message" id="all_assert_doesnotthrow_block_error_message">#</a></span></h2>
<p>Ожидает что блок кода <code>block</code> не вызовет ошибки.
См. описание параметров для <code>assert.throws</code>.

</p>
<h2>assert.ifError(value)<span><a class="mark" href="#all_assert_iferror_value" id="all_assert_iferror_value">#</a></span></h2>
<p>Проверяет что <code>value</code> имеет значение <code>false</code>, бросает исключение встретив <code>true</code>.
Удобно для проверки первого аргумента функций-обработчиков, <code>error</code>.


</p>
<h2>TTY<span><a class="mark" href="#all_tty" id="all_tty">#</a></span></h2>
<p>Используйте <code>require(&apos;tty&apos;)</code> чтобы получить доступ к этому модулю.

</p>
<p>Пример:

</p>
<pre><code>var tty = require(&apos;tty&apos;);
tty.setRawMode(true);
process.stdin.resume();
process.stdin.on(&apos;keypress&apos;, function(char, key) {
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &apos;c&apos;) {
    console.log(&apos;graceful exit&apos;);
    process.exit()
  }
});</code></pre>
<h3>tty.open(path, args=[])<span><a class="mark" href="#all_tty_open_path_args" id="all_tty_open_path_args">#</a></span></h3>
<p>Запускает новый процесс с исполняемымы файлом указанным в переменной path в новом псевдо-терминале.

</p>
<p>Возвращает массив <code>[slaveFD, childProcess]</code>. <code>slaveFD</code> это файловый дескриптор конца псевдотерминала, принадлежащего потомку. <code>childProcess</code> это объект дочернего процесса.


</p>
<h3>tty.isatty(fd)<span><a class="mark" href="#all_tty_isatty_fd" id="all_tty_isatty_fd">#</a></span></h3>
<p>Возвращает <code>true</code> или <code>false</code> в зависимости от того принадлежит ли файловый дескриптор <code>fd</code> терминалу.


</p>
<h3>tty.setRawMode(mode)<span><a class="mark" href="#all_tty_setrawmode_mode" id="all_tty_setrawmode_mode">#</a></span></h3>
<p>Переменная <code>mode</code> должна принимать значение <code>true</code> или <code>false</code>. Это задает режим работы потоков ввода-вывода текущего процесса: raw device или default.


</p>
<h3>tty.setWindowSize(fd, row, col)<span><a class="mark" href="#all_tty_setwindowsize_fd_row_col" id="all_tty_setwindowsize_fd_row_col">#</a></span></h3>
<p>Вызывает <code>ioctl()</code> для установки размеров терминала по файловуму дескриптору <code>fd</code>,
ассоциированному с ним.

</p>
<h3>tty.getWindowSize(fd)<span><a class="mark" href="#all_tty_getwindowsize_fd" id="all_tty_getwindowsize_fd">#</a></span></h3>
<p>Возвращает массив <code>[row, col]</code> размеров терминала по файловуму дескриптору <code>fd</code>,
ассоциированному с ним.


</p>
<h1>Zlib<span><a class="mark" href="#all_zlib" id="all_zlib">#</a></span></h1>
<p>Что бы получить доступ к этому модулю воспользуйтесь:

</p>
<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>
<p>Это привязка к Gzip/Gunzip, Deflate/Inflate, и
DeflateRaw/InflateRaw классам. Каждый класс имеет набор опций,
а также является потоком чтения/записи.

</p>
<h2>Примеры<span><a class="mark" href="#all_32" id="all_32">#</a></span></h2>
<p>Сжатие или распаковка файлов может быть выполнена путем передачи
потока fs.ReadStream в поток zlib, а затем в fs.WriteStream.

</p>
<pre><code>var gzip = zlib.createGzip();
var fs = require(&apos;fs&apos;);
var inp = fs.createReadStream(&apos;input.txt&apos;);
var out = fs.createWriteStream(&apos;input.txt.gz&apos;);

inp.pipe(gzip).pipe(out);</code></pre>
<p>Выполнить сжатие или распаковку в один шаг можно с помощью 
удобных методов.

</p>
<pre><code>var input = &apos;.................................&apos;;
zlib.deflate(input, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString(&apos;base64&apos;));
  }
});

var buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<p>Для испоьзования этого модуля в HTTP клиенте/сервере, воспользуйтесь установкой
заголовков, 
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
для запросов, и
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
для ответов.

</p>
<p><strong>Примечание: эти примеры очень сильно упрощены для того что бы 
показать основную идею.</strong> Zlib операции могут быть дорогими, результаты
должны сохраняться в кеш.  Смотри <a href="#memory_Usage_Tuning">настройки использования памяти</a>
ниже для получения информации о скорости/памяти/компресии влияющие на использование zlib.

</p>
<pre><code>//пример клиентского запроса
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var request = http.get({ host: &apos;izs.me&apos;,
                         path: &apos;/&apos;,
                         port: 80,
                         headers: { &apos;accept-encoding&apos;: &apos;gzip,deflate&apos; } });
request.on(&apos;response&apos;, function(response) {
  var output = fs.createWriteStream(&apos;izs.me_index.html&apos;);

  switch (response.headers[&apos;content-encoding&apos;]) {
    // или просто используйте zlib.createUnzip(), для 
    // обработки обоих случаев
    case &apos;gzip&apos;:
      response.pipe(zlib.createGunzip()).pipe(output);
      break;
    case &apos;deflate&apos;:
      response.pipe(zlib.createInflate()).pipe(output);
      break;
    default:
      response.pipe(output);
      break;
  }
});

// пример сервера
// Выполнение gzip операций на каждый запрос стоит достаточно дорого.
// использование кеширования может быть очень эффективным.
var zlib = require(&apos;zlib&apos;);
var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
http.createServer(function(request, response) {
  var raw = fs.createReadStream(&apos;index.html&apos;);
  var acceptEncoding = request.headers[&apos;accept-encoding&apos;];
  if (!acceptEncoding) {
    acceptEncoding = &apos;&apos;;
  }

  // Примечание: это не совместимый accept-encoding парсер.
  // Смотри http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<h2>Константы<span><a class="mark" href="#all_33" id="all_33">#</a></span></h2>
<!--type=misc-->

<p>Все константы определенные в  zlib.h также определены в 
<code>require(&apos;zlib&apos;)</code>. Они подробно описаны в документации Zlib.
Смотри <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a> для получения
подробной информации.

</p>
<h2>zlib.createGzip([параметры])<span><a class="mark" href="#all_zlib_creategzip" id="all_zlib_creategzip">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.Gzip">Gzip</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createGunzip([параметры])<span><a class="mark" href="#all_zlib_creategunzip" id="all_zlib_creategunzip">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.Gunzip">Gunzip</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createDeflate([параметры])<span><a class="mark" href="#all_zlib_createdeflate" id="all_zlib_createdeflate">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.Deflate">Deflate</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createInflate([параметры])<span><a class="mark" href="#all_zlib_createinflate" id="all_zlib_createinflate">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.Inflate">Inflate</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createDeflateRaw([параметры])<span><a class="mark" href="#all_zlib_createdeflateraw" id="all_zlib_createdeflateraw">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.DeflateRaw">DeflateRaw</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createInflateRaw([параметры])<span><a class="mark" href="#all_zlib_createinflateraw" id="all_zlib_createinflateraw">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.InflateRaw">InflateRaw</a> объект с <a href="#options">параметрами</a>.

</p>
<h2>zlib.createUnzip([параметры])<span><a class="mark" href="#all_zlib_createunzip" id="all_zlib_createunzip">#</a></span></h2>
<p>Возвращает новый <a href="#zlib.Unzip">Unzip</a> объект с <a href="#options">параметрами</a>.


</p>
<h2>Класс: zlib.Gzip<span><a class="mark" href="#all_zlib_gzip" id="all_zlib_gzip">#</a></span></h2>
<p>Сжатие данных используя gzip.

</p>
<h2>Класс: zlib.Gunzip<span><a class="mark" href="#all_zlib_gunzip" id="all_zlib_gunzip">#</a></span></h2>
<p>Расспаковка gzip потока.

</p>
<h2>Класс: zlib.Deflate<span><a class="mark" href="#all_zlib_deflate" id="all_zlib_deflate">#</a></span></h2>
<p>Сжатие данных используя deflate.

</p>
<h2>Класс: zlib.Inflate<span><a class="mark" href="#all_zlib_inflate" id="all_zlib_inflate">#</a></span></h2>
<p>Расспаковка deflate потока.

</p>
<h2>Класс: zlib.DeflateRaw<span><a class="mark" href="#all_zlib_deflateraw" id="all_zlib_deflateraw">#</a></span></h2>
<p>Сжатие данных используя deflate, без установки zlib заголовка.

</p>
<h2>Класс: zlib.InflateRaw<span><a class="mark" href="#all_zlib_inflateraw" id="all_zlib_inflateraw">#</a></span></h2>
<p>Расспаковка raw deflate потока.

</p>
<h2>Класс: zlib.Unzip<span><a class="mark" href="#all_zlib_unzip" id="all_zlib_unzip">#</a></span></h2>
<p>Расспаковка либо Gzip-, либо Deflate-сжатого потока с 
автоматическим определением заголовка.

</p>
<h2>Удобные методы<span><a class="mark" href="#all_34" id="all_34">#</a></span></h2>
<!--type=misc-->

<p>Все удобные методы в качестве первого аргумента принимают строки или буферы,
и возвращают результат вызывая функцию обратного вызова 
с параметрами <code>callback(error, result)</code>. Движки компрессии/декомпрессии создаются
с настройками по умолчанию. Для использования различных настроек пользуйтесь
Zlib классами напрямую.

</p>
<h2>zlib.deflate(buf, callback)<span><a class="mark" href="#all_zlib_deflate_buf_callback" id="all_zlib_deflate_buf_callback">#</a></span></h2>
<p>Сжатие строки используя Deflate.

</p>
<h2>zlib.deflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_deflateraw_buf_callback" id="all_zlib_deflateraw_buf_callback">#</a></span></h2>
<p>Сжатие строки используя DeflateRaw.

</p>
<h2>zlib.gzip(buf, callback)<span><a class="mark" href="#all_zlib_gzip_buf_callback" id="all_zlib_gzip_buf_callback">#</a></span></h2>
<p>Сжатие строки используя Gzip.

</p>
<h2>zlib.gunzip(buf, callback)<span><a class="mark" href="#all_zlib_gunzip_buf_callback" id="all_zlib_gunzip_buf_callback">#</a></span></h2>
<p>Распаковка raw Buffer используя Gunzip.

</p>
<h2>zlib.inflate(buf, callback)<span><a class="mark" href="#all_zlib_inflate_buf_callback" id="all_zlib_inflate_buf_callback">#</a></span></h2>
<p>Распаковка raw Buffer используя Inflate.

</p>
<h2>zlib.inflateRaw(buf, callback)<span><a class="mark" href="#all_zlib_inflateraw_buf_callback" id="all_zlib_inflateraw_buf_callback">#</a></span></h2>
<p>Распаковка raw Buffer используя InflateRaw.

</p>
<h2>zlib.unzip(buf, callback)<span><a class="mark" href="#all_zlib_unzip_buf_callback" id="all_zlib_unzip_buf_callback">#</a></span></h2>
<p>Распаковка raw Buffer используя Unzip.

</p>
<h2>Опции<span><a class="mark" href="#all_35" id="all_35">#</a></span></h2>
<!--type=misc-->

<p>Каждый класс может принимать объект с параметрами. Все параметры являются 
опциональными. (Удобные методы использую настройки по умолчанию для всех опций).

</p>
<p>Обратите внимание что часть опций доступна только для сжатия, и игнорируются
классами распаковщиками.

</p>
<ul>
<li>chunkSize (default: 16*1024)</li>
<li>windowBits</li>
<li>level (compression only)</li>
<li>memLevel (compression only)</li>
<li>strategy (compression only)</li>
</ul>
<p>Смотри описание о <code>deflateInit2</code> и <code>inflateInit2</code> на
</p>
<p><a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> для большей информации о них.

</p>
<h2>Настройки использования памяти<span><a class="mark" href="#all_36" id="all_36">#</a></span></h2>
<!--type=misc-->

<p>Файл <code>zlib/zconf.h</code>, изменен для использования nodejs:

</p>
<p>Требования к памяти для deflate (в байтах):

</p>
<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<p>это: 128K для windowBits=15  +  128K для memLevel = 8
(по умолчанию) плюс несколько килобайт для небольших объектов.

</p>
<p>Например, если вы хотите уменьшить требования к памяти по умолчанию
с 256K до 128K, установите параметры:

</p>
<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>
<p>Конечно это как правило ухудшает сжатие (there&apos;s no free lunch).

</p>
<p>Требования памяти при inflate (в байтах)

</p>
<pre><code>1 &lt;&lt; windowBits</code></pre>
<p>это, 32K для windowBits=15 (по умолчанию) плюс несколько килобайт
для небольших объектов.

</p>
<p>Это в дополнение к одиночной части исходящего буффера размером <code>chunkSize</code>,
который по умолчанию 16К.

</p>
<p>На скорость сжатия Zlib существенно влияет настройки <code>уровня сжатия</code>. 
Высокий уровень дает лучшее сжатие, но занимает больше времени. Низкий
уровень дает меньше сжатие, но может быть намного быстрее.

</p>
<p>В общем, варианты настроек с большим расходом памяти означают, что node 
может делать меньше вызовов zlib, и значит сможет обработать больше данных
за одину операцию <code>записи</code>. Так что, это еще один фактор влияющим на
скорость, за счет увеличения использования памяти.
</p>
<h1>Операционная система<span><a class="mark" href="#all_37" id="all_37">#</a></span></h1>
<p>Этот модуль содержит функции для определения параметров операционной системы.

</p>
<p>Используйте <code>require(&apos;os&apos;)</code> чтобы получить к нему доступ.

</p>
<h2>os.hostname()<span><a class="mark" href="#all_os_hostname" id="all_os_hostname">#</a></span></h2>
<p>Возвращает имя компьютера в сети.

</p>
<h2>os.type()<span><a class="mark" href="#all_os_type" id="all_os_type">#</a></span></h2>
<p>Возвращает имя операционной системы.

</p>
<h2>os.platform()<span><a class="mark" href="#all_os_platform" id="all_os_platform">#</a></span></h2>
<p>Возвращает платформу операционной системы.

</p>
<h2>os.arch()<span><a class="mark" href="#all_os_arch" id="all_os_arch">#</a></span></h2>
<p>Возвращает архитектуру CPU, используемую операционной системой.

</p>
<h2>os.release()<span><a class="mark" href="#all_os_release" id="all_os_release">#</a></span></h2>
<p>Возвращает версию операционной системы.

</p>
<h2>os.uptime()<span><a class="mark" href="#all_os_uptime" id="all_os_uptime">#</a></span></h2>
<p>Возвращает время работы системы в секундах с последней перезагрузки.

</p>
<h2>os.loadavg()<span><a class="mark" href="#all_os_loadavg" id="all_os_loadavg">#</a></span></h2>
<p>Возвращает массив, содержащия среднюю загрузку системы за последние 1, 5 и 15 минут.

</p>
<h2>os.totalmem()<span><a class="mark" href="#all_os_totalmem" id="all_os_totalmem">#</a></span></h2>
<p>Возвращает полный объём памяти, доступной системе.

</p>
<h2>os.freemem()<span><a class="mark" href="#all_os_freemem" id="all_os_freemem">#</a></span></h2>
<p>Возвращает объём свободной памяти.

</p>
<h2>os.cpus()<span><a class="mark" href="#all_os_cpus" id="all_os_cpus">#</a></span></h2>
<p>Возвращает массив объектов, содержащих информацию о каждом процессоре/ядре системы:
модель, частоту в мегагерцах и время в тиках,
проводимое в состояниях user, nice, sys, idle и irq.

</p>
<p>Example inspection of os.cpus:

</p>
<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<h2>os.networkInterfaces()<span><a class="mark" href="#all_os_networkinterfaces" id="all_os_networkinterfaces">#</a></span></h2>
<p>Ворвращает список сетевых интерфейсов:

</p>
<pre><code>{ lo0: 
   [ { address: &apos;::1&apos;, family: &apos;IPv6&apos;, internal: true },
     { address: &apos;fe80::1&apos;, family: &apos;IPv6&apos;, internal: true },
     { address: &apos;127.0.0.1&apos;, family: &apos;IPv4&apos;, internal: true } ],
  en1: 
   [ { address: &apos;fe80::cabc:c8ff:feef:f996&apos;, family: &apos;IPv6&apos;,
       internal: false },
     { address: &apos;10.0.1.123&apos;, family: &apos;IPv4&apos;, internal: false } ],
  vmnet1: [ { address: &apos;10.99.99.254&apos;, family: &apos;IPv4&apos;, internal: false } ],
  vmnet8: [ { address: &apos;10.88.88.1&apos;, family: &apos;IPv4&apos;, internal: false } ],
  ppp0: [ { address: &apos;10.2.0.231&apos;, family: &apos;IPv4&apos;, internal: false } ] }</code></pre>
<h2>Встроенный отладчик<span><a class="mark" href="#all_38" id="all_38">#</a></span></h2>
<p>Вместе с V8 идет мощный отладчик, доступный прямо в процессе выполнения
через простой <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP протокол</a>.
В Node есть встроенный клиент для этого отладчика. Чтобы его использовать,
запустите Node с ключом <code>debug</code>; появится следующее приглашение:

</p>
<pre><code>% node debug myscript.js
debug&gt;</code></pre>
<p>Пока <code>myscript.js</code> ещё не запущен. Чтобы запустить скрипт, введите команду <code>run</code>.
Если всё в порядке, вывод будет выглядеть примерно так:

</p>
<pre><code>% node debug myscript.js
debug&gt; run
debugger listening on port 5858
connecting...ok</code></pre>
<p>Отладчик Node не поддерживает полный набор команд но выполнение и просмотр окружения
вполне возможны. Добавив строку <code>debugger;</code> в исходный код, вы добавляете точку остановки.

</p>
<p>Например, предположим что <code>myscript.js</code> выглядит так:

</p>
<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;world&quot;);
}, 1000);
console.log(&quot;hello&quot;);</code></pre>
<p>При запуске в режиме отладки остановка произойдёт на четвёртой строке.

</p>
<pre><code>% ./node debug myscript.js
debug&gt; run
debugger listening on port 5858
connecting...ok
hello
break in #&lt;an Object&gt;._onTimeout(), myscript.js:4
  debugger;
  ^
debug&gt; next
break in #&lt;an Object&gt;._onTimeout(), myscript.js:5
  console.log(&quot;world&quot;);
  ^
debug&gt; print x
5
debug&gt; print 2+2
4
debug&gt; next
world
break in #&lt;an Object&gt;._onTimeout() returning undefined, myscript.js:6
}, 1000);
^
debug&gt; quit
A debugging session is active. Quit anyway? (y or n) y
%</code></pre>
<p>Команда <code>print</code> позволяет просматривать переменные. Команда <code>next</code> выполняет
следующую строку скрипта. Кроме этого доступно ещё несколько команд, и ещё больше
будут добавлены. Введите <code>help</code> чтобы увидеть остальные.

</p>
<h3>Продвинутое использование<span><a class="mark" href="#all_39" id="all_39">#</a></span></h3>
<p>Отладчик V8 может быть включен и использован либо при запуске Node с ключом <code>--debug</code>
или при передаче существующему процессу Node сигнала <code>SIGUSR1</code>.


</p>
<h1>Cluster<span><a class="mark" href="#all_cluster" id="all_cluster">#</a></span></h1>
<p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.

</p>
<p>The cluster module allows you to easily create a network of processes that
all share server ports.

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);
var numCPUs = require(&apos;os&apos;).cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on(&apos;death&apos;, function(worker) {
    console.log(&apos;worker &apos; + worker.pid + &apos; died&apos;);
  });
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}</code></pre>
<p>Running node will now share port 8000 between the workers:

</p>
<pre><code>% node server.js
Worker 2438 online
Worker 2437 online</code></pre>
<p>The difference between <code>cluster.fork()</code> and <code>child_process.fork()</code> is simply
that cluster allows TCP servers to be shared between workers. <code>cluster.fork</code>
is implemented on top of <code>child_process.fork</code>. The message passing API that
is available with <code>child_process.fork</code> is available with <code>cluster</code> as well.
As an example, here is a cluster which keeps count of the number of requests
in the master process via message passing:

</p>
<pre><code>var cluster = require(&apos;cluster&apos;);
var http = require(&apos;http&apos;);
var numReqs = 0;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; 2; i++) {
    var worker = cluster.fork();

    worker.on(&apos;message&apos;, function(msg) {
      if (msg.cmd &amp;&amp; msg.cmd == &apos;notifyRequest&apos;) {
        numReqs++;
      }
    });
  }

  setInterval(function() {
    console.log(&quot;numReqs =&quot;, numReqs);
  }, 1000);
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
    // Send message to master process
    process.send({ cmd: &apos;notifyRequest&apos; });
  }).listen(8000);
}</code></pre>
<h2>cluster.fork()<span><a class="mark" href="#all_cluster_fork" id="all_cluster_fork">#</a></span></h2>
<p>Spawn a new worker process. This can only be called from the master process.

</p>
<h2>cluster.isMaster<span><a class="mark" href="#all_cluster_ismaster" id="all_cluster_ismaster">#</a></span></h2>
<h2>cluster.isWorker<span><a class="mark" href="#all_cluster_isworker" id="all_cluster_isworker">#</a></span></h2>
<p>Boolean flags to determine if the current process is a master or a worker
process in a cluster. A process <code>isMaster</code> if <code>process.env.NODE_WORKER_ID</code>
is undefined.

</p>
<h2>Event: &apos;death&apos;<span><a class="mark" href="#all_event_death" id="all_event_death">#</a></span></h2>
<p>When any of the workers die the cluster module will emit the &apos;death&apos; event.
This can be used to restart the worker by calling <code>fork()</code> again.

</p>
<pre><code>cluster.on(&apos;death&apos;, function(worker) {
  console.log(&apos;worker &apos; + worker.pid + &apos; died. restart...&apos;);
  cluster.fork();
});</code></pre>
<p>Different techniques can be used to restart the worker depending on the
application.

</p>
<h1>Приложение 1 - Рекомендуемые сторонние модули<span><a class="mark" href="#all_1" id="all_1">#</a></span></h1>
<p>Для Node есть множество модулей.
Их список можно найти в <a href="https://github.com/joyent/node/wiki/modules">вики на GitHub</a>.

</p>
<p>Это приложение предназначено для новичков, чтобы помочь им быстро найти
качественные модули. Этот список не претендует на полноту. Мы будем рады
дополнениям к этому списку.

</p>
<ul>
<li><p>Менеджер/регистр модулей: <a href="https://github.com/isaacs/npm">npm</a></p>
</li>
<li><p>https Middleware: <a href="https://github.com/senchalabs/connect">Connect</a></p>
</li>
<li><p>Web-фреймворк: <a href="https://github.com/visionmedia/express">Express</a></p>
</li>
<li><p>Web-сокеты: <a href="https://github.com/LearnBoost/Socket.IO-node">Socket.IO</a></p>
</li>
<li><p>Работа с DOM: <a href="https://github.com/aredridel/html5">HTML5</a></p>
</li>
<li><p><a href="https://github.com/agnat/node_mdns">mDNS/Zeroconf/Bonjour</a></p>
</li>
<li><p><a href="https://github.com/ry/node-amqp">RabbitMQ, AMQP</a></p>
</li>
<li><p>MySQL: <a href="https://github.com/felixge/node-mysql">на чистом Javascript</a>,
<a href="https://github.com/Sannis/node-mysql-libmysqlclient">на основе libmysqlclient</a>.</p>
</li>
<li><p>Сериализация: <a href="https://github.com/pgriess/node-msgpack">msgpack</a></p>
</li>
<li><p>Парсинг HTML: <a href="https://github.com/silentrob/Apricot">Apricot</a></p>
</li>
<li><p>Отладка: <a href="https://github.com/smtlaissezfaire/ndb">ndb</a> — консольный отладчик,
<a href="https://github.com/dannycoates/node-inspector">inspector</a> — web-based инструмент.</p>
</li>
<li><p><a href="https://github.com/mranney/node_pcap">pcap binding</a></p>
</li>
<li><p><a href="https://github.com/mscdex/node-ncurses">ncurses</a></p>
</li>
<li><p>Тестирование/TDD/BDD: <a href="http://vowsjs.org/">vows</a>,
<a href="https://github.com/visionmedia/expresso">expresso</a>,
<a href="https://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p>
</li>
</ul>

          </div>
        </div>
    </div>
    <div id="footer">
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/#download">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://search.npmjs.org/">npm Registry</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>&copy; 2010 <a href="http://joyent.com">Joyent, Inc</a>, Node.js является <a href="http://nodejs.org/trademark-policy.pdf">торговой маркой</a> Joyent, Inc. Подробную информацию вы можете прочитать в <a href="https://raw.github.com/joyent/node/v0.6.x/LICENSE">лицензии</a>.</p>
        
        <p>Перевод &copy; 2010 <a href="https://github.com/kurokikaze/nodejs-docs-rus/contributors">соавтороами</a> репозитория <a href="https://github.com/kurokikaze/nodejs-docs-rus">github.com/kurokikaze/nodejs-docs-rus</a>.</p>
    </div>

    <script src="assets/sh_main.js"></script>
    <script src="assets/sh_javascript.min.js"></script>
    <script>highlight(undefined, undefined, 'pre');</script>
    <!-- Yandex.Metrika --> 
    <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script> 
    <script type="text/javascript"> 
    try { var yaCounter612423 = new Ya.Metrika(612423); } catch(e){}
    </script> 
    <noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/612423" alt="" /></div></noscript> 
    <!-- /Yandex.Metrika -->  
</body>
</html>

