<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>tls - Node.js &mdash; Документация</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all" />
</head>
<body>
  <a href="http://github.com/kurokikaze/nodejs-docs-rus"><img style="position: absolute; top: 0; left: 0; border: 0;" src="assets/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <div id="container">
    <header>
      <h1>Node.js &mdash; Документация</h1>
      <div id="gtoc">
        <p><a href="index.html">Содержание</a> | <a href="all.html">Просмотреть на одной странице</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Содержание</h2><ul><li><a href="#tLS_">TLS (SSL)</a><ul><li><a href="#s_tls.connect">s = tls.connect(port, [host], [options], callback)</a></li><li><a href="#sTARTTLS">STARTTLS</a></li><li><a href="#tls.Server">tls.Server</a><ul><li><a href="#tls.createServer">tls.createServer(options, secureConnectionListener)</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_secureConnection_">Событие: 'secureConnection'</a></li><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li></ul></li></ul></li></ul><hr /></div>
<h2 id="tLS_">TLS (SSL)</h2>

<p>Используйте <code>require('tls')</code> чтобы получить доступ к функциям этого модуля.</p>

<p>Модуль <code>tls</code> использует OpenSSL чтобы предоставить Transport Layer Security и/или
Secure Socket Layer (SSL): зашифрованные соединения.</p>

<p>TLS/SSL это инфраструктура с публичными ключами. Каждый клиент и каждый сервер должны иметь собственный приватный ключ. Приватный ключ создаётся таким образом:</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>

<p>Все серверы и некоторые клиенты должны иметь сертификат. Сертификаты это публичные ключи подписанные Центром Сертификации или самим создателем сертификата. Первый шаг в получени сертификата: создание файла запроса на подпись сертификата (CSR, Certificate Signing Request). Это делается следующим образом:</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>

<p>Чтобы создать самостоятельно подписанный сертификат CSR, сделайте:</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>

<p>Либо Вы можете отправить CSR в Центр Сертификации для подписи.</p>

<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)</p>

<h3 id="s_tls.connect">s = tls.connect(port, [host], [options], callback)</h3>

<p>Создаёт новое соединение на выбранный порт и хост (хост по умолчанию - <code>localhost</code>). Опции <code>options</code> должны быть объектом, содержащим</p>

<ul><li><p><code>key</code>: Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)</p></li><li><p><code>cert</code>: Строка или буфер содержащие ключ сертификата сервера в формате PEM.</p></li><li><p><code>ca</code>: Массив строк или буферов с доверенными сертификатами. Если этот массив пропущен, будут использованы "корневые" Центры Сертификации, например VeriSign. Они будут использованы для авторизации соединения.</p></li></ul>

<p><code>tls.connect()</code> возвращает текстовый объект <code>CryptoStream</code>.</p>

<p>После рукопожатия TLS/SSL вызывается переданная функция. Вызов произойдёт независимо от того был ли авторизрван сертификат. Пользователь сам должен проверить значение <code>s.authorized</code> чтобы увидеть был ли сертификат подписан одним из указанных центров. Если <code>s.authorized === false</code> то в переменной <code>s.authorizationError</code> будет содержаться объект соответствующей ошибки.</p>

<h3 id="sTARTTLS">STARTTLS</h3>

<p>В ветке v0.4 нет функций для начала TLS-сессии для существующего TCP-соединения.
Тем не менее это возможно сделать. техника состоит в вызове <code>tls.createSecurePair()</code>,
который возвратит два потока: шифрованный и текстовый. Далее вам необходимо
перенаправить шифрованный поток в сокет, а в приложении использовать текстовый.</p>

<p><a href="http://gist.github.com/848444">Пример использование этой техники</a>.</p>

<h3 id="tls.Server">tls.Server</h3>

<p>Этот класс - подкласс <code>net.Server</code> и имеет те же методы. Вместо приёма простых TCP соединений он принимает защищённые соединения с использованием TLS или SSL.</p>

<p>Простой пример эхо-сервера (возвращает полученные данные):</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
};

tls.createServer(options, function (s) {
  s.write("welcome!\n");
  s.pipe(s);
}).listen(8000);</code></pre>

<p>Вы можете проверить сервер, присоединившись к нему с помощью <code>openssl s_client</code>:</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>

<h4 id="tls.createServer">tls.createServer(options, secureConnectionListener)</h4>

<p>Это конструктор для класса <code>tls.Server</code>. Объект опций может содержать следующие значения:</p>

<ul><li><p><code>key</code>:  Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)</p></li><li><p><code>cert</code>: Строка или буфер содержащие ключ сертификата сервера в формате PEM.</p></li><li><p><code>ca</code>: Массив строк или буферов с доверенными сертификатами. Если этот массив пропущен, будут использованы "корневые" Центры Сертификации, например VeriSign. Они будут использованы для авторизации соединения.</p></li><li><p><code>requestCert</code>: Если принимает значение <code>true</code> сервер будет запрашивать у клиентов сертификаты и пытаться проверять их подлинность. По умолчанию принимает значение <code>false</code>.</p></li><li><p><code>rejectUnauthorized</code>: Если равно <code>true</code> сервер будет сбрасывать соединения сертификаты которых не подтверждены списком доверенных Центров Сертификации. Эта опция действует только если <code>requestCert</code> равен <code>true</code>. Значение по умолчанию: <code>false</code>.</p></li></ul>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_secureConnection_">Событие: 'secureConnection'</h4>

<p><code>function (cleartextStream) {}</code></p>

<p>Это событие генерируется при приёме нового соединения после успешного прохождения рукопожатия. Аргумент - экземпляр <code>stream.Stream</code> открытый на чтение и запись. Он имеет все методы и события обычного потока.</p>

<p><code>cleartextStream.authorized</code> - двоичное значение, сообщающее что клиент был проверен одним из заданных для сервера доверенных Центров Сертификации. Если это свойство принимает значение <code>false</code>, в <code>cleartextStream.authorizationError</code> будет храниться ошибка авторизации. Стоит заметить что в зависимости от настроек TLS-сервера неавторизованные соединения могут приниматься либо сбрасываться.</p>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Начинает приём соединений на указанном порту и адресе. Если адрес не указан, сервер принимает соединения на любой адрес IPv4 (<code>INADDR_ANY</code>).</p>

<p>Эта функция асинхронна. Коллбек, переданный последним параметром, будет вызван когда сервер будет готов к приёму соединений.</p>

<p>См. <code>net.Server</code> для дальнейшей информации.</p>

<h4 id="server.close">server.close()</h4>

<p>Прекращает приём новых соединений сервером. Эта функция асинхронна, сервер окончательно закрывается когда генерируется событие <code>'close'</code>.</p>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Задайте это свойство чтобы сбрасывать новые соединения как только количество одновременных соединений достигнет указанного значения.</p>

<h4 id="server.connections">server.connections</h4>

<p>Число одновременных соединений с сервером.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
  <!-- Yandex.Metrika --> 
  <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script> 
  <script type="text/javascript"> 
  try { var yaCounter612423 = new Ya.Metrika(612423); } catch(e){}
  </script> 
  <noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/612423" alt="" /></div></noscript> 
  <!-- /Yandex.Metrika -->   
</body>
</html>
