<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>net - Node.js &mdash; Документация</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all" />
</head>
<body>
<a href="http://github.com/kurokikaze/nodejs-docs-rus"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://assets0.github.com/img/ce742187c818c67d98af16f96ed21c00160c234a?repo=&url=http%3A%2F%2Fs3.amazonaws.com%2Fgithub%2Fribbons%2Fforkme_left_gray_6d6d6d.png&path=" alt="Fork me on GitHub"></a>
  <div id="container">
    <header>
      <h1>Node.js &mdash; Документация</h1>
      <div id="gtoc">
        <p><a href="index.html">Содержание</a> | <a href="all.html">Просмотреть на одной странице</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Содержание</h2><ul><li><a href="#tCP_u0421_u0435_u0442_u044C">TCP / Сеть</a><ul><li><a href="#net.createServer">net.createServer(connectionListener)</a></li><li><a href="#net.createConnection">net.createConnection(arguments...)</a></li><li><a href="#net.Server">net.Server</a><ul><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.listenFD">server.listenFD(fd)</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.address">server.address()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connection_">Событие: 'connection'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</a></li></ul></li><li><a href="#net.Socket">net.Socket</a><ul><li><a href="#socket.connect">socket.connect(port, [host])</a></li><li><a href="#socket.connect">socket.connect(path)</a></li><li><a href="#socket.bufferSize">socket.bufferSize</a></li><li><a href="#socket.setEncoding">socket.setEncoding(encoding=null)</a></li><li><a href="#socket.setSecure">socket.setSecure([credentials])</a></li><li><a href="#socket.write">socket.write(data, [encoding], [callback])</a></li><li><a href="#socket.write">socket.write(data, [encoding], [fileDescriptor], [callback])</a></li><li><a href="#socket.end">socket.end([data], [encoding])</a></li><li><a href="#socket.destroy">socket.destroy()</a></li><li><a href="#socket.pause">socket.pause()</a></li><li><a href="#socket.resume">socket.resume()</a></li><li><a href="#socket.setTimeout">socket.setTimeout(timeout, [callback])</a></li><li><a href="#socket.setNoDelay">socket.setNoDelay(noDelay=true)</a></li><li><a href="#socket.setKeepAlive">socket.setKeepAlive(enable=false, [initialDelay])</a></li><li><a href="#socket.remoteAddress">socket.remoteAddress</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connect_">Событие: 'connect'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_timeout_">Событие: 'timeout'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_drain_">Событие: 'drain'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_error_">Событие: 'error'</a></li><li><a href="#_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</a></li></ul></li><li><a href="#net.isIP">net.isIP</a><ul><li><a href="#net.isIP">net.isIP(input)</a></li><li><a href="#net.isIPv4">net.isIPv4(input)</a></li><li><a href="#net.isIPv6">net.isIPv6(input)</a></li></ul></li></ul></li></ul><hr /></div>
<h2 id="tCP_u0421_u0435_u0442_u044C">TCP / Сеть</h2>

<p>Модуль <code>net</code> предоставляет асинхронные методы для работы с сетью. Он включает
методы для создания как серверов, так и клиентов (называемых потоками).
Вы может использовать этот модуль вызвав <code>require("net")</code>.</p>

<h3 id="net.createServer">net.createServer(connectionListener)</h3>

<p>Создаёт новый TCP сервер. Аргумент <code>connection_listener</code> автоматически
становится обработчиком события <code>'connection'</code>.</p>

<h3 id="net.createConnection">net.createConnection(arguments...)</h3>

<p>Создаёт новый сокет. Когда соединение установлено, будет сгенерировано
событие <code>'connect'</code>.</p>

<p>Аргументы для этого метода определяются тепим соединения:</p>

<ul><li><p><code>net.createConnection(port, [host])</code></p><p>Открывает TCP-соединение с указанным портом <code>port</code> и адресом <code>host</code>.
Если второй параметр не задан, предполагается значение <code>localhost</code>.</p></li><li><p><code>net.createConnection(path)</code></p><p>Создаёт соединение с Unix-сокетом <code>path</code>.</p></li></ul>

<hr />

<h3 id="net.Server">net.Server</h3>

<p>Этот класс используется для создания TCP или UNIX сервера.</p>

<p>Вот простой пример сервера, который возвращает полученный запрос
и слушает на порту 8124:</p>

<pre><code>var net = require('net');
var server = net.createServer(function (stream) {
var server = net.createServer(function (c) {
  c.write('hello\r\n');
  c.pipe(c);
});
server.listen(8124, 'localhost');</code></pre>

<p>Проверить работу сервера можно с помощью <code>telnet</code>:</p>

<pre><code>telnet localhost 8124</code></pre>

<p>Чтобы слушать сокет <code>'/tmp/echo.sock'</code>, последнюю строку скрипта надо заменить на</p>

<pre><code>server.listen('/tmp/echo.sock');</code></pre>

<p>Для подключения к UNIX-сокеты используйте <code>nc</code>:</p>

<pre><code>nc -U /tmp/echo.sock</code></pre>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Начинает принимать соединения на указанном порту <code>port</code> и имени хоста <code>host</code>.
Если <code>host</code> пропущен, сервер будет принимать соединения
на каждом IPv4-адресе (INADDR_ANY).</p>

<p>Эта функция асинхронна. Последний параметр <code>callback</code> будет вызван когда сервер
начнёт принимать соединения.</p>

<h4 id="server.listen">server.listen(path, [callback])</h4>

<p>Запускает сервер слушающий UNIX-сокет по указанному адресу <code>path</code>.</p>

<p>Эта функция асинхронна. Последний параметр <code>callback</code> будет вызван когда сервер
начнёт принимать соединения.</p>

<p>Часто пользователи сообщают об ошибке <code>EADDRINUSE</code>. Она означает, что на этом порту
уже запущен другой сервер. Одним из способов обработки ошибки <code>EADDRINUSE</code> является
ожидание в течении, напрмиер, одной секунды и повторная попытка вызова <code>server.listen</code>.
Это можно сделать с помощью следующего кода:</p>

<pre><code>server.on('error', function (e) {
  if (e.code == 'EADDRINUSE') {
    console.log('Address in use, retrying...');
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>

<p>ПРИМЕЧАНИЕ: Все сокеты в Node имеют установленную опцию SO_REUSEADDR.</p>

<h4 id="server.listenFD">server.listenFD(fd)</h4>

<p>Запускает сервер, слушающий указанный файловый дескриптор.</p>

<p>Для указанного файлового дескриптора должны быть уже выполнены
системные вызовы <code>bind(2)</code> и <code>listen(2)</code>.</p>

<h4 id="server.close">server.close()</h4>

<p>Прекращает приём соединений сервером. Эта функция асинхронна,
сервер полностью закрывается только после генерации события <code>'close'</code>.</p>

<h4 id="server.address">server.address()</h4>

<p>Возвращает адрес, к которому привязан сервер. Удобно использовать, если выбор
адреса предоставляется системе.</p>

<p>Пример:</p>

<pre><code>var server = net.createServer(function (socket) {
  socket.end("goodbye\n");
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log("opened server on %j", address);
});</code></pre>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Установите это свойство, если хотите запретить серверу принимать
больше определённого числа соединений единовременно.</p>

<h4 id="server.connections">server.connections</h4>

<p>Текущее число соединений с сервером.</p>

<hr />

<p><code>net.Server</code> — экземпляр <code>EventEmitter</code> со следующими событиями:</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connection_">Событие: 'connection'</h4>

<p><code>function (socket) {}</code></p>

<p>Генерируется при новом соединении. <code>socket</code> — экземпляр <code>net.Socket</code>.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</h4>

<p><code>function () {}</code></p>

<p>Генерируется при завершении работы сервера.</p>

<hr />

<h3 id="net.Socket">net.Socket</h3>

<p>Этот объект — абстракция TCP порта или UNIX сокета. Экземпляр <code>net.Socket</code>
имеет возможность как чтения, так и записи. Он может быть создан и использован
как клиентом (с помощью <code>connect()</code>) либо создан внутри Node и передан
пользователю через обработчик события <code>'connection'</code>.</p>

<h4 id="socket.connect">socket.connect(port, [host])</h4>

<h4 id="socket.connect">socket.connect(path)</h4>

<p>Открывает TCP-соединение с указанным портом <code>port</code> и адресом <code>host</code>. Если второй
параметр не задан, предполагается значение <code>localhost</code>. Если указан параметр
<code>path</code>, то создаёт соединение с Unix-сокетом <code>path</code>.</p>

<p>Обычно этот метод не нужен. Используйте его только если поток закрыт и вы хотите
повторно использовать тот же объект для соединения с другим сервером.</p>

<p>Эта функция асинхронна. Когда генерируется событие <code>'connect'</code>, соединение
установлено. Если при соединении возникли проблемы, событие <code>'connect'</code>
не будет сгенерировано, вместо него будет сгенерировано событие <code>'error'</code>
с аргументом исключения.</p>

<p>Функция <code>callback</code> будет добавлена как обработчик события <code>'connect'</code>.</p>

<h4 id="socket.bufferSize">socket.bufferSize</h4>

<p><code>net.Socket</code> имеет свойство, которое постоянно используется в <code>socket.write()</code>.
Это нужно для быстрой работы Node. Компьютер не может самостоятельно определить,
сколько данных реально записано в сокет, так как сетевые соединения могут быть
очень медленными. Node содержит очередь записи для сокетов и производит её
при первой же возможности. (Внутри это представялет из себя polling файлового
дескриптора сокета на предмет возможности записи).</p>

<p>ЕСледствием этой внутренней буферизации является возможное увеличение затрат памяти.
Это совйство (<code>bufferSize</code>) показывает количество символов, которые содержатся
на данный момент в очереди на запись. (Количество символов примерно равно количеству
байтов, однако в буфере могут находиться строки и тогда это не совсем верно).</p>

<p>Если вы наблюдаете большую величину <code>bufferSize</code> или её быстрое увеличение, то вы
можете попробовать посылать данные порциями ("throttle"), используя методы <code>pause()</code> и resume()`.</p>

<h4 id="socket.setEncoding">socket.setEncoding(encoding=null)</h4>

<p>Задаёт кодировку (<code>'ascii'</code>, <code>'utf8'</code> или <code>'base64'</code>) для принимаемых данных.</p>

<h4 id="socket.setSecure">socket.setSecure([credentials])</h4>

<p>Эта функция удалена в v0.3. Она использовалась для установки защищённого соединения.
См. модуль TLS с описанием нового API.</p>

<h4 id="socket.write">socket.write(data, [encoding], [callback])</h4>

<p>Отправляет данные в поток. Второй параметр означает кодировку, если первым
параметром передана строка. По умолчанию используется UTF-8.</p>

<p>Возвращает <code>true</code> если все данные были успешно переданы в буфер ядра. Возвращает
<code>false</code> если все данные или их часть были помещены в очередь в памяти. Событие
<code>'drain'</code> будет сгенерировано когда буфер ядра снова будет пуст.</p>

<p>Необязательый параметр-функци <code>callback</code> будет вызвана после завершения записи данных.</p>

<h4 id="socket.write">socket.write(data, [encoding], [fileDescriptor], [callback])</h4>

<p>UNIX-сокеты позволяют передавать через них файловые дескрипторы между приложениями.
Для этого достаточно передать параметр <code>fileDescriptor</code> и ожидать события <code>'fd'</code>
во втором приложении.</p>

<h4 id="socket.end">socket.end([data], [encoding])</h4>

<p>Наполовину закрывает соединение, т.е. отправляет пакет FIN. Возможно сервер ещё
получит какие-то данные.</p>

<p>Если определён аргумент <code>data</code>, то этот вызов эквивалентен последовательному вызову
<code>socket.write(data, encoding)</code> и <code>socket.end()</code>.</p>

<h4 id="socket.destroy">socket.destroy()</h4>

<p>Закрывает сокет таким образом чтобы в нём больше не происходило ввода-вывода.
Необходимо только для закрытия соединения в случае серьёзных ошибок.</p>

<h4 id="socket.pause">socket.pause()</h4>

<p>Приостанавливает чтение данных. Т.е. события 'data' не будут генерироваться.
Используется при приёме файлов.</p>

<h4 id="socket.resume">socket.resume()</h4>

<p>Возобновляет чтение данных после вызова pause().</p>

<h4 id="socket.setTimeout">socket.setTimeout(timeout, [callback])</h4>

<p>Устанавливает таймаут в <code>timeout</code> миллисекунд бездействия сокета. По умолчанию
<code>net.Stream</code> не имеет таймаута.</p>

<p>Если сокет не будет проявлять активности указанное количество миллисекунд будет
сгенерировано событие <code>'timeout'</code>, но само соединение не будет затронуто.
Пользователь должен самостоятельно вызвать <code>end()</code> или <code>destroy()</code> для закрытия сокета.</p>

<p>Если в качестве <code>timeout</code> передан 0, существующий таймаут перестаёт действовать.</p>

<p>Необязательный аргумент <code>callback</code> будет добавлен в качестве обработчика события <code>'timeout'</code>.</p>

<h4 id="socket.setNoDelay">socket.setNoDelay(noDelay=true)</h4>

<p>Выключает алгоритм Нагла. По умолчанию TCP-соединения используют алгоритм Нагла,
собирая данные в буфер перед отправкой. Установка noDelay приведёт к немедленной
отправке всех данных, передаваемых в <code>stream.write()</code>.</p>

<h4 id="socket.setKeepAlive">socket.setKeepAlive(enable=false, [initialDelay])</h4>

<p>Включает/выключает функционал keep-alive, и дополнительно позволяет установить
начальную задержку после которой будет отправлен первый пакет проверки соединения
при неактивности. Значение <code>initialDelay</code> (в миллисекундах) означает интервал
между последним отправленным пакетом и первой проверкой соединения. Установка
<code>initialDelay</code> в 0 оставит в силе предыдущее значение.</p>

<h4 id="socket.remoteAddress">socket.remoteAddress</h4>

<p>Строковое представление удалённого IP адреса. Например, <code>'74.125.127.100'</code> или
<code>'2001:4860:a005::68'</code>.</p>

<p>Это свойство доступно только для соединений сервер-сервер.</p>

<hr />

<p>Экземпляры <code>net.Stream</code> — экземпляры <code>EventEmitter</code> со следующими событиями:</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_connect_">Событие: 'connect'</h4>

<p><code>function () { }</code></p>

<p>Генерируется после успешной установки соединения. См. <code>connect()</code>.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_data_">Событие: 'data'</h4>

<p><code>function (data) { }</code></p>

<p>Генерируется при приёме данных. Аргумент <code>data</code> будет экземпляром <code>Buffer</code>
или <code>String</code>. Кодировка передаваемых данных устанавливается методом
<code>socket.setEncoding()</code>. (См. секцию о <code>потоках с возможностью чтения</code> для
более подробной информации.)</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_end_">Событие: 'end'</h4>

<p><code>function () { }</code></p>

<p>Генерируется когда другой участник соединения посылает пакет FIN.</p>

<p>По умолчанию (<code>allowHalfOpen == false</code>) сокет уничтожает свой файловый дескриптор
после завершения обработки очереди записи. Но если установить <code>allowHalfOpen == true</code>,
то поток не будет автоматически завершаться (<code>end()</code>), т.е. пользоввателю
требуется вручную вызвать <code>end()</code>.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_timeout_">Событие: 'timeout'</h4>

<p><code>function () { }</code></p>

<p>Генерируется если сокет долгое время не используется. Это просто уведомление
о длительной неактивности сокета. Пользователь должен сам закрыть соединение.</p>

<p>См. также: <code>socket.setTimeout()</code>.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_drain_">Событие: 'drain'</h4>

<p><code>function () { }</code></p>

<p>Генерируется когда буфер записи становится пустым (все данные, переданные в поток,
были отправлены получателю). Может быть использоваться для отправки файлов.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_error_">Событие: 'error'</h4>

<p><code>function (exception) { }</code></p>

<p>Генерируется при возникновении ошибки. Сразу после этого будет сгенерировано
событие <code>'close'</code>.</p>

<h4 id="_u0421_u043E_u0431_u044B_u0442_u0438_u0435_close_">Событие: 'close'</h4>

<p><code>function (had_error) { }</code></p>

<p>Генерируется один раз когда поток полностью закрывается. Аргумент had_error —
двоичное значение, устанавливаемое в true если поток был закрыт из за ошибки передачи.</p>

<hr />

<h3 id="net.isIP">net.isIP</h3>

<h4 id="net.isIP">net.isIP(input)</h4>

<p>Проверяет. является ли <code>input</code> валидным IP адресом. Возвращает 0 для неверных строк,
4 для IPv4 адресов и 6 для IPv6 адресов.</p>

<h4 id="net.isIPv4">net.isIPv4(input)</h4>

<p>Возвращает <code>true</code> если <code>input</code> является IPv4 адресов, в осатльных случаях <code>false</code>.</p>

<h4 id="net.isIPv6">net.isIPv6(input)</h4>

<p>Возвращает <code>true</code> если <code>input</code> является IPv6 адресов, в осатльных случаях <code>false</code>.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
  <!-- Yandex.Metrika --> 
  <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript"></script> 
  <script type="text/javascript"> 
  try { var yaCounter612423 = new Ya.Metrika(612423); } catch(e){}
  </script> 
  <noscript><div style="position: absolute;"><img src="//mc.yandex.ru/watch/612423" alt="" /></div></noscript> 
  <!-- /Yandex.Metrika -->   
</body>
</html>
